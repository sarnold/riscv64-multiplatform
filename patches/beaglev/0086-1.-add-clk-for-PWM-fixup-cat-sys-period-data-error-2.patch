From f3c2d9a00c7de27ddfa3689e113645fc84cc21c3 Mon Sep 17 00:00:00 2001
From: "yiming.li" <yiming.li@starfivetech.com>
Date: Fri, 2 Apr 2021 07:48:22 +0000
Subject: [PATCH 86/86] 1. add clk for PWM & fixup cat /sys period data error
 2. Clear PWM CNTR after modified period & duty_cycle

---
 drivers/Makefile             |   2 +-
 drivers/pwm/pwm-sifive-ptc.c | 137 +++++++++++++++++++++--------------
 2 files changed, 84 insertions(+), 55 deletions(-)

diff --git a/drivers/Makefile b/drivers/Makefile
index 576228037718..d4dd277de2ba 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -14,7 +14,6 @@ obj-$(CONFIG_GENERIC_PHY)	+= phy/
 # GPIO must come after pinctrl as gpios may need to mux pins etc
 obj-$(CONFIG_PINCTRL)		+= pinctrl/
 obj-$(CONFIG_GPIOLIB)		+= gpio/
-obj-y				+= pwm/
 
 obj-y				+= pci/
 
@@ -38,6 +37,7 @@ obj-y				+= clk/
 # really early.
 obj-$(CONFIG_DMADEVICES)	+= dma/
 
+obj-y				+= pwm/
 # SOC specific infrastructure drivers.
 obj-y				+= soc/
 
diff --git a/drivers/pwm/pwm-sifive-ptc.c b/drivers/pwm/pwm-sifive-ptc.c
index a8be2a788d63..32672b3f56f6 100644
--- a/drivers/pwm/pwm-sifive-ptc.c
+++ b/drivers/pwm/pwm-sifive-ptc.c
@@ -14,40 +14,40 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 
-#define PTC_DEBUG			0
-
 /* max channel of pwm */
-#define MAX_PWM				8
+#define MAX_PWM								8
 
 /* PTC Register offsets */
-#define REG_RPTC_CNTR			0x0
-#define REG_RPTC_HRC			0x4
-#define REG_RPTC_LRC			0x8
-#define REG_RPTC_CTRL			0xC
+#define REG_RPTC_CNTR 						0x0
+#define REG_RPTC_HRC						0x4
+#define REG_RPTC_LRC						0x8
+#define REG_RPTC_CTRL						0xC
 
 /* Bit for PWM clock */
-#define BIT_PWM_CLOCK_EN		31
+#define BIT_PWM_CLOCK_EN					31
 
 /* Bit for clock gen soft reset */
-#define BIT_CLK_GEN_SOFT_RESET		13
+#define BIT_CLK_GEN_SOFT_RESET				13
+
+#define NS_1                                1000000000
 
-#define NS_1				1000000000
+#define PTC_DEBUG  0
 
 /* Access PTC register (cntr hrc lrc and ctrl) ,need to replace PWM_BASE_ADDR */
-#define REG_PTC_BASE_ADDR_SUB(base, N)	((base) + ((N>3)?((N-4)*0x10+(1<<15)):(N*0x10)))
-#define REG_PTC_RPTC_CNTR(base,N)	(REG_PTC_BASE_ADDR_SUB(base,N))
-#define REG_PTC_RPTC_HRC(base,N)	(REG_PTC_BASE_ADDR_SUB(base,N) + 0x4)
-#define REG_PTC_RPTC_LRC(base,N)	(REG_PTC_BASE_ADDR_SUB(base,N) + 0x8)
-#define REG_PTC_RPTC_CTRL(base,N)	(REG_PTC_BASE_ADDR_SUB(base,N) + 0xC)
+#define REG_PTC_BASE_ADDR_SUB(base, N)    ((base) + ((N>3)?((N-4)*0x10+(1<<15)):(N*0x10))) 
+#define REG_PTC_RPTC_CNTR(base,N)		(REG_PTC_BASE_ADDR_SUB(base,N))
+#define REG_PTC_RPTC_HRC(base,N)			(REG_PTC_BASE_ADDR_SUB(base,N) + 0x4)
+#define REG_PTC_RPTC_LRC(base,N)			(REG_PTC_BASE_ADDR_SUB(base,N) + 0x8)
+#define REG_PTC_RPTC_CTRL(base,N)		(REG_PTC_BASE_ADDR_SUB(base,N) + 0xC)
 
 /* pwm ptc device */
 struct sifive_pwm_ptc_device {
-	struct pwm_chip	chip;
-	struct clk	*clk;
-	void __iomem	*regs;
-	int		irq;
+	struct pwm_chip		chip;
+	struct clk		*clk;
+	void __iomem		*regs;
+	int 			irq;
 	/* apb clock frequency , from dts */
-	unsigned int	approx_period;
+	unsigned int		approx_period;
 };
 
 static inline struct sifive_pwm_ptc_device *chip_to_sifive_ptc(struct pwm_chip *c)
@@ -61,19 +61,19 @@ static void sifive_pwm_ptc_get_state(struct pwm_chip *chip, struct pwm_device *d
 	struct sifive_pwm_ptc_device *pwm = chip_to_sifive_ptc(chip);
 	uint32_t data_lrc;
 	uint32_t data_hrc;
-	uint32_t period;
+	uint32_t period;	
 	uint32_t pwm_clk_ns = 0;
 
 	/* get lrc and hrc data from registe*/
-	data_lrc = ioread32(REG_PTC_RPTC_LRC(pwm->regs, dev->hwpwm));
-	data_hrc = ioread32(REG_PTC_RPTC_HRC(pwm->regs, dev->hwpwm));
-	period = data_lrc + data_hrc;
+	data_lrc = ioread32(REG_PTC_RPTC_LRC(pwm->regs,dev->hwpwm));
+	data_hrc = ioread32(REG_PTC_RPTC_HRC(pwm->regs,dev->hwpwm));
+	//period = data_lrc + data_hrc;
 
 	/* how many ns does apb clock elapse */
 	pwm_clk_ns = NS_1 / pwm->approx_period;
 
 	/* pwm period(ns) */
-	state->period     = period*pwm_clk_ns;
+	state->period     = data_lrc*pwm_clk_ns;
 
 	/* duty cycle(ns) ,means high level eclapse ns if it is normal polarity */
 	state->duty_cycle = data_hrc*pwm_clk_ns;
@@ -83,6 +83,15 @@ static void sifive_pwm_ptc_get_state(struct pwm_chip *chip, struct pwm_device *d
 
 	/* enabled or not */
 	state->enabled    = 1;
+#if PTC_DEBUG   
+	printk("sifive_pwm_ptc_get_state in,no:%d....\r\n",dev->hwpwm);
+	printk("data_hrc:0x%x 0x%x \n", data_hrc, data_lrc);
+        printk("period:%d\r\n",state->period);
+        printk("duty_cycle:%d\r\n",state->duty_cycle);
+        printk("polarity:%d\r\n",state->polarity);
+	printk("enabled:%d\r\n",state->enabled);
+#endif
+
 }
 
 
@@ -96,21 +105,23 @@ static int sifive_pwm_ptc_apply(struct pwm_chip *chip, struct pwm_device *dev, s
 	uint32_t duty_data = 0;
 	void __iomem* reg_addr;
 
-#if PTC_DEBUG
+#if PTC_DEBUG	
 	printk("sifive_pwm_ptc_apply in,no:%d....\r\n",dev->hwpwm);
 	printk("set parameter......\r\n");
 	printk("period:%d\r\n",state->period);
-	printk("duty_cycle:%d\r\n",state->duty_cycle);
+	printk("duty_cycle:%d\r\n",state->duty_cycle);	
 	printk("polarity:%d\r\n",state->polarity);
 	printk("enabled:%d\r\n",state->enabled);
 #endif
 	/* duty_cycle should be less or equal than period */
 	if(state->duty_cycle > state->period)
+	{
 		state->duty_cycle = state->period;
+	}	
 
 	/* calculate pwm real period (ns) */
 	pwm_clk_ns = NS_1 / pwm->approx_period;
-
+	
 #if PTC_DEBUG
 	printk("approx_period,:%d,pwm_clk_ns:%d\r\n",pwm->approx_period,pwm_clk_ns);
 #endif
@@ -118,48 +129,58 @@ static int sifive_pwm_ptc_apply(struct pwm_chip *chip, struct pwm_device *dev, s
 	/* calculate period count */
 	period_data = state->period / pwm_clk_ns;
 
-	if (!state->enabled)
+	if (!state->enabled) 
+	{
 		/* if is unenable,just set duty_dat to 0 , means low level always */
 		duty_data = 0;
+	}
 	else
+	{
 		/* calculate duty count*/
 		duty_data = state->duty_cycle / pwm_clk_ns;
+	}
 
 #if PTC_DEBUG
 	printk("period_data:%d,duty_data:%d\r\n",period_data,duty_data);
 #endif
 
 	if(state->polarity == PWM_POLARITY_NORMAL)
-		/* calculate data_hrc */
-		data_hrc = period_data - duty_data;
+	{
+		/* calculate data_hrc */	
+		data_hrc = period_data - duty_data;		
+	}
 	else
+	{
 		/* calculate data_hrc */
-		data_hrc = duty_data;
-
+		data_hrc = duty_data;	
+	}
 	data_lrc = period_data;
 
 	/* set hrc */
-	reg_addr = REG_PTC_RPTC_HRC(pwm->regs, dev->hwpwm);
+	reg_addr = REG_PTC_RPTC_HRC(pwm->regs,dev->hwpwm);
 #if PTC_DEBUG
-	printk("[sifive_pwm_ptc_config]reg_addr:0x%lx,data:0x%d....\n",reg_addr,data_hrc);
+	printk("[sifive_pwm_ptc_config]reg_addr:0x%lx,data:%d....\n",reg_addr,data_hrc);
 #endif
 	iowrite32(data_hrc, reg_addr);
 
 #if PTC_DEBUG
 	printk("[sifive_pwm_ptc_config]hrc ok....\n");
-#endif
+#endif	
 
 	/* set lrc */
-	reg_addr = REG_PTC_RPTC_LRC(pwm->regs, dev->hwpwm);
+	reg_addr = REG_PTC_RPTC_LRC(pwm->regs,dev->hwpwm);
 #if PTC_DEBUG
-	printk("[sifive_pwm_ptc_config]reg_addr:0x%lx,data:0x%d....\n",reg_addr,data_lrc);
-#endif
-
-	iowrite32(data_lrc, reg_addr);
+	printk("[sifive_pwm_ptc_config]reg_addr:0x%lx,data:%d....\n",reg_addr,data_lrc);
+#endif	
+	
+	iowrite32(data_lrc, reg_addr);	
 
 #if PTC_DEBUG
 	printk("[sifive_pwm_ptc_config]lrc ok....\n");
-#endif
+#endif	
+        /* set REG_RPTC_CNTR*/
+        reg_addr = REG_PTC_RPTC_CNTR(pwm->regs, dev->hwpwm);
+        iowrite32(0, reg_addr);
 
 	return 0;
 }
@@ -168,7 +189,7 @@ static int sifive_pwm_ptc_apply(struct pwm_chip *chip, struct pwm_device *dev, s
 
 static const struct pwm_ops sifive_pwm_ptc_ops = {
 	.get_state	= sifive_pwm_ptc_get_state,
-	.apply		= (void *)sifive_pwm_ptc_apply,
+	.apply		= (void*)sifive_pwm_ptc_apply,
 	.owner		= THIS_MODULE,
 };
 
@@ -183,7 +204,7 @@ static int sifive_pwm_ptc_probe(struct platform_device *pdev)
 	struct pwm_chip *chip;
 	struct resource *res;
 	int ret;
-
+	
 #if PTC_DEBUG
 	printk("sifive_pwm_ptc_probe in....\r\n");
 #endif
@@ -202,11 +223,12 @@ static int sifive_pwm_ptc_probe(struct platform_device *pdev)
 	chip->base = -1;
 
 	/* get pwm channels count, max value is 8 */
-	ret = of_property_read_u32(node, "sifive,npwm", &chip->npwm);
-	if (ret < 0 || chip->npwm > MAX_PWM)
+	ret = of_property_read_u32(node, "starfive,npwm", &chip->npwm);
+	if (ret < 0 || chip->npwm > MAX_PWM) 
+	{
 		chip->npwm = MAX_PWM;
-
-#if PTC_DEBUG
+	}
+#if PTC_DEBUG	
 	printk("[sifive_pwm_ptc_probe] npwm:0x%lx....\r\n",chip->npwm);
 #endif
 	/* get apb clock frequency */
@@ -220,9 +242,9 @@ static int sifive_pwm_ptc_probe(struct platform_device *pdev)
 
 #if PTC_DEBUG
 	printk("[sifive_pwm_ptc_probe] res start:0x%lx,end:0x%lx....\r\n",res->start,res->end);
-#endif
+#endif	
 	pwm->regs = devm_ioremap_resource(dev, res);
-	if (IS_ERR(pwm->regs))
+	if (IS_ERR(pwm->regs)) 
 	{
 		dev_err(dev, "Unable to map IO resources\n");
 		return PTR_ERR(pwm->regs);
@@ -232,7 +254,13 @@ static int sifive_pwm_ptc_probe(struct platform_device *pdev)
 	printk("[sifive_pwm_ptc_probe] regs:0x%lx....\r\n",pwm->regs);
 #endif
 
-	/* after add,it will display as /sys/class/pwm/pwmchip0,0 is chip->base
+	pwm->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(pwm->clk)) {
+		dev_err(dev, "Unable to find controller clock\n");
+		return PTR_ERR(pwm->clk);
+	}
+
+	/* after add,it will display as /sys/class/pwm/pwmchip0,0 is chip->base 
 	 * after execute echo 0 > export in  , pwm0 can be seen */
 	ret = pwmchip_add(chip);
 	if (ret < 0) {
@@ -241,7 +269,7 @@ static int sifive_pwm_ptc_probe(struct platform_device *pdev)
 	}
 
 	platform_set_drvdata(pdev, pwm);
-
+	
 #if PTC_DEBUG
 	printk("SiFive PWM PTC chip registered %d PWMs\n", chip->npwm);
 #endif
@@ -258,8 +286,8 @@ static int sifive_pwm_ptc_remove(struct platform_device *dev)
 }
 
 static const struct of_device_id sifive_pwm_ptc_of_match[] = {
-	{ .compatible = "sifive,pwm0" },
-	{ },
+	{ .compatible = "starfive,pwm0" },
+	{},
 };
 MODULE_DEVICE_TABLE(of, sifive_pwm_ptc_of_match);
 
@@ -275,3 +303,4 @@ module_platform_driver(sifive_pwm_ptc_driver);
 
 MODULE_DESCRIPTION("SiFive PWM PTC driver");
 MODULE_LICENSE("GPL v2");
+
-- 
2.30.0

