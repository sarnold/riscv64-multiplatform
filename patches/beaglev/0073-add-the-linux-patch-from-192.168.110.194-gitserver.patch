From 86646c22ae970bbd16d8ad5ed275edfeef499744 Mon Sep 17 00:00:00 2001
From: "Huan.Feng" <huan.feng@starfivetech.com>
Date: Tue, 9 Mar 2021 09:09:49 +0800
Subject: [PATCH 73/79] add the linux patch from 192.168.110.194 gitserver

---
 arch/riscv/configs/defconfig                | 2941 ++++++++++++++++++-
 drivers/crypto/Kconfig                      |    4 +-
 drivers/crypto/Makefile                     |    1 +
 drivers/crypto/sifive-vic/Kconfig           |   10 +
 drivers/crypto/sifive-vic/Makefile          |    3 +
 drivers/crypto/sifive-vic/vic-aes.c         | 1636 +++++++++++
 drivers/crypto/sifive-vic/vic-pka-hw.h      | 1671 +++++++++++
 drivers/crypto/sifive-vic/vic-pka-tools.c   |  366 +++
 drivers/crypto/sifive-vic/vic-pka.c         | 1316 +++++++++
 drivers/crypto/sifive-vic/vic-pka.h         |  173 ++
 drivers/crypto/sifive-vic/vic-sec.c         |  308 ++
 drivers/crypto/sifive-vic/vic-sec.h         |  446 +++
 drivers/crypto/sifive-vic/vic-sha.c         | 1101 +++++++
 drivers/i2c/busses/i2c-designware-core.h    |    2 +
 drivers/i2c/busses/i2c-designware-master.c  |   55 +
 drivers/i2c/busses/i2c-designware-platdrv.c |   13 +-
 usr/gen_initramfs_list.sh                   |  328 +++
 17 files changed, 10333 insertions(+), 41 deletions(-)
 create mode 100644 drivers/crypto/sifive-vic/Kconfig
 create mode 100644 drivers/crypto/sifive-vic/Makefile
 create mode 100644 drivers/crypto/sifive-vic/vic-aes.c
 create mode 100644 drivers/crypto/sifive-vic/vic-pka-hw.h
 create mode 100644 drivers/crypto/sifive-vic/vic-pka-tools.c
 create mode 100644 drivers/crypto/sifive-vic/vic-pka.c
 create mode 100644 drivers/crypto/sifive-vic/vic-pka.h
 create mode 100644 drivers/crypto/sifive-vic/vic-sec.c
 create mode 100644 drivers/crypto/sifive-vic/vic-sec.h
 create mode 100644 drivers/crypto/sifive-vic/vic-sha.c
 create mode 100755 usr/gen_initramfs_list.sh

diff --git a/arch/riscv/configs/defconfig b/arch/riscv/configs/defconfig
index d222d353d86d..2c445d64b150 100644
--- a/arch/riscv/configs/defconfig
+++ b/arch/riscv/configs/defconfig
@@ -1,133 +1,3002 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/riscv 5.9.14 Kernel Configuration
+#
+CONFIG_CC_VERSION_TEXT="riscv64-buildroot-linux-gnu-gcc.br_real (Buildroot -g1278ddf) 10.2.0"
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=100200
+CONFIG_LD_VERSION=234000000
+CONFIG_CLANG_VERSION=0
+CONFIG_CC_CAN_LINK=y
+CONFIG_CC_CAN_LINK_STATIC=y
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_CC_HAS_ASM_INLINE=y
+CONFIG_IRQ_WORK=y
+CONFIG_THREAD_INFO_IN_TASK=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="-sifive-1"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_BUILD_SALT=""
+CONFIG_DEFAULT_INIT=""
+CONFIG_DEFAULT_HOSTNAME="riscv"
+CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
 CONFIG_POSIX_MQUEUE=y
-CONFIG_NO_HZ_IDLE=y
-CONFIG_HIGH_RES_TIMERS=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_WATCH_QUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_USELIB is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+# end of IRQ subsystem
+
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_ARCH_CLOCKSOURCE_INIT=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_HZ_PERIODIC=y
+# CONFIG_NO_HZ_IDLE is not set
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+# end of Timers subsystem
+
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_PREEMPT_COUNT=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_PSI is not set
+# end of CPU/Task time and stats accounting
+
+CONFIG_CPU_ISOLATION=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# end of RCU Subsystem
+
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+# CONFIG_IKHEADERS is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+
+#
+# Scheduler features
+#
+# end of Scheduler features
+
+CONFIG_CC_HAS_INT128=y
+CONFIG_ARCH_SUPPORTS_INT128=y
 CONFIG_CGROUPS=y
+# CONFIG_MEMCG is not set
+# CONFIG_BLK_CGROUP is not set
 CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
 CONFIG_CFS_BANDWIDTH=y
+# CONFIG_RT_GROUP_SCHED is not set
+# CONFIG_CGROUP_PIDS is not set
+# CONFIG_CGROUP_RDMA is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_HUGETLB is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CGROUP_CPUACCT is not set
 CONFIG_CGROUP_BPF=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_SOCK_CGROUP_DATA=y
 CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
 CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
 CONFIG_CHECKPOINT_RESTORE=y
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
 CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="/work/freedom-u-sdk_up/work/buildroot_initramfs_sysroot"
+# CONFIG_INITRAMFS_FORCE is not set
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_RD_ZSTD=y
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+# CONFIG_INITRAMFS_COMPRESSION_BZIP2 is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZMA is not set
+# CONFIG_INITRAMFS_COMPRESSION_XZ is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZO is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZ4 is not set
+# CONFIG_INITRAMFS_COMPRESSION_ZSTD is not set
+# CONFIG_INITRAMFS_COMPRESSION_NONE is not set
+# CONFIG_BOOT_CONFIG is not set
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_BPF=y
 CONFIG_EXPERT=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_HAVE_FUTEX_CMPXCHG=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_IO_URING=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
 CONFIG_BPF_SYSCALL=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# end of Kernel Performance Events And Counters
+
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+# CONFIG_SHUFFLE_PAGE_ALLOCATOR is not set
+CONFIG_SLUB_CPU_PARTIAL=y
+# CONFIG_PROFILING is not set
+# end of General setup
+
+CONFIG_64BIT=y
+CONFIG_RISCV=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=18
+CONFIG_ARCH_MMAP_RND_BITS_MAX=24
+CONFIG_RISCV_SBI=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA32=y
+CONFIG_VA_BITS=39
+CONFIG_PA_BITS=56
+CONFIG_PAGE_OFFSET=0xffffffe000000000
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=3
+CONFIG_LOCKDEP_SUPPORT=y
+
+#
+# SoC selection
+#
 CONFIG_SOC_SIFIVE=y
-CONFIG_SOC_VIRT=y
+CONFIG_SOC_STARFIVE_VIC7100=y
+
+#
+# StarFive VIC7100 SoC Debug Option
+#
+# CONFIG_FPGA_GMAC_SPEED10 is not set
+# CONFIG_FPGA_GMAC_SPEED100 is not set
+CONFIG_FPGA_GMAC_SPEED_AUTO=y
+CONFIG_FPGA_GMAC_FLUSH_DDR=y
+# end of StarFive VIC7100 SoC Debug Option
+
+# CONFIG_SOC_VIRT is not set
+# end of SoC selection
+
+#
+# Platform type
+#
+# CONFIG_ARCH_RV32I is not set
+CONFIG_ARCH_RV64I=y
+# CONFIG_CMODEL_MEDLOW is not set
+CONFIG_CMODEL_MEDANY=y
+CONFIG_MODULE_SECTIONS=y
+# CONFIG_MAXPHYSMEM_2GB is not set
+CONFIG_MAXPHYSMEM_128GB=y
 CONFIG_SMP=y
-CONFIG_JUMP_LABEL=y
+CONFIG_NR_CPUS=8
+# CONFIG_HOTPLUG_CPU is not set
+CONFIG_TUNE_GENERIC=y
+CONFIG_RISCV_ISA_C=y
+CONFIG_FPU=y
+# end of Platform type
+
+#
+# Kernel features
+#
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+# CONFIG_SECCOMP is not set
+CONFIG_RISCV_SBI_V01=y
+# end of Kernel features
+
+#
+# Boot options
+#
+CONFIG_CMDLINE="earlyprintk console=ttyS0,115200 debug rootwait stmmaceth=chain_mode:1"
+# CONFIG_CMDLINE_FALLBACK is not set
+# CONFIG_CMDLINE_EXTEND is not set
+CONFIG_CMDLINE_FORCE=y
+# end of Boot options
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+# end of Power management options
+
+#
+# General architecture-dependent options
+#
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_ARCH_HAS_SET_DIRECT_MAP=y
+CONFIG_HAVE_ASM_MODVERSIONS=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT=y
+CONFIG_CLONE_BACKWARDS=y
+# CONFIG_COMPAT_32BIT_TIME is not set
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+# CONFIG_LOCK_EVENT_COUNTS is not set
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# end of GCOV-based kernel profiling
+
+CONFIG_HAVE_GCC_PLUGINS=y
+CONFIG_GCC_PLUGINS=y
+# CONFIG_GCC_PLUGIN_CYC_COMPLEXITY is not set
+# CONFIG_GCC_PLUGIN_LATENT_ENTROPY is not set
+# CONFIG_GCC_PLUGIN_RANDSTRUCT is not set
+# end of General architecture-dependent options
+
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
 CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
 CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_BLOCK=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+CONFIG_BLK_DEV_ZONED=y
+# CONFIG_BLK_CMDLINE_PARSER is not set
+# CONFIG_BLK_WBT is not set
+CONFIG_BLK_DEBUG_FS=y
+CONFIG_BLK_DEBUG_FS_ZONED=y
+# CONFIG_BLK_SED_OPAL is not set
+# CONFIG_BLK_INLINE_ENCRYPTION is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+# end of Partition Types
+
+CONFIG_BLK_MQ_PCI=y
+CONFIG_BLK_MQ_VIRTIO=y
+
+#
+# IO Schedulers
+#
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+# end of IO Schedulers
+
+CONFIG_ASN1=m
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_HAS_MMIOWB=y
+CONFIG_MMIOWB=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_ARCH_HAS_BINFMT_FLAT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+# end of Executable file formats
+
+#
+# Memory Management options
+#
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_MEMORY_ISOLATION=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+# CONFIG_PAGE_REPORTING is not set
+CONFIG_MIGRATION=y
+CONFIG_CONTIG_ALLOC=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+CONFIG_CMA_DEBUGFS=y
+CONFIG_CMA_AREAS=7
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
+CONFIG_ARCH_HAS_PTE_SPECIAL=y
+# end of Memory Management options
+
 CONFIG_NET=y
+
+#
+# Networking options
+#
 CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
 CONFIG_UNIX=y
+CONFIG_UNIX_SCM=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+# CONFIG_XDP_SOCKETS is not set
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+# CONFIG_IP_MULTIPLE_TABLES is not set
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
 CONFIG_IP_PNP_BOOTP=y
 CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+# CONFIG_IP_MROUTE is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_RAW_DIAG is not set
+# CONFIG_INET_DIAG_DESTROY is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_IPV6_VTI is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_IPV6_RPL_LWTUNNEL is not set
+# CONFIG_MPTCP is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_BPFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
 CONFIG_NETLINK_DIAG=y
-CONFIG_NET_9P=y
-CONFIG_NET_9P_VIRTIO=y
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_QRTR is not set
+# CONFIG_NET_NCSI is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+# CONFIG_BPF_STREAM_PARSER is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# end of Network testing
+# end of Networking options
+
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_GRO_CELLS=y
+CONFIG_PAGE_POOL=y
+CONFIG_FAILOVER=y
+CONFIG_ETHTOOL_NETLINK=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_HAVE_PCI=y
 CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_DOMAINS_GENERIC=y
 CONFIG_PCIEPORTBUS=y
-CONFIG_PCI_HOST_GENERIC=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+# CONFIG_PCIEAER is not set
+CONFIG_PCIEASPM=y
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_POWER_SUPERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PTM=y
+# CONFIG_PCIE_BW is not set
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_PCI_DEBUG=y
+CONFIG_PCI_REALLOC_ENABLE_AUTO=y
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_PF_STUB is not set
+CONFIG_PCI_ATS=y
+CONFIG_PCI_IOV=y
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_HOTPLUG_PCI=y
+CONFIG_HOTPLUG_PCI_CPCI=y
+CONFIG_HOTPLUG_PCI_SHPC=y
+
+#
+# PCI controller drivers
+#
+# CONFIG_PCI_FTPCI100 is not set
+# CONFIG_PCI_HOST_GENERIC is not set
 CONFIG_PCIE_XILINX=y
+
+#
+# DesignWare PCI Core Support
+#
+# CONFIG_PCIE_DW_PLAT_HOST is not set
+# CONFIG_PCI_MESON is not set
+# end of DesignWare PCI Core Support
+
+#
+# Mobiveil PCIe Core Support
+#
+# end of Mobiveil PCIe Core Support
+
+#
+# Cadence PCIe controllers support
+#
+# CONFIG_PCIE_CADENCE_PLAT_HOST is not set
+# CONFIG_PCI_J721E_HOST is not set
+# end of Cadence PCIe controllers support
+# end of PCI controller drivers
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# end of PCI Endpoint
+
+#
+# PCI switch controller drivers
+#
+# CONFIG_PCI_SW_SWITCHTEC is not set
+# end of PCI switch controller drivers
+
+# CONFIG_PCCARD is not set
+# CONFIG_RAPIDIO is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_UEVENT_HELPER is not set
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+# CONFIG_FW_LOADER_COMPRESS is not set
+# end of Firmware loader
+
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_DMA_FENCE_TRACE is not set
+CONFIG_GENERIC_ARCH_TOPOLOGY=y
+# end of Generic Driver Options
+
+#
+# Bus devices
+#
+# CONFIG_MOXTET is not set
+# CONFIG_MHI_BUS is not set
+# end of Bus devices
+
+# CONFIG_CONNECTOR is not set
+# CONFIG_GNSS is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+
+#
+# Partition parsers
+#
+# CONFIG_MTD_AR7_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# end of Partition parsers
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
+# CONFIG_MTD_BLOCK is not set
+CONFIG_MTD_BLOCK_RO=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# end of RAM/ROM/Flash chip drivers
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+# end of Mapping drivers for chip access
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_MCHP23K256 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# end of Self-contained MTD device drivers
+
+#
+# NAND
+#
+# CONFIG_MTD_ONENAND is not set
+# CONFIG_MTD_RAW_NAND is not set
+# CONFIG_MTD_SPI_NAND is not set
+# end of NAND
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# end of LPDDR & LPDDR2 PCM memory drivers
+
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
+# CONFIG_MTD_UBI is not set
+# CONFIG_MTD_HYPERBUS is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+CONFIG_CDROM=y
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_DEV_UMEM is not set
 CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
 CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+
+#
+# NVME Support
+#
+CONFIG_NVME_CORE=y
+CONFIG_BLK_DEV_NVME=y
+# CONFIG_NVME_MULTIPATH is not set
+CONFIG_NVME_FABRICS=y
+CONFIG_NVME_FC=y
+# CONFIG_NVME_TCP is not set
+# end of NVME Support
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+# CONFIG_PCI_ENDPOINT_TEST is not set
+# CONFIG_XILINX_SDFEC is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=y
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+# CONFIG_EEPROM_EE1004 is not set
+# end of EEPROM support
+
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# end of Texas Instruments shared transport line discipline
+
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel MIC & related support
+#
+# CONFIG_VOP_BUS is not set
+# end of Intel MIC & related support
+
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_MISC_ALCOR_PCI is not set
+# CONFIG_MISC_RTSX_PCI is not set
+# CONFIG_HABANA_AI is not set
+# end of Misc devices
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
 CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
 CONFIG_BLK_DEV_SR=y
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# end of SCSI Transports
+
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_ESAS2R is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_SMARTPQI is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_MYRB is not set
+# CONFIG_SCSI_MYRS is not set
+# CONFIG_SCSI_SNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FDOMAIN_PCI is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_WD719X is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
 CONFIG_SCSI_VIRTIO=y
+# CONFIG_SCSI_DH is not set
+# end of SCSI device support
+
 CONFIG_ATA=y
+CONFIG_SATA_HOST=y
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_FORCE=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
 CONFIG_SATA_AHCI=y
+CONFIG_SATA_MOBILE_LPM_POLICY=0
 CONFIG_SATA_AHCI_PLATFORM=y
+# CONFIG_AHCI_CEVA is not set
+# CONFIG_AHCI_QORIQ is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+CONFIG_SATA_SIL24=y
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+# CONFIG_ATA_PIIX is not set
+# CONFIG_SATA_DWC is not set
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SCH is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_RZ1000 is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_LEGACY is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# end of IEEE 1394 (FireWire) support
+
 CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_WIREGUARD is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_BAREUDP is not set
+# CONFIG_GTP is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
 CONFIG_VIRTIO_NET=y
-CONFIG_MACB=y
-CONFIG_E1000E=y
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+
+#
+# Distributed Switch Architecture drivers
+#
+# end of Distributed Switch Architecture drivers
+
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+CONFIG_NET_VENDOR_ADAPTEC=y
+# CONFIG_ADAPTEC_STARFIRE is not set
+CONFIG_NET_VENDOR_AGERE=y
+# CONFIG_ET131X is not set
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+CONFIG_NET_VENDOR_ALTEON=y
+# CONFIG_ACENIC is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+CONFIG_NET_VENDOR_AMD=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_PCNET32 is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+CONFIG_NET_VENDOR_ATHEROS=y
+# CONFIG_ATL2 is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_ALX is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_NET_VENDOR_BROCADE=y
+# CONFIG_BNA is not set
+# CONFIG_NET_VENDOR_CADENCE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+CONFIG_NET_VENDOR_CISCO=y
+# CONFIG_ENIC is not set
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_DEC=y
+# CONFIG_NET_TULIP is not set
+CONFIG_NET_VENDOR_DLINK=y
+# CONFIG_DL2K is not set
+# CONFIG_SUNDANCE is not set
+CONFIG_NET_VENDOR_EMULEX=y
+# CONFIG_BE2NET is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MICROSEMI is not set
+CONFIG_NET_VENDOR_MYRI=y
+# CONFIG_MYRI10GE is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+CONFIG_NET_VENDOR_NETERION=y
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NI is not set
+CONFIG_NET_VENDOR_NVIDIA=y
+# CONFIG_FORCEDETH is not set
+CONFIG_NET_VENDOR_OKI=y
+# CONFIG_ETHOC is not set
+CONFIG_NET_VENDOR_PACKET_ENGINES=y
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_NET_VENDOR_PENSANDO is not set
+CONFIG_NET_VENDOR_QLOGIC=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_QED is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+CONFIG_NET_VENDOR_RDC=y
+# CONFIG_R6040 is not set
+CONFIG_NET_VENDOR_REALTEK=y
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
 CONFIG_R8169=y
-CONFIG_MICROSEMI_PHY=y
-CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+CONFIG_NET_VENDOR_SILAN=y
+# CONFIG_SC92031 is not set
+CONFIG_NET_VENDOR_SIS=y
+# CONFIG_SIS900 is not set
+# CONFIG_SIS190 is not set
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_EPIC100 is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_SMSC9420 is not set
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+CONFIG_NET_VENDOR_STMICRO=y
+CONFIG_STMMAC_ETH=y
+# CONFIG_STMMAC_SELFTESTS is not set
+CONFIG_STMMAC_PLATFORM=y
+# CONFIG_DWMAC_DWC_QOS_ETH is not set
+CONFIG_DWMAC_GENERIC=y
+# CONFIG_STMMAC_PCI is not set
+CONFIG_NET_VENDOR_SUN=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NIU is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+CONFIG_NET_VENDOR_TEHUTI=y
+# CONFIG_TEHUTI is not set
+CONFIG_NET_VENDOR_TI=y
+# CONFIG_TI_CPSW_PHY_SEL is not set
+# CONFIG_TLAN is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_NET_VENDOR_XILINX is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+CONFIG_MDIO_DEVRES=y
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MDIO_BUS_MUX_MULTIPLEXER is not set
+# CONFIG_MDIO_HISI_FEMAC is not set
+# CONFIG_MDIO_IPQ4019 is not set
+# CONFIG_MDIO_IPQ8064 is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+# CONFIG_MDIO_OCTEON is not set
+# CONFIG_MDIO_THUNDER is not set
+CONFIG_MDIO_XPCS=y
+CONFIG_PHYLINK=y
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_SFP is not set
+# CONFIG_ADIN_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AX88796B_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM54140_PHY is not set
+# CONFIG_BCM84881_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+# CONFIG_DP83869_PHY is not set
+CONFIG_FIXED_PHY=y
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_LXT_PHY is not set
+CONFIG_MARVELL_PHY=y
+# CONFIG_MARVELL_10G_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+CONFIG_REALTEK_PHY=y
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_ROCKCHIP_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_NETDEVSIM is not set
+CONFIG_NET_FAILOVER=y
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_GPIO_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+# end of Hardware I/O ports
+# end of Input device support
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_LDISC_AUTOLOAD=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
 CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+CONFIG_SERIAL_8250_16550A_VARIANTS=y
+# CONFIG_SERIAL_8250_FINTEK is not set
 CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_EXAR=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_ASPEED_VUART is not set
+CONFIG_SERIAL_8250_DWLIB=y
+CONFIG_SERIAL_8250_DW=y
+# CONFIG_SERIAL_8250_RT288X is not set
 CONFIG_SERIAL_OF_PLATFORM=y
-CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
-CONFIG_HVC_RISCV_SBI=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_RISCV_SBI is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_SERIAL_SIFIVE=y
+CONFIG_SERIAL_SIFIVE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_FSL_LINFLEXUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_SPRD is not set
+# end of Serial drivers
+
+CONFIG_SERIAL_MCTRL_GPIO=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_NULL_TTY is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_HVC_DRIVER=y
+# CONFIG_HVC_RISCV_SBI is not set
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
 CONFIG_VIRTIO_CONSOLE=y
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMB_DEVICE_INTERFACE is not set
 CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_BA431 is not set
 CONFIG_HW_RANDOM_VIRTIO=y
+CONFIG_HW_RANDOM_STARFIVE_VIC=y
+# CONFIG_HW_RANDOM_CCTRNG is not set
+# CONFIG_APPLICOM is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_DEVPORT=y
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+# end of Character devices
+
+# CONFIG_RANDOM_TRUST_BOOTLOADER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_NVIDIA_GPU is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+CONFIG_I2C_DESIGNWARE_CORE=y
+CONFIG_I2C_DESIGNWARE_SLAVE=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# end of I2C Hardware Bus support
+
+# CONFIG_I2C_STUB is not set
+CONFIG_I2C_SLAVE=y
+# CONFIG_I2C_SLAVE_EEPROM is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# end of I2C support
+
+# CONFIG_I3C is not set
 CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MEM=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_CADENCE is not set
+CONFIG_SPI_DESIGNWARE=y
+# CONFIG_SPI_DW_DMA is not set
+# CONFIG_SPI_DW_PCI is not set
+CONFIG_SPI_DW_MMIO=y
+# CONFIG_SPI_NXP_FLEXSPI is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
 CONFIG_SPI_SIFIVE=y
+# CONFIG_SPI_MXIC is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+# CONFIG_SPI_AMD is not set
+
+#
+# SPI Multiplexer support
+#
+# CONFIG_SPI_MUX is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+CONFIG_SPI_LOOPBACK_TEST=m
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_SLAVE is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+# CONFIG_PPS is not set
+
+#
+# PTP clock support
+#
 # CONFIG_PTP_1588_CLOCK is not set
-CONFIG_POWER_RESET=y
-CONFIG_DRM=y
-CONFIG_DRM_RADEON=y
-CONFIG_DRM_VIRTIO_GPU=y
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# end of PTP clock support
+
+# CONFIG_PINCTRL is not set
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_CADENCE is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_EXAR is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_LOGICVC is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_SAMA5D2_PIOBU is not set
+# CONFIG_GPIO_SIFIVE is not set
+CONFIG_GPIO_STARFIVE_VIC=y
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_AMD_FCH is not set
+# end of Memory mapped GPIO drivers
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_GW_PLD is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCA9570 is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_TPIC2810 is not set
+# end of I2C GPIO expanders
+
+#
+# MFD GPIO expanders
+#
+# end of MFD GPIO expanders
+
+#
+# PCI GPIO expanders
+#
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_PCI_IDIO_16 is not set
+# CONFIG_GPIO_PCIE_IDIO_24 is not set
+# CONFIG_GPIO_RDC321X is not set
+# end of PCI GPIO expanders
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+# end of SPI GPIO expanders
+
+# CONFIG_GPIO_AGGREGATOR is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_GATEWORKS_GSC is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_MP2629 is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_IQS62X is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77650 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6360 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TQMX86 is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_LOCHNAGAR is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_MFD_ROHM_BD70528 is not set
+# CONFIG_MFD_ROHM_BD71828 is not set
+# CONFIG_MFD_STPMIC1 is not set
+# CONFIG_MFD_STMFX is not set
+# end of Multifunction device drivers
+
+# CONFIG_REGULATOR is not set
+# CONFIG_RC_CORE is not set
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+# CONFIG_DRM is not set
+
+#
+# ARM devices
+#
+# end of ARM devices
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_FB_SM712 is not set
+# end of Frame buffer Devices
+
+#
+# Backlight & LCD device support
+#
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_PWM is not set
+# CONFIG_BACKLIGHT_QCOM_WLED is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630A is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+# CONFIG_BACKLIGHT_GPIO is not set
+# CONFIG_BACKLIGHT_LV5207LP is not set
+# CONFIG_BACKLIGHT_BD6107 is not set
+# CONFIG_BACKLIGHT_ARCXCNN is not set
+# end of Backlight & LCD device support
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
 CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_USB=y
-CONFIG_USB_XHCI_HCD=y
-CONFIG_USB_XHCI_PLATFORM=y
-CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_EHCI_HCD_PLATFORM=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_OHCI_HCD_PLATFORM=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_UAS=y
-CONFIG_MMC=y
-CONFIG_MMC_SPI=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER is not set
+# end of Console display driver support
+
+# CONFIG_LOGO is not set
+# end of Graphics support
+
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_COUGAR is not set
+# CONFIG_HID_MACALLY is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_GLORIOUS is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_VIEWSONIC is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_JABRA is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MALTRON is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_REDRAGON is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEAM is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+# end of Special HID drivers
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+# end of I2C HID support
+# end of HID support
+
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
 CONFIG_RTC_CLASS=y
-CONFIG_VIRTIO_PCI=y
-CONFIG_VIRTIO_BALLOON=y
-CONFIG_VIRTIO_INPUT=y
-CONFIG_VIRTIO_MMIO=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+CONFIG_RTC_NVMEM=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABEOZ9 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF85363 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3028 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+# CONFIG_RTC_DRV_SD3078 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+CONFIG_RTC_I2C_AND_SPI=y
+
+#
+# SPI and I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_CADENCE is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_VIRTUAL_CHANNELS=y
+CONFIG_DMA_OF=y
+# CONFIG_ALTERA_MSGDMA is not set
+CONFIG_DW_AXI_DMAC=y
+CONFIG_DW_AXI_DMAC_STARFIVE=y
+# CONFIG_FSL_EDMA is not set
+# CONFIG_INTEL_IDMA64 is not set
+# CONFIG_PLX_DMA is not set
+# CONFIG_XILINX_ZYNQMP_DPDMA is not set
+# CONFIG_QCOM_HIDMA_MGMT is not set
+# CONFIG_QCOM_HIDMA is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+# CONFIG_DW_EDMA is not set
+# CONFIG_DW_EDMA_PCIE is not set
+# CONFIG_SF_PDMA is not set
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+
+#
+# DMABUF options
+#
+CONFIG_SYNC_FILE=y
+# CONFIG_SW_SYNC is not set
+# CONFIG_UDMABUF is not set
+# CONFIG_DMABUF_MOVE_NOTIFY is not set
+# CONFIG_DMABUF_SELFTESTS is not set
+# CONFIG_DMABUF_HEAPS is not set
+# end of DMABUF options
+
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VDPA is not set
+# CONFIG_VHOST_MENU is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# end of Microsoft Hyper-V guest support
+
+# CONFIG_GREYBUS is not set
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+CONFIG_HAVE_CLK=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_SI5341 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_COMMON_CLK_PWM is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+# CONFIG_COMMON_CLK_FIXED_MMIO is not set
+CONFIG_CLK_ANALOGBITS_WRPLL_CLN28HPC=y
+CONFIG_CLK_SIFIVE=y
+CONFIG_CLK_SIFIVE_FU540_PRCI=y
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_RISCV_TIMER=y
+# CONFIG_MICROCHIP_PIT64B is not set
+# end of Clock Source drivers
+
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+# end of Remoteproc drivers
+
+#
+# Rpmsg drivers
+#
+CONFIG_RPMSG=y
 CONFIG_RPMSG_CHAR=y
 CONFIG_RPMSG_VIRTIO=y
+# end of Rpmsg drivers
+
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+# end of Amlogic SoC drivers
+
+#
+# Aspeed SoC drivers
+#
+# end of Aspeed SoC drivers
+
+#
+# Broadcom SoC drivers
+#
+# end of Broadcom SoC drivers
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+# end of NXP/Freescale QorIQ SoC drivers
+
+#
+# i.MX SoC drivers
+#
+# end of i.MX SoC drivers
+
+#
+# Qualcomm SoC drivers
+#
+# end of Qualcomm SoC drivers
+
+CONFIG_SIFIVE_L2=y
+CONFIG_SIFIVE_L2_FLUSH=y
+CONFIG_SIFIVE_L2_FLUSH_START=0x80000000
+CONFIG_SIFIVE_L2_FLUSH_SIZE=0x800000000
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# end of Xilinx SoC drivers
+# end of SOC (System On Chip) specific Drivers
+
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+CONFIG_PWM=y
+CONFIG_PWM_SYSFS=y
+# CONFIG_PWM_DEBUG is not set
+# CONFIG_PWM_FSL_FTM is not set
+# CONFIG_PWM_PCA9685 is not set
+CONFIG_PWM_SIFIVE=y
+CONFIG_PWM_SIFIVE_PTC=y
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+# CONFIG_AL_FIC is not set
+CONFIG_RISCV_INTC=y
+CONFIG_SIFIVE_PLIC=y
+# end of IRQ chip support
+
+# CONFIG_IPACK_BUS is not set
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_BRCMSTB_RESCAL is not set
+# CONFIG_RESET_INTEL_GW is not set
+# CONFIG_RESET_TI_SYSCON is not set
+
+#
+# PHY Subsystem
+#
+CONFIG_GENERIC_PHY=y
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_CADENCE_TORRENT is not set
+# CONFIG_PHY_CADENCE_DPHY is not set
+# CONFIG_PHY_CADENCE_SIERRA is not set
+# CONFIG_PHY_CADENCE_SALVO is not set
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+# CONFIG_PHY_MIXEL_MIPI_DPHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_OCELOT_SERDES is not set
+# end of PHY Subsystem
+
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+# CONFIG_RAS is not set
+# CONFIG_USB4 is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# end of Android
+
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+CONFIG_NVMEM_SYSFS=y
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# end of HW tracing support
+
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_INTERCONNECT is not set
+# CONFIG_COUNTER is not set
+# CONFIG_XRP is not set
+# end of Device Drivers
+
+#
+# File systems
+#
+# CONFIG_VALIDATE_FS_PARSER is not set
+CONFIG_FS_IOMAP=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
 CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT2=y
 CONFIG_EXT4_FS_POSIX_ACL=y
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_ZONEFS_FS is not set
+# CONFIG_FS_DAX is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FS_VERITY is not set
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
 CONFIG_AUTOFS4_FS=y
+CONFIG_AUTOFS_FS=y
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# end of Caches
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+# end of CD-ROM/DVD Filesystems
+
+#
+# DOS/FAT/EXFAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
 CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_FAT_DEFAULT_UTF8=y
+CONFIG_EXFAT_FS=y
+CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+# end of DOS/FAT/EXFAT/NT Filesystems
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
 CONFIG_TMPFS=y
 CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_TMPFS_INODE64 is not set
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_MEMFD_CREATE=y
+CONFIG_ARCH_HAS_GIGANTIC_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+# end of Pseudo filesystems
+
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_EROFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
 CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
 CONFIG_NFS_V4_1=y
 CONFIG_NFS_V4_2=y
+CONFIG_PNFS_FILE_LAYOUT=y
+CONFIG_PNFS_FLEXFILE_LAYOUT=m
+CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
+# CONFIG_NFS_V4_1_MIGRATION is not set
 CONFIG_ROOT_NFS=y
-CONFIG_9P_FS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFS_DISABLE_UDP_SUPPORT=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_SUNRPC_BACKCHANNEL=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_UNICODE is not set
+CONFIG_IO_WQ=y
+# end of File systems
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_REQUEST_CACHE is not set
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity,bpf"
+
+#
+# Kernel hardening options
+#
+
+#
+# Memory initialization
+#
+CONFIG_INIT_STACK_NONE=y
+# CONFIG_GCC_PLUGIN_STRUCTLEAK_USER is not set
+# CONFIG_GCC_PLUGIN_STRUCTLEAK_BYREF is not set
+# CONFIG_GCC_PLUGIN_STRUCTLEAK_BYREF_ALL is not set
+# CONFIG_INIT_ON_ALLOC_DEFAULT_ON is not set
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+# end of Memory initialization
+# end of Kernel hardening options
+# end of Security options
+
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_SKCIPHER=y
+CONFIG_CRYPTO_SKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=m
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+CONFIG_CRYPTO_ENGINE=y
+
+#
+# Public-key cryptography
+#
+CONFIG_CRYPTO_RSA=m
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_ECDH is not set
+# CONFIG_CRYPTO_ECRDSA is not set
+# CONFIG_CRYPTO_CURVE25519 is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_AEGIS128 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CFB is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_OFB is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_ADIANTUM is not set
+# CONFIG_CRYPTO_ESSIV is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_XXHASH is not set
+# CONFIG_CRYPTO_BLAKE2B is not set
+# CONFIG_CRYPTO_BLAKE2S is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_STREEBOG is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+# CONFIG_CRYPTO_ZSTD is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+CONFIG_CRYPTO_USER_API=y
 CONFIG_CRYPTO_USER_API_HASH=y
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_STATS is not set
+
+#
+# Crypto library routines
+#
+# CONFIG_CRYPTO_LIB_BLAKE2S is not set
+# CONFIG_CRYPTO_LIB_CHACHA is not set
+# CONFIG_CRYPTO_LIB_CURVE25519 is not set
+CONFIG_CRYPTO_LIB_POLY1305_RSIZE=1
+# CONFIG_CRYPTO_LIB_POLY1305 is not set
+# CONFIG_CRYPTO_LIB_CHACHA20POLY1305 is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_ATMEL_ECC is not set
+# CONFIG_CRYPTO_DEV_ATMEL_SHA204A is not set
+# CONFIG_CRYPTO_DEV_NITROX_CNN55XX is not set
 CONFIG_CRYPTO_DEV_VIRTIO=y
+# CONFIG_CRYPTO_DEV_SAFEXCEL is not set
+# CONFIG_CRYPTO_DEV_CCREE is not set
+# CONFIG_CRYPTO_DEV_AMLOGIC_GXL is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+# end of Certificates for signature checking
+
+#
+# Library routines
+#
+# CONFIG_PACKING is not set
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+# CONFIG_CORDIC is not set
+# CONFIG_PRIME_NUMBERS is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_PCI_IOMAP=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+CONFIG_XXHASH=y
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_ZSTD_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_DECOMPRESS_ZSTD=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_DMA_DECLARE_COHERENT=y
+CONFIG_SWIOTLB=y
+# CONFIG_DMA_CMA is not set
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_SGL_ALLOC=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_CLZ_TAB=y
+# CONFIG_IRQ_POLL is not set
+CONFIG_MPILIB=m
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_HAVE_GENERIC_VDSO=y
+CONFIG_GENERIC_GETTIMEOFDAY=y
+CONFIG_FONT_SUPPORT=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_SG_POOL=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+# end of Library routines
+
+CONFIG_GENERIC_IOREMAP=y
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
 CONFIG_PRINTK_TIME=y
+# CONFIG_PRINTK_CALLER is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DYNAMIC_DEBUG_CORE is not set
+CONFIG_SYMBOLIC_ERRNAME=y
+CONFIG_DEBUG_BUGVERBOSE=y
+# end of printk and dmesg options
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_HEADERS_INSTALL is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_FUNCTION_ALIGN_32B is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# end of Compile-time checks and compiler options
+
+#
+# Generic Kernel Debugging Instruments
+#
+# CONFIG_MAGIC_SYSRQ is not set
 CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_FS_ALLOW_ALL=y
+# CONFIG_DEBUG_FS_DISALLOW_MOUNT is not set
+# CONFIG_DEBUG_FS_ALLOW_NONE is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARCH_KGDB_QXFER_PKT=y
+# CONFIG_KGDB is not set
+# CONFIG_UBSAN is not set
+# end of Generic Kernel Debugging Instruments
+
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_MISC=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
 CONFIG_DEBUG_PAGEALLOC=y
+# CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+CONFIG_ARCH_HAS_DEBUG_WX=y
+# CONFIG_DEBUG_WX is not set
+CONFIG_GENERIC_PTDUMP=y
+# CONFIG_PTDUMP_DEBUGFS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
 CONFIG_SCHED_STACK_END_CHECK=y
+CONFIG_ARCH_HAS_DEBUG_VM_PGTABLE=y
 CONFIG_DEBUG_VM=y
+# CONFIG_DEBUG_VM_VMACACHE is not set
+# CONFIG_DEBUG_VM_RB is not set
 CONFIG_DEBUG_VM_PGFLAGS=y
+CONFIG_DEBUG_VM_PGTABLE=y
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
 CONFIG_DEBUG_MEMORY_INIT=y
-CONFIG_DEBUG_PER_CPU_MAPS=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_ARCH_KASAN=y
+CONFIG_CC_HAS_WORKING_NOSANITIZE_ADDRESS=y
+# end of Memory Debugging
+
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Oops, Lockups and Hangs
+#
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_LOCKUP_DETECTOR=y
 CONFIG_SOFTLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
 CONFIG_WQ_WATCHDOG=y
+# CONFIG_TEST_LOCKUP is not set
+# end of Debug Oops, Lockups and Hangs
+
+#
+# Scheduler Debugging
+#
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# end of Scheduler Debugging
+
 CONFIG_DEBUG_TIMEKEEPING=y
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
 CONFIG_DEBUG_RT_MUTEXES=y
 CONFIG_DEBUG_SPINLOCK=y
 CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
 CONFIG_DEBUG_RWSEMS=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
 CONFIG_DEBUG_ATOMIC_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# end of Lock Debugging (spinlocks, mutexes, etc...)
+
 CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+
+#
+# Debug kernel data structures
+#
 CONFIG_DEBUG_LIST=y
 CONFIG_DEBUG_PLIST=y
 CONFIG_DEBUG_SG=y
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# end of Debug kernel data structures
+
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_REF_SCALE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
 # CONFIG_RCU_TRACE is not set
 CONFIG_RCU_EQS_DEBUG=y
+# end of RCU Debugging
+
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
 CONFIG_DEBUG_BLOCK_EXT_DEVT=y
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_TRACING_SUPPORT=y
 # CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+
+#
+# riscv Debugging
+#
+
+#
+# Kernel Testing and Coverage
+#
+# CONFIG_KUNIT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
 # CONFIG_RUNTIME_TESTING_MENU is not set
 CONFIG_MEMTEST=y
-# CONFIG_SYSFS_SYSCALL is not set
-CONFIG_EFI=y
+# end of Kernel Testing and Coverage
+# end of Kernel hacking
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index 9d6645b1f0ab..74080ca3c47a 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -21,7 +21,7 @@ config CRYPTO_DEV_PADLOCK
 	  (so called VIA PadLock ACE, Advanced Cryptography Engine)
 	  that provides instructions for very fast cryptographic
 	  operations with supported algorithms.
-	  
+
 	  The instructions are used only when the CPU supports them.
 	  Otherwise software encryption is used.
 
@@ -733,6 +733,8 @@ config CRYPTO_DEV_VMX
 
 source "drivers/crypto/vmx/Kconfig"
 
+source "drivers/crypto/sifive-vic/Kconfig"
+
 config CRYPTO_DEV_IMGTEC_HASH
 	tristate "Imagination Technologies hardware hash accelerator"
 	depends on MIPS || COMPILE_TEST
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 53fc115cf459..68ee795f3ea8 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -45,6 +45,7 @@ obj-$(CONFIG_CRYPTO_DEV_TALITOS) += talitos.o
 obj-$(CONFIG_CRYPTO_DEV_UX500) += ux500/
 obj-$(CONFIG_CRYPTO_DEV_VIRTIO) += virtio/
 obj-$(CONFIG_CRYPTO_DEV_VMX) += vmx/
+obj-y += sifive-vic/
 obj-$(CONFIG_CRYPTO_DEV_BCM_SPU) += bcm/
 obj-$(CONFIG_CRYPTO_DEV_SAFEXCEL) += inside-secure/
 obj-$(CONFIG_CRYPTO_DEV_ARTPEC6) += axis/
diff --git a/drivers/crypto/sifive-vic/Kconfig b/drivers/crypto/sifive-vic/Kconfig
new file mode 100644
index 000000000000..0f1e520555ba
--- /dev/null
+++ b/drivers/crypto/sifive-vic/Kconfig
@@ -0,0 +1,10 @@
+config CRYPTO_DEV_SIFIVE_VIC_ENCRYPT
+	tristate "Encryption acceleration support on sifive vic"
+	depends on RISCV
+	select CRYPTO_ENGINE
+	select CRYPTO_RSA
+	default m
+	help
+	  Support for SIFIVE VIC cryptographic acceleration instructions on riscv64 CPU.
+	  This module supports acceleration for AES and GHASH in hardware. If you
+	  choose 'M' here, this module will be called vic-crypto.
diff --git a/drivers/crypto/sifive-vic/Makefile b/drivers/crypto/sifive-vic/Makefile
new file mode 100644
index 000000000000..27ac09e4fc58
--- /dev/null
+++ b/drivers/crypto/sifive-vic/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_CRYPTO_DEV_SIFIVE_VIC_ENCRYPT) += vic-crypto.o
+vic-crypto-objs := vic-sec.o vic-aes.o vic-sha.o vic-pka.o vic-pka-tools.o
diff --git a/drivers/crypto/sifive-vic/vic-aes.c b/drivers/crypto/sifive-vic/vic-aes.c
new file mode 100644
index 000000000000..6a59a4d24033
--- /dev/null
+++ b/drivers/crypto/sifive-vic/vic-aes.c
@@ -0,0 +1,1636 @@
+/*
+ ******************************************************************************
+ * @file  vic-aes.c
+ * @author  StarFive Technology
+ * @version  V1.0
+ * @date  08/13/2020
+ * @brief
+ ******************************************************************************
+ * @copy
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+ * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+ * TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE FOR ANY
+ * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+ * FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+ * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ * <h2><center>&copy; COPYRIGHT 2020 Shanghai StarFive Technology Co., Ltd. </center></h2>
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <crypto/hash.h>
+
+#include <crypto/scatterwalk.h>
+#include <crypto/internal/aead.h>
+#include <crypto/internal/hash.h>
+#include <crypto/internal/skcipher.h>
+
+#include "vic-sec.h"
+
+
+/* Mode mask = bits [3..0] */
+#define FLG_MODE_MASK           GENMASK(3, 0)
+
+/* Bit [4] encrypt / decrypt */
+#define FLG_ENCRYPT             BIT(4)
+
+/* Bit [31..16] status  */
+#define FLG_CCM_PADDED_WA       BIT(5)
+
+#define CR_KEY128               BIT(9)
+#define CR_KEY192               BIT(10)
+#define CR_KEY256               BIT(11)
+
+/* Registers */
+#define CRYP_CR                 0x00000000
+#define CRYP_SR                 0x00000004
+#define CRYP_DIN                0x00000008
+#define CRYP_DOUT               0x0000000C
+#define CRYP_DMACR              0x00000010
+#define CRYP_IMSCR              0x00000014
+#define CRYP_RISR               0x00000018
+#define CRYP_MISR               0x0000001C
+#define CRYP_K0LR               0x00000020
+#define CRYP_K0RR               0x00000024
+#define CRYP_K1LR               0x00000028
+#define CRYP_K1RR               0x0000002C
+#define CRYP_K2LR               0x00000030
+#define CRYP_K2RR               0x00000034
+#define CRYP_K3LR               0x00000038
+#define CRYP_K3RR               0x0000003C
+#define CRYP_IV0LR              0x00000040
+#define CRYP_IV0RR              0x00000044
+#define CRYP_IV1LR              0x00000048
+#define CRYP_IV1RR              0x0000004C
+#define CRYP_CSGCMCCM0R         0x00000050
+#define CRYP_CSGCM0R            0x00000070
+
+#define SR_BUSY                 0x00000010
+#define SR_OFNE                 0x00000004
+
+#define IMSCR_IN                BIT(0)
+#define IMSCR_OUT               BIT(1)
+
+#define MISR_IN                 BIT(0)
+#define MISR_OUT                BIT(1)
+
+/* Misc */
+#define AES_BLOCK_32            (AES_BLOCK_SIZE / sizeof(u32))
+#define GCM_CTR_INIT            1
+#define _walked_in              (cryp->in_walk.offset - cryp->in_sg->offset)
+#define _walked_out             (cryp->out_walk.offset - cryp->out_sg->offset)
+#define CRYP_AUTOSUSPEND_DELAY	50
+
+static inline int vic_aes_wait_busy(struct vic_sec_dev *sdev)
+{
+	int ret = -1;
+
+	mutex_lock(&sdev->doing);
+	if(sdev->status.sec_done&& (!sdev->status.aes_busy))
+		ret = 0;
+	mutex_unlock(&sdev->doing);
+	return ret;
+}
+
+static inline int is_ecb(struct vic_sec_dev *cryp)
+{
+	return (cryp->flags & FLG_MODE_MASK) == VIC_AES_MODE_ECB;
+}
+
+static inline int is_cbc(struct vic_sec_dev *cryp)
+{
+	return (cryp->flags & FLG_MODE_MASK) == VIC_AES_MODE_CBC;
+}
+
+static inline int is_cmac(struct vic_sec_dev *cryp)
+{
+	return (cryp->flags & FLG_MODE_MASK) == VIC_AES_MODE_CMAC;
+}
+
+static inline int is_ofb(struct vic_sec_dev *cryp)
+{
+	return (cryp->flags & FLG_MODE_MASK) == VIC_AES_MODE_OFB;
+}
+
+static inline int is_cfb(struct vic_sec_dev *cryp)
+{
+	return (cryp->flags & FLG_MODE_MASK) == VIC_AES_MODE_CFB;
+}
+
+static inline int is_ctr(struct vic_sec_dev *cryp)
+{
+	return (cryp->flags & FLG_MODE_MASK) == VIC_AES_MODE_CTR;
+}
+
+static inline int is_gcm(struct vic_sec_dev *cryp)
+{
+	return (cryp->flags & FLG_MODE_MASK) == VIC_AES_MODE_GCM;
+}
+
+static inline int is_ccm(struct vic_sec_dev *cryp)
+{
+	return (cryp->flags & FLG_MODE_MASK) == VIC_AES_MODE_CCM;
+}
+
+static inline int get_aes_mode(struct vic_sec_dev *cryp)
+{
+	return cryp->flags & FLG_MODE_MASK;
+}
+
+static inline int is_encrypt(struct vic_sec_dev *cryp)
+{
+	return !!(cryp->flags & FLG_ENCRYPT);
+}
+
+static inline int is_decrypt(struct vic_sec_dev *cryp)
+{
+	return !is_encrypt(cryp);
+}
+
+static int vic_cryp_read_auth_tag(struct vic_sec_dev *sdev);
+
+static void vic_cryp_hw_write_iv(struct vic_sec_dev *sdev, u32 *iv)
+{
+	if (!iv)
+		return;
+	if(sdev->ctx->begin_new){
+		vic_write_n(sdev->io_base + VIC_AES_CTX_RAM_OFFSET + VIC_AES_CTX_IV_OFS, (u8 *)iv,
+		    VIC_AES_IV_LEN);
+	}
+}
+
+static void vic_cryp_hw_write_ctr(struct vic_sec_dev *sdev, u32 *ctr)
+{
+	if(sdev->ctx->begin_new){
+		vic_write_n(sdev->io_base + VIC_AES_CTX_RAM_OFFSET + VIC_AES_CTX_CTR_OFS, (u8 *)ctr,
+			    VIC_AES_IV_LEN);
+	}
+}
+
+static void vic_cryp_hw_write_key(struct vic_sec_dev *sdev)
+{
+	if(sdev->ctx->begin_new){
+		vic_write_n(sdev->io_base + VIC_AES_CTX_RAM_OFFSET + VIC_AES_CTX_KEYS_OFS, sdev->ctx->key,
+			    sdev->ctx->keylen);
+	}
+}
+
+static unsigned int vic_cryp_get_input_text_len(struct vic_sec_dev *cryp)
+{
+	return is_encrypt(cryp) ? cryp->areq->cryptlen :
+				  cryp->areq->cryptlen - cryp->authsize;
+}
+
+static int vic_cryp_gcm_init(struct vic_sec_dev *sdev, u32 cfg)
+{
+	/* Phase 1 : init */
+	memcpy(sdev->last_ctr, sdev->areq->iv, 12);
+	sdev->last_ctr[3] = cpu_to_be32(GCM_CTR_INIT);
+
+	vic_cryp_hw_write_ctr(sdev,(u32 *)sdev->last_ctr);
+	return 0;
+}
+
+static int vic_cryp_write_cryp_out(struct vic_sec_dev *sdev);
+
+static int vic_cryp_ccm_init(struct vic_sec_dev *sdev, u32 cfg)
+{
+	u8 iv[AES_BLOCK_SIZE], *b0;
+	unsigned int textlen;
+
+	/* Phase 1 : init. Firstly set the CTR value to 1 (not 0) */
+	memcpy(iv, sdev->areq->iv, AES_BLOCK_SIZE);
+	memset(iv + AES_BLOCK_SIZE - 1 - iv[0], 0, iv[0] + 1);
+	//iv[AES_BLOCK_SIZE - 1] = 1;
+
+	vic_cryp_hw_write_ctr(sdev,(u32 *)iv);
+
+	/* Build B0 */
+
+	b0 = (u8 *)sdev->data;
+	memcpy(b0, iv, AES_BLOCK_SIZE);
+
+	b0[0] |= (8 * ((sdev->authsize - 2) / 2));
+
+	if (sdev->areq->assoclen)
+		b0[0] |= 0x40;
+
+	textlen = vic_cryp_get_input_text_len(sdev);
+
+	b0[AES_BLOCK_SIZE - 2] = textlen >> 8;
+	b0[AES_BLOCK_SIZE - 1] = textlen & 0xFF;
+
+	memcpy((void *)sdev->last_ctr,sdev->data,AES_BLOCK_SIZE);
+	vic_cryp_hw_write_iv(sdev,(u32 *)b0);
+
+	return 0;
+}
+
+static int vic_cryp_hw_init(struct vic_sec_dev *cryp)
+{
+	int ret;
+	u32  cfg = cryp->rctx->mode, hw_mode;
+
+	/* Set key */
+	vic_cryp_hw_write_key(cryp);
+
+	switch (cryp->ctx->keylen) {
+	case AES_KEYSIZE_128:
+		cfg |= CR_KEY128;
+		break;
+
+	case AES_KEYSIZE_192:
+		cfg |= CR_KEY192;
+		break;
+
+	default:
+	case AES_KEYSIZE_256:
+		cfg |= CR_KEY256;
+		break;
+	}
+
+	hw_mode = get_aes_mode(cryp);
+
+	cfg |= hw_mode;
+
+	memset((void *)cryp->last_ctr, 0, sizeof(cryp->last_ctr));
+
+	switch (hw_mode) {
+	case VIC_AES_MODE_GCM:
+	case VIC_AES_MODE_CCM:
+		/* Phase 1 : init */
+		if (hw_mode == VIC_AES_MODE_CCM)
+			ret = vic_cryp_ccm_init(cryp, cfg);
+		else
+			ret = vic_cryp_gcm_init(cryp, cfg);
+
+		if (ret)
+			return ret;
+		break;
+
+	case VIC_AES_MODE_CBC:
+	case VIC_AES_MODE_CFB:
+	case VIC_AES_MODE_OFB:
+		vic_cryp_hw_write_iv(cryp, (u32 *)cryp->sreq->iv);
+		break;
+	case VIC_AES_MODE_CTR:
+		vic_cryp_hw_write_ctr(cryp, (u32 *)cryp->sreq->iv);
+		memcpy((void *)cryp->last_ctr,(void *)cryp->sreq->iv,16);
+		break;
+
+	default:
+		break;
+	}
+
+	cryp->flags |= cfg;
+
+	return 0;
+}
+
+int vic_cryp_get_from_sg(struct vic_sec_request_ctx *rctx, size_t offset,
+								size_t count,size_t data_offset)
+{
+	size_t of, ct, index;
+	struct scatterlist	*sg = rctx->sg;
+
+	of = offset;
+	ct = count;
+
+	while (sg->length <= of){
+		of -= sg->length;
+
+		if (!sg_is_last(sg)){
+			sg = sg_next(sg);
+			continue;
+		} else {
+			return -EBADE;
+		}
+	}
+
+	index = data_offset;
+	while (ct > 0) {
+		if(sg->length - of >= ct) {
+			scatterwalk_map_and_copy(rctx->sdev->data + index, sg,
+					of, ct, 0);
+			index = index + ct;
+			return index - data_offset;
+		} else {
+			scatterwalk_map_and_copy(rctx->sdev->data + index, sg,
+					of, sg->length - of, 0);
+			index += sg->length - of;
+			ct = ct - (sg->length - of);
+
+			of = 0;
+		}
+		if (!sg_is_last(sg))
+			sg = sg_next(sg);
+		else
+			return -EBADE;
+	}
+	return index - data_offset;
+}
+
+static int vic_cryp_read_auth_tag(struct vic_sec_dev *sdev)
+{
+	struct vic_sec_request_ctx *rctx = sdev->rctx;
+	u32 idigest[SHA512_DIGEST_SIZE / sizeof(u32)];
+	int err = 0;
+
+	if(sdev->status.sha_busy || sdev->status.aes_busy) {
+		return -EBUSY;
+	}
+
+	vic_read_n(sdev->io_base + VIC_AES_CTX_RAM_OFFSET + VIC_AES_CTX_MAC_OFS,
+				sdev->rctx->digest,sdev->authsize);
+
+
+	if(is_cmac(sdev)) {
+		if(rctx->op & HASH_OP_FINAL) {
+			memcpy(sdev->req->result, sdev->rctx->digest, sdev->authsize);
+		} else {
+			rctx->is_load = 1;
+		}
+	} else {
+		if(is_encrypt(sdev)) {
+			sg_copy_buffer(rctx->out_sg,sg_nents(rctx->out_sg), rctx->digest,
+				       sdev->authsize, rctx->offset, 0);
+		} else {
+			scatterwalk_map_and_copy(idigest,sdev->areq->src, sdev->total_in - sdev->authsize,
+						 sdev->authsize, 0);
+			if (crypto_memneq(idigest, rctx->digest, sdev->authsize)) {
+				err = -EBADMSG;
+			}
+		}
+	}
+
+	return err;
+}
+
+static int vic_cryp_read_data(struct vic_sec_dev *sdev)
+{
+	struct vic_sec_request_ctx *rctx = sdev->rctx;
+	int count;
+
+	if(sdev->status.sha_busy || sdev->status.aes_busy) {
+		return -EBUSY;
+	}
+	if(rctx->bufcnt >= sdev->total_out) {
+		count = sdev->total_out;
+	} else {
+		count = rctx->bufcnt;
+	}
+
+	vic_read_n(sdev->io_base + VIC_AES_MSG_RAM_OFFSET,sdev->data,
+			count);
+
+	sg_copy_buffer(sdev->rctx->out_sg,sg_nents(sdev->rctx->out_sg), sdev->data,
+			count, rctx->offset, 0);
+
+	//	sdev->total_out = sdev->total_out - count;
+
+	return 0;
+}
+
+
+static int vic_gcm_zero_message_data(struct vic_sec_dev *sdev);
+
+static int vic_cryp_finish_req(struct vic_sec_dev *sdev, int err)
+{
+	if (!err && (is_gcm(sdev) || is_ccm(sdev))) {
+		/* Phase 4 : output tag */
+		err = vic_cryp_read_auth_tag(sdev);
+	}
+
+	if (is_gcm(sdev) || is_ccm(sdev)) {
+		crypto_finalize_aead_request(sdev->engine, sdev->areq, err);
+		sdev->areq = NULL;
+	} else {
+		crypto_finalize_skcipher_request(sdev->engine, sdev->sreq,
+						   err);
+		sdev->sreq = NULL;
+	}
+
+	memset(sdev->ctx->key, 0, sdev->ctx->keylen);
+
+	return err;
+}
+
+static int vic_aes_start(struct vic_sec_request_ctx *rctx)
+{
+	struct vic_sec_dev *sdev = rctx->sdev;
+	int loop, int_len = sizeof(unsigned int);
+
+	if(sdev->status.sha_busy || sdev->status.aes_busy) {
+		return -EBUSY;
+	}
+
+	for(loop = 0; loop < CFG_REGS_LEN / int_len; loop++) {
+		writel(*(rctx->aes_cfg.vs + loop), sdev->io_base + VIC_AES_CFG_REGS + loop * int_len);
+	}
+	sdev->ie.sec_done_ie = 1;
+	sdev->ie.mac_valid_ie = 1;
+
+	mutex_lock(&sdev->doing);
+	writel(sdev->ie.v, sdev->io_base + SEC_IE_REG);
+	sdev->status.aes_mac_valid = 0;
+	sdev->status.aes_busy = 1;
+	sdev->status.sec_done = 0;
+
+	rctx->aes_ctrl.aes_start = 1;
+
+	writel(rctx->aes_ctrl.v, sdev->io_base + VIC_AES_CTRL_REG);
+
+	return 0;
+}
+
+static int vic_cryp_write_assoc_out(struct vic_sec_dev *sdev)
+{
+	int ret = 0;
+	struct vic_sec_request_ctx *rctx = sdev->rctx;
+	unsigned int align_len = rctx->bufcnt % AES_BLOCK_SIZE;
+	int ap;
+
+	align_len = AES_BLOCK_SIZE - align_len;
+
+	if(is_ccm(sdev) && align_len) {
+		memset(sdev->data + rctx->bufcnt, 0, align_len);
+		rctx->bufcnt += align_len;
+		sdev->data_offset += align_len;
+	}
+
+	memset((void *)&(rctx->aes_cfg), 0, sizeof(rctx->aes_cfg));
+	memset((void *)&(rctx->aes_ctrl), 0, sizeof(rctx->aes_ctrl));
+
+	rctx->aes_cfg.authsize = sdev->authsize;
+	rctx->aes_cfg.aes_ctx_idx = 0;
+	rctx->aes_cfg.aes_blk_idx = 0;
+
+	rctx->aes_ctrl.aes_mode = get_aes_mode(sdev);
+	rctx->aes_ctrl.aes_encrypt = is_encrypt(sdev);
+	rctx->aes_ctrl.aes_key_sz = (sdev->ctx->keylen >> 3) - 2;
+	rctx->aes_ctrl.aes_str_ctx = 1;
+	rctx->aes_ctrl.aes_ret_ctx = 1;
+
+	rctx->aes_cfg.aes_assoclen = rctx->bufcnt;
+	rctx->aes_cfg.aes_n_bytes = rctx->bufcnt;
+	if (rctx->offset == 0)
+		rctx->aes_ctrl.aes_msg_begin = 1;
+	else
+		rctx->aes_ctrl.aes_msg_begin = 0;
+	ap = 0;
+	if(!is_encrypt(sdev))
+		ap = sdev->authsize;
+
+	if ((sdev->total_in - ap - rctx->assoclen == 0) &&
+		(rctx->offset + rctx->bufcnt == rctx->assoclen + sdev->data_offset)) {
+			rctx->aes_ctrl.aes_msg_end = 1;
+			rctx->aes_cfg.aes_assoclen_tot = rctx->assoclen + sdev->data_offset;
+	}
+
+	vic_write_n(sdev->io_base + VIC_AES_MSG_RAM_OFFSET, sdev->data,
+					rctx->bufcnt);
+
+	ret = vic_aes_start(rctx);
+	if (ret)
+		return ret;
+
+	if(vic_aes_wait_busy(sdev))
+		ret = -ETIMEDOUT;
+
+	return ret;
+}
+
+static int vic_cryp_write_cryp_out(struct vic_sec_dev *sdev)
+{
+	struct vic_sec_request_ctx *rctx = sdev->rctx;
+	int ret = 0;
+	int ap;
+
+	memset((void *)&(rctx->aes_cfg), 0, sizeof(rctx->aes_cfg));
+	memset((void *)&(rctx->aes_ctrl), 0, sizeof(rctx->aes_ctrl));
+
+
+	rctx->aes_cfg.authsize = sdev->authsize;
+	//if(sdev->authsize == 16)
+		//	rctx->aes_cfg.authsize = 0xff;
+	rctx->aes_cfg.aes_assoclen_tot = rctx->assoclen + sdev->data_offset;
+	rctx->aes_ctrl.aes_msg_begin = rctx->assoclen ? 0 : 1;
+
+	rctx->aes_cfg.aes_ctx_idx = 0;
+	rctx->aes_cfg.aes_blk_idx = 0;
+
+	rctx->aes_cfg.aes_n_bytes = rctx->bufcnt;
+
+	rctx->aes_ctrl.aes_mode = get_aes_mode(sdev);
+	rctx->aes_ctrl.aes_encrypt = is_encrypt(sdev);
+	rctx->aes_ctrl.aes_key_sz = (sdev->ctx->keylen >> 3) - 2;
+
+	rctx->aes_ctrl.aes_str_ctx = 1;
+	rctx->aes_ctrl.aes_ret_ctx = 1;
+
+	rctx->aes_cfg.aes_tot_n_bytes = sdev->total_in - rctx->assoclen;
+
+	ap = 0;
+	if(!is_encrypt(sdev)) {
+		rctx->aes_cfg.aes_tot_n_bytes -= sdev->authsize;
+		ap = sdev->authsize;
+	}
+
+	if (rctx->offset + rctx->bufcnt + ap == sdev->total_in) {
+		rctx->aes_ctrl.aes_msg_end = 1;
+	} else {
+		rctx->aes_ctrl.aes_msg_end = 0;
+	}
+	if(is_cmac(sdev)) {
+		if(rctx->is_load) {
+			rctx->aes_ctrl.aes_msg_begin = 0;
+			vic_write_n(sdev->io_base + VIC_AES_CTX_RAM_OFFSET + VIC_AES_CTX_MAC_OFS,
+					rctx->digest,sdev->authsize);
+			rctx->is_load = 0;
+		}
+	}
+	if(rctx->aes_ctrl.aes_msg_begin){
+		if(rctx->sdev->ctx->begin_new){
+			rctx->sdev->ctx->begin_new = 0;
+		}
+	}
+	vic_write_n(sdev->io_base + VIC_AES_MSG_RAM_OFFSET, sdev->data,
+					rctx->bufcnt);
+	//	vic_write_n(sdev->io_base + VIC_AES_MSG_RAM_OFFSET, sdev->data,
+	//				rctx->bufcnt + AES_BLOCK_SIZE);
+
+	ret = vic_aes_start(rctx);
+	if (ret)
+		return ret;
+
+	if(vic_aes_wait_busy(sdev))
+		ret = -ETIMEDOUT;
+
+	if(!is_cmac(sdev))
+		ret = vic_cryp_read_data(sdev);
+
+	return ret;
+}
+
+static bool vic_check_counter_overflow(struct vic_sec_dev *sdev, size_t count)
+{
+	struct vic_sec_request_ctx *rctx = sdev->rctx;
+	bool ret = false;
+	u32 start, end, ctr, blocks;
+
+	if(count) {
+		blocks = DIV_ROUND_UP(count, AES_BLOCK_SIZE);
+		sdev->last_ctr[3] = cpu_to_be32(be32_to_cpu(sdev->last_ctr[3]) + blocks);
+
+		if(sdev->last_ctr[3] == 0){
+			sdev->last_ctr[2] = cpu_to_be32(be32_to_cpu(sdev->last_ctr[2]) + 1);
+			if (sdev->last_ctr[2] == 0){
+				sdev->last_ctr[1] = cpu_to_be32(be32_to_cpu(sdev->last_ctr[1]) + 1);
+				if (sdev->last_ctr[1] == 0){
+					sdev->last_ctr[0] = cpu_to_be32(be32_to_cpu(sdev->last_ctr[0]) + 1);
+					if (sdev->last_ctr[1] == 0) {
+						vic_cryp_hw_write_ctr(sdev, (u32 *)sdev->last_ctr);
+					}
+				}
+			}
+		}
+	}
+
+	/* ctr counter overflow. */
+	ctr = sdev->total_in - rctx->assoclen - sdev->authsize;
+	blocks = DIV_ROUND_UP(ctr, AES_BLOCK_SIZE);
+	start = be32_to_cpu(sdev->last_ctr[3]);
+
+	end = start + blocks - 1;
+	if (end < start) {
+		sdev->ctr_over_count = AES_BLOCK_SIZE * -start;
+		ret = true;
+	}
+
+	return ret;
+}
+
+static int vic_cryp_write_data(struct vic_sec_dev *sdev)
+{
+	struct vic_sec_request_ctx *rctx = sdev->rctx;
+	size_t data_len, total, count, data_buf_len;
+	int ret;
+	bool fragmented = false;
+	u32 data_offset;
+
+	if (unlikely(!sdev->total_in)) {
+		dev_warn(sdev->dev, "No more data to process\n");
+		return -EINVAL;
+	}
+
+	/* ctr counter overflow. */
+	fragmented = vic_check_counter_overflow(sdev, 0);
+
+	total = 0;
+	rctx->offset = 0;
+	sdev->data_offset = 0;
+
+	if(is_ccm(sdev)){
+		int index = AES_BLOCK_SIZE;
+		if(rctx->assoclen <= 65280) {
+
+			((u8 *)sdev->data)[index] = (rctx->assoclen >> 8) & 0xff;
+			((u8 *)sdev->data)[index + 1] = rctx->assoclen  & 0xff;
+			sdev->data_offset = index + 2;
+		} else {
+			((u8 *)sdev->data)[index] = 0xff;
+			((u8 *)sdev->data)[index + 1] = 0xfe;
+			((u8 *)sdev->data)[index + 2] = rctx->assoclen & 0xFF000000;
+			((u8 *)sdev->data)[index + 3] = rctx->assoclen & 0x00FF0000;
+			((u8 *)sdev->data)[index + 4] = rctx->assoclen & 0x0000FF00;
+			((u8 *)sdev->data)[index + 5] = rctx->assoclen & 0x000000FF;
+			sdev->data_offset = index + 6;
+		}
+	}
+	data_offset = sdev->data_offset;
+	while(total < rctx->assoclen) {
+		data_buf_len = sdev->data_buf_len - (sdev->data_buf_len % sdev->ctx->keylen) - data_offset;
+		count = min (rctx->assoclen - rctx->offset, data_buf_len);
+		count = min (count, rctx->assoclen - total);
+		data_len = vic_cryp_get_from_sg(rctx, rctx->offset, count, data_offset);
+		if(data_len < 0)
+			return data_len;
+		if(data_len != count) {
+			return -EINVAL;
+		}
+
+		rctx->bufcnt = data_len + data_offset;
+
+		total += data_len;
+		ret = vic_cryp_write_assoc_out(sdev);
+		if(ret)
+			return ret;
+		data_offset = 0;
+		rctx->offset += data_len;
+	}
+
+	total = 0;
+
+	while(total < sdev->total_in - rctx->assoclen) {
+		data_buf_len = sdev->data_buf_len - (sdev->data_buf_len % sdev->ctx->keylen) - data_offset;
+		count = min (sdev->total_in - rctx->offset, data_buf_len);
+		count = min (count, sdev->total_in - rctx->assoclen - total);
+
+		/* ctr counter overflow. */
+		if(fragmented && sdev->ctr_over_count != 0) {
+			if (count >= sdev->ctr_over_count) {
+				count = sdev->ctr_over_count;
+			}
+		}
+
+		data_len = vic_cryp_get_from_sg(rctx, rctx->offset, count,data_offset);
+		if(data_len < 0)
+			return data_len;
+		if(data_len != count) {
+			return -EINVAL;
+		}
+
+		rctx->bufcnt = data_len;
+		total += data_len;
+
+		if(!is_encrypt(sdev) && (total + rctx->assoclen >= sdev->total_in))
+		        rctx->bufcnt = rctx->bufcnt - sdev->authsize;
+
+		if(rctx->bufcnt) {
+			ret = vic_cryp_write_cryp_out(sdev);
+			if(ret)
+				return ret;
+		}
+		rctx->offset += data_len;
+
+		fragmented = vic_check_counter_overflow(sdev, data_len);
+	}
+
+	return 0;
+}
+
+static int vic_cmac_write_data(struct vic_sec_dev *sdev)
+{
+	struct vic_sec_request_ctx *rctx = sdev->rctx;
+	size_t data_len, count, data_buf_len;
+
+	int ret;
+
+	if(!sdev->total_in) {
+		sdev->rctx->bufcnt = 0;
+		sdev->rctx->offset = 0;
+		ret = vic_cryp_write_cryp_out(sdev);
+		if(ret)
+			return ret;
+	}
+
+	while(rctx->total < sdev->total_in) {
+		data_buf_len = sdev->data_buf_len - (sdev->data_buf_len % sdev->ctx->keylen) - sdev->data_offset;
+		count = min (sdev->total_in - rctx->offset, data_buf_len);
+		count = min (count, sdev->total_in - rctx->total);
+
+		if(rctx->op == HASH_OP_UPDATE) {
+			if((count > sdev->ctx->keylen) && (count % sdev->ctx->keylen)) {
+				count = count - count % sdev->ctx->keylen;
+			}
+		}
+
+		data_len = vic_cryp_get_from_sg(rctx, rctx->offset, count, sdev->data_offset);
+		if(data_len < 0)
+			return data_len;
+		if(data_len != count) {
+			return -EINVAL;
+		}
+
+		rctx->bufcnt = data_len + sdev->data_offset;
+		rctx->total += data_len;
+
+		if((rctx->op == HASH_OP_UPDATE) &&
+			(data_len < sdev->ctx->keylen)) {
+			sdev->data_offset = data_len;
+		} else {
+			ret = vic_cryp_write_cryp_out(sdev);
+			if(ret)
+				return ret;
+			rctx->offset += data_len;
+		}
+	}
+
+	if(sdev->data_offset && (rctx->op & HASH_OP_FINAL)) {
+		ret = vic_cryp_write_cryp_out(sdev);
+		if(ret)
+			return ret;
+		rctx->offset += sdev->data_offset;
+	}
+
+	return 0;
+}
+
+static int vic_gcm_zero_message_data(struct vic_sec_dev *sdev)
+{
+	int ret;
+
+	sdev->rctx->bufcnt = 0;
+	sdev->rctx->offset = 0;
+	ret = vic_cryp_write_cryp_out(sdev);
+
+	if(ret)
+		return ret;
+
+	return 0;
+}
+
+static int vic_cryp_cpu_start(struct vic_sec_dev *sdev, struct vic_sec_request_ctx *rctx)
+{
+	int ret;
+
+	ret = vic_cryp_write_data(sdev);
+	if(ret)
+		return ret;
+
+	ret = vic_cryp_finish_req(sdev,ret);
+
+	return ret;
+}
+
+static int vic_cryp_cipher_one_req(struct crypto_engine *engine, void *areq);
+static int vic_cryp_prepare_cipher_req(struct crypto_engine *engine,
+					 void *areq);
+
+static int vic_cryp_cra_init(struct crypto_skcipher *tfm)
+{
+	struct vic_sec_ctx *ctx = crypto_skcipher_ctx(tfm);
+
+	ctx->sdev = vic_sec_find_dev(ctx);
+	if (!ctx->sdev)
+		return -ENODEV;
+
+	mutex_lock(&ctx->sdev->lock);
+	vic_clk_enable(ctx->sdev,AES_CLK);
+
+	crypto_skcipher_set_reqsize(tfm, sizeof(struct vic_sec_request_ctx));
+
+	ctx->begin_new = 1;
+	ctx->enginectx.op.do_one_request = vic_cryp_cipher_one_req;
+	ctx->enginectx.op.prepare_request = vic_cryp_prepare_cipher_req;
+	ctx->enginectx.op.unprepare_request = NULL;
+	return 0;
+}
+
+static void vic_cryp_cra_exit(struct crypto_skcipher *tfm)
+{
+	struct vic_sec_ctx *ctx = crypto_skcipher_ctx(tfm);
+
+	ctx->begin_new = 0;
+	ctx->enginectx.op.do_one_request = NULL;
+	ctx->enginectx.op.prepare_request = NULL;
+	ctx->enginectx.op.unprepare_request = NULL;
+
+	vic_clk_disable(ctx->sdev,AES_CLK);
+	mutex_unlock(&ctx->sdev->lock);
+}
+
+static int vic_cryp_aead_one_req(struct crypto_engine *engine, void *areq);
+static int vic_cryp_prepare_aead_req(struct crypto_engine *engine,
+				       void *areq);
+
+static int vic_cryp_aes_aead_init(struct crypto_aead *tfm)
+{
+	struct vic_sec_ctx *ctx = crypto_aead_ctx(tfm);
+
+	ctx->sdev = vic_sec_find_dev(ctx);
+
+	if (!ctx->sdev)
+		return -ENODEV;
+
+	mutex_lock(&ctx->sdev->lock);
+	vic_clk_enable(ctx->sdev,AES_CLK);
+
+	tfm->reqsize = sizeof(struct vic_sec_request_ctx);
+
+	ctx->begin_new = 1;
+	ctx->enginectx.op.do_one_request = vic_cryp_aead_one_req;
+	ctx->enginectx.op.prepare_request = vic_cryp_prepare_aead_req;
+	ctx->enginectx.op.unprepare_request = NULL;
+
+	return 0;
+}
+
+static void vic_cryp_aes_aead_exit(struct crypto_aead *tfm)
+{
+	struct vic_sec_ctx *ctx = crypto_aead_ctx(tfm);
+
+	ctx->begin_new = 0;
+	ctx->enginectx.op.do_one_request = NULL;
+	ctx->enginectx.op.prepare_request = NULL;
+	ctx->enginectx.op.unprepare_request = NULL;
+
+	vic_clk_disable(ctx->sdev,AES_CLK);
+	mutex_unlock(&ctx->sdev->lock);
+}
+
+static int vic_cryp_crypt(struct skcipher_request *req, unsigned long mode)
+{
+	struct vic_sec_ctx *ctx = crypto_skcipher_ctx(
+			crypto_skcipher_reqtfm(req));
+	struct vic_sec_request_ctx *rctx = skcipher_request_ctx(req);
+	struct vic_sec_dev *sdev = ctx->sdev;
+
+	if (!sdev)
+		return -ENODEV;
+
+	rctx->mode = mode;
+	rctx->req_type = AES_ABLK;
+
+	return crypto_transfer_skcipher_request_to_engine(sdev->engine, req);
+}
+
+static int vic_cryp_aead_crypt(struct aead_request *req, unsigned long mode)
+{
+	struct vic_sec_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
+	struct vic_sec_request_ctx *rctx = aead_request_ctx(req);
+	struct vic_sec_dev *cryp = ctx->sdev;
+
+	if (!cryp)
+		return -ENODEV;
+
+	rctx->mode = mode;
+	rctx->req_type = AES_AEAD;
+
+	return crypto_transfer_aead_request_to_engine(cryp->engine, req);
+}
+
+static int vic_cryp_setkey(struct crypto_skcipher *tfm, const u8 *key,
+			     unsigned int keylen)
+{
+	struct vic_sec_ctx *ctx = crypto_skcipher_ctx(tfm);
+
+	memcpy(ctx->key, key, keylen);
+	ctx->keylen = keylen;
+
+	return 0;
+}
+
+static int vic_cryp_aes_setkey(struct crypto_skcipher *tfm, const u8 *key,
+				 unsigned int keylen)
+{
+	if (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&
+	    keylen != AES_KEYSIZE_256)
+		return -EINVAL;
+	else
+		return vic_cryp_setkey(tfm, key, keylen);
+}
+
+static int vic_cryp_aes_aead_setkey(struct crypto_aead *tfm, const u8 *key,
+				      unsigned int keylen)
+{
+	struct vic_sec_ctx *ctx = crypto_aead_ctx(tfm);
+
+	if (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&
+	    keylen != AES_KEYSIZE_256) {
+		return -EINVAL;
+	}
+
+	memcpy(ctx->key, key, keylen);
+	ctx->keylen = keylen;
+
+	return 0;
+}
+
+static int vic_cryp_aes_gcm_setauthsize(struct crypto_aead *tfm,
+					  unsigned int authsize)
+{
+	return authsize == AES_BLOCK_SIZE ? 0 : -EINVAL;
+}
+
+static int vic_cryp_aes_ccm_setauthsize(struct crypto_aead *tfm,
+					  unsigned int authsize)
+{
+	switch (authsize) {
+	case 4:
+	case 6:
+	case 8:
+	case 10:
+	case 12:
+	case 14:
+	case 16:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int vic_cryp_aes_ecb_encrypt(struct skcipher_request *req)
+{
+	return vic_cryp_crypt(req,  VIC_AES_MODE_ECB | FLG_ENCRYPT);
+}
+
+static int vic_cryp_aes_ecb_decrypt(struct skcipher_request *req)
+{
+	return vic_cryp_crypt(req,  VIC_AES_MODE_ECB);
+}
+
+static int vic_cryp_aes_cbc_encrypt(struct skcipher_request *req)
+{
+	return vic_cryp_crypt(req,  VIC_AES_MODE_CBC | FLG_ENCRYPT);
+}
+
+static int vic_cryp_aes_cbc_decrypt(struct skcipher_request *req)
+{
+	return vic_cryp_crypt(req,  VIC_AES_MODE_CBC);
+}
+
+static int vic_cryp_aes_cfb_encrypt(struct skcipher_request *req)
+{
+	return vic_cryp_crypt(req,  VIC_AES_MODE_CFB | FLG_ENCRYPT);
+}
+
+static int vic_cryp_aes_cfb_decrypt(struct skcipher_request *req)
+{
+	return vic_cryp_crypt(req,  VIC_AES_MODE_CFB);
+}
+
+static int vic_cryp_aes_ofb_encrypt(struct skcipher_request *req)
+{
+	return vic_cryp_crypt(req,  VIC_AES_MODE_OFB | FLG_ENCRYPT);
+}
+
+static int vic_cryp_aes_ofb_decrypt(struct skcipher_request *req)
+{
+	return vic_cryp_crypt(req,  VIC_AES_MODE_OFB);
+}
+
+static int vic_cryp_aes_ctr_encrypt(struct skcipher_request *req)
+{
+	return vic_cryp_crypt(req,  VIC_AES_MODE_CTR | FLG_ENCRYPT);
+}
+
+static int vic_cryp_aes_ctr_decrypt(struct skcipher_request *req)
+{
+	return vic_cryp_crypt(req,  VIC_AES_MODE_CTR);
+}
+
+static int vic_cryp_aes_gcm_encrypt(struct aead_request *req)
+{
+	return vic_cryp_aead_crypt(req,  VIC_AES_MODE_GCM | FLG_ENCRYPT);
+}
+
+static int vic_cryp_aes_gcm_decrypt(struct aead_request *req)
+{
+	return vic_cryp_aead_crypt(req,  VIC_AES_MODE_GCM);
+}
+
+static int vic_cryp_aes_ccm_encrypt(struct aead_request *req)
+{
+	return vic_cryp_aead_crypt(req,  VIC_AES_MODE_CCM | FLG_ENCRYPT);
+}
+
+static int vic_cryp_aes_ccm_decrypt(struct aead_request *req)
+{
+	return vic_cryp_aead_crypt(req, VIC_AES_MODE_CCM);
+}
+
+static int vic_cryp_prepare_req(struct skcipher_request *req,
+				  struct aead_request *areq)
+{
+	struct vic_sec_ctx *ctx;
+	struct vic_sec_dev *sdev;
+	struct vic_sec_request_ctx *rctx;
+	int ret;
+
+	if (!req && !areq)
+		return -EINVAL;
+
+	ctx = req ? crypto_skcipher_ctx(crypto_skcipher_reqtfm(req)) :
+		    crypto_aead_ctx(crypto_aead_reqtfm(areq));
+
+	sdev = ctx->sdev;
+
+	if (!sdev)
+		return -ENODEV;
+	if(is_ccm(sdev)){
+		if(!areq->assoclen) {
+			dev_info(sdev->dev, "AES CCM input assoclen can not be 0\n");
+			return -EINVAL;
+		}
+	}
+
+	rctx = req ? skcipher_request_ctx(req) : aead_request_ctx(areq);
+
+	rctx->sdev = sdev;
+	ctx->sdev = sdev;
+
+	sdev->flags = rctx->mode;
+	sdev->ctx = ctx;
+	sdev->rctx = rctx;
+
+	if (req) {
+		sdev->sreq = req;
+		sdev->areq = NULL;
+		sdev->total_in = req->cryptlen;
+		sdev->total_out = sdev->total_in;
+		sdev->authsize = 0;
+		rctx->assoclen = 0;
+	} else {
+		/*
+		 * Length of input and output data:
+		 * Encryption case:
+		 *  INPUT  =   AssocData  ||   PlainText
+		 *          <- assoclen ->  <- cryptlen ->
+		 *          <------- total_in ----------->
+		 *
+		 *  OUTPUT =   AssocData  ||  CipherText  ||   AuthTag
+		 *          <- assoclen ->  <- cryptlen ->  <- authsize ->
+		 *          <---------------- total_out ----------------->
+		 *
+		 * Decryption case:
+		 *  INPUT  =   AssocData  ||  CipherText  ||  AuthTag
+		 *          <- assoclen ->  <--------- cryptlen --------->
+		 *                                          <- authsize ->
+		 *          <---------------- total_in ------------------>
+		 *
+		 *  OUTPUT =   AssocData  ||   PlainText
+		 *          <- assoclen ->  <- crypten - authsize ->
+		 *          <---------- total_out ----------------->
+		 */
+		sdev->sreq = NULL;
+		sdev->areq = areq;
+		sdev->authsize = crypto_aead_authsize(crypto_aead_reqtfm(areq));
+		sdev->total_in = areq->assoclen + areq->cryptlen;
+		rctx->assoclen = areq->assoclen;
+		if (is_encrypt(sdev))
+			/* Append auth tag to output */
+			sdev->total_out = sdev->total_in + sdev->authsize;
+		else
+			/* No auth tag in output */
+			sdev->total_out = sdev->total_in - sdev->authsize;
+	}
+
+	rctx->sg = req ? req->src : areq->src;
+	rctx->out_sg = req ? req->dst : areq->dst;
+
+	sdev->in_sg_len = sg_nents_for_len(rctx->sg, sdev->total_in);
+	if (sdev->in_sg_len < 0) {
+		dev_err(sdev->dev, "Cannot get in_sg_len\n");
+		ret = sdev->in_sg_len;
+		goto out;
+	}
+
+	sdev->out_sg_len = sg_nents_for_len(rctx->out_sg, sdev->total_out);
+	if (sdev->out_sg_len < 0) {
+		dev_err(sdev->dev, "Cannot get out_sg_len\n");
+		ret = sdev->out_sg_len;
+		goto out;
+	}
+#if 0
+	if (is_gcm(sdev) || is_ccm(sdev)) {
+		/* In output, jump after assoc data */
+		sdev->total_out -= sdev->areq->assoclen;
+	}
+#endif
+	ret = vic_cryp_hw_init(sdev);
+
+out:
+
+	return ret;
+}
+
+static int vic_cryp_prepare_cipher_req(struct crypto_engine *engine,
+					 void *areq)
+{
+	struct skcipher_request *req = container_of(areq,
+						      struct skcipher_request,
+						      base);
+
+	return vic_cryp_prepare_req(req, NULL);
+}
+
+static int vic_cryp_cipher_one_req(struct crypto_engine *engine, void *areq)
+{
+	struct skcipher_request *req = container_of(areq,
+						      struct skcipher_request,
+						      base);
+	struct vic_sec_request_ctx *rctx = skcipher_request_ctx(req);
+	struct vic_sec_ctx *ctx = crypto_skcipher_ctx(
+			crypto_skcipher_reqtfm(req));
+	struct vic_sec_dev *cryp = ctx->sdev;
+
+	if (!cryp)
+		return -ENODEV;
+
+	return vic_cryp_cpu_start(cryp,rctx);
+}
+
+static int vic_cryp_prepare_aead_req(struct crypto_engine *engine, void *areq)
+{
+	struct aead_request *req = container_of(areq, struct aead_request,
+						base);
+
+	return vic_cryp_prepare_req(NULL, req);
+}
+
+static int vic_cryp_aead_one_req(struct crypto_engine *engine, void *areq)
+{
+	struct aead_request *req = container_of(areq, struct aead_request,
+						base);
+	struct vic_sec_request_ctx *rctx = aead_request_ctx(req);
+	struct vic_sec_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
+	struct vic_sec_dev *sdev = ctx->sdev;
+
+	if (!sdev)
+		return -ENODEV;
+
+	if (unlikely(!sdev->areq->assoclen &&
+		     !vic_cryp_get_input_text_len(sdev))) {
+		/* No input data to process: get tag and finish */
+		vic_gcm_zero_message_data(sdev);
+		vic_cryp_finish_req(sdev, 0);
+		return 0;
+	}
+
+	return vic_cryp_cpu_start(sdev, rctx);
+}
+
+static int vic_cryp_prepare_cmac_req(struct crypto_engine *engine,
+					 void *areq)
+{
+	struct ahash_request *req = container_of(areq, struct ahash_request,
+						 base);
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
+	struct vic_sec_dev *sdev;
+	struct vic_sec_request_ctx *rctx;
+	int ret;
+
+	sdev = ctx->sdev;
+
+	if (!sdev)
+		return -ENODEV;
+
+	rctx = ahash_request_ctx(req);
+
+	rctx->sdev = sdev;
+	ctx->sdev = sdev;
+
+	sdev->flags = rctx->mode;
+	sdev->ctx = ctx;
+	sdev->rctx = rctx;
+
+	sdev->req = req;
+	sdev->total_in = req->nbytes;
+	sdev->authsize = AES_BLOCK_SIZE;
+	rctx->assoclen = 0;
+
+	//rctx->sg = req->src;
+
+	ret = vic_cryp_hw_init(sdev);
+
+	return ret;
+}
+
+static int vic_cryp_cmac_one_req(struct crypto_engine *engine, void *areq)
+{
+	struct ahash_request *req = container_of(areq, struct ahash_request,
+						 base);
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
+	struct vic_sec_dev *sdev = ctx->sdev;
+	int ret;
+
+	if (!sdev)
+		return -ENODEV;
+
+	ret = vic_cmac_write_data(sdev);
+
+	if(ret)
+		return ret;
+
+	ret = vic_cryp_read_auth_tag(sdev);
+
+	crypto_finalize_hash_request(sdev->engine, sdev->req, ret);
+	sdev->req = NULL;
+
+
+	return ret;
+}
+
+static int vic_cryp_aes_cmac_init(struct crypto_tfm *tfm)
+{
+	struct vic_sec_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	ctx->sdev = vic_sec_find_dev(ctx);
+
+	if (!ctx->sdev)
+		return -ENODEV;
+
+	mutex_lock(&ctx->sdev->lock);
+	vic_clk_enable(ctx->sdev,AES_CLK);
+
+	crypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),
+				 sizeof(struct vic_sec_request_ctx));
+
+	ctx->begin_new = 1;
+	ctx->enginectx.op.do_one_request = vic_cryp_cmac_one_req;
+	ctx->enginectx.op.prepare_request = vic_cryp_prepare_cmac_req;
+	ctx->enginectx.op.unprepare_request = NULL;
+
+	return 0;
+}
+
+static void vic_cryp_aes_cmac_exit(struct crypto_tfm *tfm)
+{
+	struct vic_sec_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	ctx->begin_new = 0;
+	ctx->enginectx.op.do_one_request = NULL;
+	ctx->enginectx.op.prepare_request = NULL;
+	ctx->enginectx.op.unprepare_request = NULL;
+
+	vic_clk_disable(ctx->sdev,AES_CLK);
+	mutex_unlock(&ctx->sdev->lock);
+}
+
+static int vic_aes_cmac_init(struct ahash_request *req)
+{
+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct vic_sec_dev *sdev = ctx->sdev;
+
+	if (!sdev)
+		return -ENODEV;
+
+	rctx->sdev = sdev;
+	rctx->mode = VIC_AES_MODE_CMAC | FLG_ENCRYPT;
+	rctx->req_type = AES_ABLK;
+	rctx->op = 0;
+	rctx->is_load = 0;
+	rctx->bufcnt = 0;
+	rctx->offset = 0;
+	sdev->data_offset = 0;
+
+	return 0;
+}
+static int vic_aes_cmac_update(struct ahash_request *req)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct vic_sec_dev *sdev = rctx->sdev;
+
+	if (!req->nbytes)
+		return 0;
+
+	rctx->total = 0;
+	rctx->sg = req->src;
+	rctx->offset = 0;
+
+	rctx->op |= HASH_OP_UPDATE;
+
+	return crypto_transfer_hash_request_to_engine(sdev->engine, req);
+}
+
+static int vic_aes_cmac_final(struct ahash_request *req)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct vic_sec_dev *sdev = rctx->sdev;
+
+	rctx->op |= HASH_OP_FINAL;
+
+	return crypto_transfer_hash_request_to_engine(sdev->engine, req);
+}
+
+static int vic_aes_cmac_finup(struct ahash_request *req)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+	int err1, err2;
+
+	rctx->op |= HASH_OP_FINAL | HASH_OP_UPDATE;
+
+	err1 = vic_aes_cmac_update(req);
+
+	if (err1 == -EINPROGRESS || err1 == -EBUSY)
+		return err1;
+
+	/*
+	 * final() has to be always called to cleanup resources
+	 * even if update() failed, except EINPROGRESS
+	 */
+	err2 = vic_aes_cmac_final(req);
+
+	return err1 ?: err2;
+}
+
+static int vic_aes_cmac_digest(struct ahash_request *req)
+{
+	return vic_aes_cmac_init(req) ?: vic_aes_cmac_finup(req);
+}
+
+static int vic_aes_cmac_setkey(struct crypto_ahash *tfm,
+			     const u8 *key, unsigned int keylen)
+{
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+
+
+	if (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&
+	    keylen != AES_KEYSIZE_256)
+		return -EINVAL;
+
+	memcpy(ctx->key, key, keylen);
+	ctx->keylen = keylen;
+
+	return 0;
+}
+
+static int vic_aes_cmac_export(struct ahash_request *req, void *out)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct vic_sec_dev *sdev = rctx->sdev;
+
+	rctx->digcnt = sdev->authsize;
+
+	vic_read_n(sdev->io_base + VIC_AES_CTX_RAM_OFFSET + VIC_AES_CTX_MAC_OFS,
+				sdev->rctx->digest,rctx->digcnt);
+
+	memcpy(out, rctx, sizeof(*rctx));
+
+	return 0;
+}
+
+static int vic_aes_cmac_import(struct ahash_request *req, const void *in)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct vic_sec_dev *sdev = rctx->sdev;
+
+	memcpy(rctx, in, sizeof(*rctx));
+	vic_write_n(sdev->io_base + VIC_AES_CTX_RAM_OFFSET + VIC_AES_CTX_MAC_OFS,
+				sdev->rctx->digest,rctx->digcnt);
+	sdev->authsize = rctx->digcnt;
+
+	return 0;
+}
+
+static struct ahash_alg algs_aes_cmac[] = {
+	{
+		.init = vic_aes_cmac_init,
+		.update = vic_aes_cmac_update,
+		.final = vic_aes_cmac_final,
+		.finup = vic_aes_cmac_finup,
+		.digest = vic_aes_cmac_digest,
+		.setkey	= vic_aes_cmac_setkey,
+		.export = vic_aes_cmac_export,
+		.import = vic_aes_cmac_import,
+		.halg = {
+			.digestsize = AES_BLOCK_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "cmac(aes)",
+				.cra_driver_name = "vic-cmac-aes",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+				             CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = AES_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_cryp_aes_cmac_init,
+				.cra_exit = vic_cryp_aes_cmac_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+};
+
+static struct skcipher_alg crypto_algs[] = {
+{
+	.base.cra_name		= "ecb(aes)",
+	.base.cra_driver_name	= "vic-ecb-aes",
+	.base.cra_priority		= 200,
+	.base.cra_flags		= CRYPTO_ALG_ASYNC,
+	.base.cra_blocksize		= AES_BLOCK_SIZE,
+	.base.cra_ctxsize		= sizeof(struct vic_sec_ctx),
+	.base.cra_alignmask		= 0xf,
+	.base.cra_module		= THIS_MODULE,
+	.init		= vic_cryp_cra_init,
+	.exit               = vic_cryp_cra_exit,
+	.min_keysize	= AES_MIN_KEY_SIZE,
+	.max_keysize	= AES_MAX_KEY_SIZE,
+	.setkey		= vic_cryp_aes_setkey,
+	.encrypt	= vic_cryp_aes_ecb_encrypt,
+	.decrypt	= vic_cryp_aes_ecb_decrypt,
+},
+{
+	.base.cra_name		= "cbc(aes)",
+	.base.cra_driver_name	= "vic-cbc-aes",
+	.base.cra_priority		= 200,
+	.base.cra_flags		=  CRYPTO_ALG_ASYNC,
+	.base.cra_blocksize		= AES_BLOCK_SIZE,
+	.base.cra_ctxsize		= sizeof(struct vic_sec_ctx),
+	.base.cra_alignmask		= 0xf,
+	.base.cra_module		= THIS_MODULE,
+	.init		= vic_cryp_cra_init,
+	.exit               = vic_cryp_cra_exit,
+	.min_keysize	= AES_MIN_KEY_SIZE,
+	.max_keysize	= AES_MAX_KEY_SIZE,
+	.ivsize		= AES_BLOCK_SIZE,
+	.setkey		= vic_cryp_aes_setkey,
+	.encrypt	= vic_cryp_aes_cbc_encrypt,
+	.decrypt	= vic_cryp_aes_cbc_decrypt,
+},
+{
+	.base.cra_name		= "ctr(aes)",
+	.base.cra_driver_name	= "vic-ctr-aes",
+	.base.cra_priority		= 200,
+	.base.cra_flags		= CRYPTO_ALG_ASYNC,
+	.base.cra_blocksize		= 1,
+	.base.cra_ctxsize		= sizeof(struct vic_sec_ctx),
+	.base.cra_alignmask		= 0xf,
+	.base.cra_module		= THIS_MODULE,
+	.init		= vic_cryp_cra_init,
+	.exit               = vic_cryp_cra_exit,
+	.min_keysize	= AES_MIN_KEY_SIZE,
+	.max_keysize	= AES_MAX_KEY_SIZE,
+	.ivsize		= AES_BLOCK_SIZE,
+	.setkey		= vic_cryp_aes_setkey,
+	.encrypt	= vic_cryp_aes_ctr_encrypt,
+	.decrypt	= vic_cryp_aes_ctr_decrypt,
+},
+{
+	.base.cra_name		= "cfb(aes)",
+	.base.cra_driver_name	= "vic-cfb-aes",
+	.base.cra_priority		= 200,
+	.base.cra_flags		= CRYPTO_ALG_ASYNC,
+	.base.cra_blocksize		= AES_BLOCK_SIZE,
+	.base.cra_ctxsize		= sizeof(struct vic_sec_ctx),
+	.base.cra_alignmask		= 0xf,
+	.base.cra_module		= THIS_MODULE,
+	.init		= vic_cryp_cra_init,
+	.exit               = vic_cryp_cra_exit,
+	.min_keysize	= AES_MIN_KEY_SIZE,
+	.max_keysize	= AES_MAX_KEY_SIZE,
+	.ivsize		= AES_BLOCK_SIZE,
+	.setkey		= vic_cryp_aes_setkey,
+	.encrypt	= vic_cryp_aes_cfb_encrypt,
+	.decrypt	= vic_cryp_aes_cfb_decrypt,
+},
+{
+	.base.cra_name		= "ofb(aes)",
+	.base.cra_driver_name	= "vic-ofb-aes",
+	.base.cra_priority		= 200,
+	.base.cra_flags		= CRYPTO_ALG_ASYNC,
+	.base.cra_blocksize		= AES_BLOCK_SIZE,
+	.base.cra_ctxsize		= sizeof(struct vic_sec_ctx),
+	.base.cra_alignmask		= 0xf,
+	.base.cra_module		= THIS_MODULE,
+	.init		= vic_cryp_cra_init,
+	.exit               = vic_cryp_cra_exit,
+	.min_keysize	= AES_MIN_KEY_SIZE,
+	.max_keysize	= AES_MAX_KEY_SIZE,
+	.ivsize		= AES_BLOCK_SIZE,
+	.setkey		= vic_cryp_aes_setkey,
+	.encrypt	= vic_cryp_aes_ofb_encrypt,
+	.decrypt	= vic_cryp_aes_ofb_decrypt,
+},
+};
+
+static struct aead_alg aead_algs[] = {
+#if 1
+{
+	.setkey		= vic_cryp_aes_aead_setkey,
+	.setauthsize	= vic_cryp_aes_gcm_setauthsize,
+	.encrypt	= vic_cryp_aes_gcm_encrypt,
+	.decrypt	= vic_cryp_aes_gcm_decrypt,
+	.init		= vic_cryp_aes_aead_init,
+	.exit		= vic_cryp_aes_aead_exit,
+	.ivsize		= 12,
+	.maxauthsize	= AES_BLOCK_SIZE,
+
+	.base = {
+		.cra_name		= "gcm(aes)",
+		.cra_driver_name	= "vic-gcm-aes",
+		.cra_priority		= 200,
+		.cra_flags		= CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= 1,
+		.cra_ctxsize		= sizeof(struct vic_sec_ctx),
+		.cra_alignmask		= 0xf,
+		.cra_module		= THIS_MODULE,
+	},
+},
+#endif
+{
+	.setkey		= vic_cryp_aes_aead_setkey,
+	.setauthsize	= vic_cryp_aes_ccm_setauthsize,
+	.encrypt	= vic_cryp_aes_ccm_encrypt,
+	.decrypt	= vic_cryp_aes_ccm_decrypt,
+	.init		= vic_cryp_aes_aead_init,
+	.exit		= vic_cryp_aes_aead_exit,
+	.ivsize		= AES_BLOCK_SIZE,
+	.maxauthsize	= AES_BLOCK_SIZE,
+
+	.base = {
+		.cra_name		= "ccm(aes)",
+		.cra_driver_name	= "vic-ccm-aes",
+		.cra_priority		= 200,
+		.cra_flags		= CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= 1,
+		.cra_ctxsize		= sizeof(struct vic_sec_ctx),
+		.cra_alignmask		= 0xf,
+		.cra_module		= THIS_MODULE,
+	},
+},
+};
+#if 0
+int vic_aes_register_algs(void)
+{return 0;}
+
+int vic_aes_unregister_algs(void)
+{return 0;}
+#else
+int vic_aes_register_algs(void)
+{
+	int ret;
+#if 1
+	ret = crypto_register_ahashes(algs_aes_cmac, ARRAY_SIZE(algs_aes_cmac));
+	if (ret) {
+		printk("Could not register algs_aes_cmac\n");
+		goto err_hash;
+	}
+
+	ret = crypto_register_skciphers(crypto_algs, ARRAY_SIZE(crypto_algs));
+	if (ret) {
+		printk("Could not register algs\n");
+		goto err_algs;
+	}
+#endif
+	ret = crypto_register_aeads(aead_algs, ARRAY_SIZE(aead_algs));
+	if (ret)
+		goto err_aead_algs;
+
+	return 0;
+
+err_aead_algs:
+	crypto_unregister_skciphers(crypto_algs, ARRAY_SIZE(crypto_algs));
+err_algs:
+	crypto_unregister_ahashes(algs_aes_cmac, ARRAY_SIZE(algs_aes_cmac));
+err_hash:
+	return ret;
+}
+
+int vic_aes_unregister_algs(void)
+{
+
+	crypto_unregister_aeads(aead_algs, ARRAY_SIZE(aead_algs));
+#if 1
+	crypto_unregister_skciphers(crypto_algs, ARRAY_SIZE(crypto_algs));
+
+	crypto_unregister_ahashes(algs_aes_cmac, ARRAY_SIZE(algs_aes_cmac));
+#endif
+	return 0;
+}
+#endif
diff --git a/drivers/crypto/sifive-vic/vic-pka-hw.h b/drivers/crypto/sifive-vic/vic-pka-hw.h
new file mode 100644
index 000000000000..b6b420bf0e44
--- /dev/null
+++ b/drivers/crypto/sifive-vic/vic-pka-hw.h
@@ -0,0 +1,1671 @@
+// ------------------------------------------------------------------------
+//
+//                (C) COPYRIGHT 2011 - 2015 SYNOPSYS, INC.
+//                          ALL RIGHTS RESERVED
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  version 2 as published by the Free Software Foundation.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, see <https://gnu.org/licenses/>.
+//
+// ------------------------------------------------------------------------
+
+#ifndef __VIC_PKA_HW_H__
+#define __VIC_PKA_HW_H__
+
+/* Control/status registers */
+enum {
+   PKA_CTRL = 0,
+   PKA_ENTRY,
+   PKA_RC,
+   PKA_BUILD_CONF,
+   PKA_F_STACK,
+   PKA_INST_SINCE_GO,
+   PKA_P_STACK,
+   PKA_CONF,
+   PKA_STATUS,
+   PKA_FLAGS,
+   PKA_WATCHDOG,
+   PKA_CYCLES_SINCE_GO,
+   PKA_INDEX_I,
+   PKA_INDEX_J,
+   PKA_INDEX_K,
+   PKA_INDEX_L,
+   PKA_IRQ_EN,
+   PKA_DTA_JUMP,
+   PKA_LFSR_SEED,
+
+   PKA_BANK_SWITCH_A = 20,
+   PKA_BANK_SWITCH_B,
+   PKA_BANK_SWITCH_C,
+   PKA_BANK_SWITCH_D,
+
+   PKA_OPERAND_A_BASE = 0x100,
+   PKA_OPERAND_B_BASE = 0x200,
+   PKA_OPERAND_C_BASE = 0x300,
+   PKA_OPERAND_D_BASE = 0x400,
+
+   /* F/W base for old cores */
+   PKA_FIRMWARE_BASE = 0x800,
+
+   /* F/W base for new ("type 2") cores, with fixed RAM/ROM split offset */
+   PKA_FIRMWARE_T2_BASE = 0x1000,
+   PKA_FIRMWARE_T2_SPLIT = 0x1800
+};
+
+#define PKA_MAX_OPERAND_SIZE    512 /* 4096 bits */
+#define PKA_ECC521_OPERAND_SIZE  66 /* 528 bits */
+#define PKA_OPERAND_BANK_SIZE 0x400
+
+#define PKA_CTRL_GO                31
+#define PKA_CTRL_STOP_RQST         27
+#define PKA_CTRL_M521_MODE         16
+#define PKA_CTRL_M521_MODE_BITS     5
+#define PKA_CTRL_BASE_RADIX         8
+#define PKA_CTRL_BASE_RADIX_BITS    3
+#define PKA_CTRL_PARTIAL_RADIX      0
+#define PKA_CTRL_PARTIAL_RADIX_BITS 8
+
+#define PKA_CTRL_M521_ECC521  9
+
+#define PKA_RC_BUSY          31
+#define PKA_RC_IRQ           30
+#define PKA_RC_WR_PENDING    29
+#define PKA_RC_ZERO          28
+#define PKA_RC_REASON        16
+#define PKA_RC_REASON_BITS    8
+
+#define PKA_BC_FORMAT_TYPE      30
+#define PKA_BC_FORMAT_TYPE_BITS  2
+
+/*
+ * Bit fields for BUILD_CONF format type 1 (H/W version >= 1.13)
+ * Note that format type 2 (H/W version >= 1.17) has the same layout.
+ */
+#define PKA_BC1_ALU_SZ         19
+#define PKA_BC1_ALU_SZ_BITS     2
+#define PKA_BC1_RSA_SZ         16
+#define PKA_BC1_RSA_SZ_BITS     3
+#define PKA_BC1_ECC_SZ         14
+#define PKA_BC1_ECC_SZ_BITS     2
+#define PKA_BC1_FW_ROM_SZ      11
+#define PKA_BC1_FW_ROM_SZ_BITS  3
+#define PKA_BC1_FW_RAM_SZ       8
+#define PKA_BC1_FW_RAM_SZ_BITS  3
+#define PKA_BC1_BANK_SW_D       6
+#define PKA_BC1_BANK_SW_D_BITS  2
+#define PKA_BC1_BANK_SW_C       4
+#define PKA_BC1_BANK_SW_C_BITS  2
+#define PKA_BC1_BANK_SW_B       2
+#define PKA_BC1_BANK_SW_B_BITS  2
+#define PKA_BC1_BANK_SW_A       0
+#define PKA_BC1_BANK_SW_A_BITS  2
+
+/* Enumerations for the FW_RAM and FW_ROM fields in format type 1. */
+enum {
+   PKA_BC1_FW_SZ_0,
+   PKA_BC1_FW_SZ_256,
+   PKA_BC1_FW_SZ_512,
+   PKA_BC1_FW_SZ_1024,
+   PKA_BC1_FW_SZ_2048,
+};
+
+/* Bit fields for BUILD_CONF format type 0 (H/W version <= 1.12) */
+#define PKA_BC_ALU_SZ         19
+#define PKA_BC_ALU_SZ_BITS     2
+#define PKA_BC_RSA_SZ         16
+#define PKA_BC_RSA_SZ_BITS     3
+#define PKA_BC_ECC_SZ         14
+#define PKA_BC_ECC_SZ_BITS     2
+#define PKA_BC_FW_HAS_ROM     13
+#define PKA_BC_FW_HAS_RAM     12
+#define PKA_BC_FW_ROM_SZ      10
+#define PKA_BC_FW_ROM_SZ_BITS  2
+#define PKA_BC_FW_RAM_SZ       8
+#define PKA_BC_FW_RAM_SZ_BITS  2
+#define PKA_BC_BANK_SW_D       6
+#define PKA_BC_BANK_SW_D_SZ    2
+#define PKA_BC_BANK_SW_C       4
+#define PKA_BC_BANK_SW_C_SZ    2
+#define PKA_BC_BANK_SW_B       2
+#define PKA_BC_BANK_SW_B_SZ    2
+#define PKA_BC_BANK_SW_A       0
+#define PKA_BC_BANK_SW_A_SZ    2
+
+/* Enumerations for the FW_RAM and FW_ROM fields in format type 0. */
+enum {
+   PKA_FW_SZ_256,
+   PKA_FW_SZ_512,
+   PKA_FW_SZ_1024,
+   PKA_FW_SZ_2048,
+};
+
+#define PKA_STAT_IRQ 30
+
+#define PKA_IRQ_EN_STAT 30
+
+#define PKA_FLAG_ZERO   0
+#define PKA_FLAG_MEMBIT 1
+#define PKA_FLAG_BORROW 2
+#define PKA_FLAG_CARRY  3
+#define PKA_FLAG_F0     4
+#define PKA_FLAG_F1     5
+#define PKA_FLAG_F2     6
+#define PKA_FLAG_F3     7
+
+#define PKA_CONF_BYTESWAP 26
+
+#define PKA_DTA_JUMP_PROBABILITY       0
+#define PKA_DTA_JUMP_PROBABILITY_BITS 13
+
+// from clp300_ram_fw.hex
+static const u32 PKA_FW[] = {
+    0xf8000009,
+    0xf8eb4d8a,
+    0xf8f93bc3,
+    0xf869f0f1,
+    0xf8a38aaa,
+    0xf8fe215f,
+    0xf80828f0,
+    0xf80000fc,
+    0xf80005d1,
+    0x000000ff,
+    0x2000002b,
+    0x2000002d,
+    0x2000002f,
+    0x20000031,
+    0x20000033,
+    0x20000035,
+    0x20000037,
+    0x20000039,
+    0x2000003b,
+    0x2000003d,
+    0x20000110,
+    0x20000112,
+    0x20000114,
+    0x20000116,
+    0x20000118,
+    0x200001bd,
+    0x200001bf,
+    0x200001c1,
+    0x200001c3,
+    0x200001c5,
+    0x200001c7,
+    0x200001c9,
+    0x200001cb,
+    0x200001cd,
+    0x200001cf,
+    0x20000392,
+    0x200003f7,
+    0x200003f9,
+    0x200003fb,
+    0x200003fd,
+    0x200003ff,
+    0x20000401,
+    0x20000578,
+    0x220000a4,
+    0x00000000,
+    0x22000090,
+    0x00000000,
+    0x22000099,
+    0x00000000,
+    0x2200003f,
+    0x00000000,
+    0x22000041,
+    0x00000000,
+    0x220000c1,
+    0x00000000,
+    0x220000ee,
+    0x00000000,
+    0x220000e9,
+    0x00000000,
+    0x220000e1,
+    0x00000000,
+    0xc8004400,
+    0x00000000,
+    0x48200000,
+    0x20000043,
+    0x48200000,
+    0x44000400,
+    0x40008200,
+    0x220000da,
+    0x40004400,
+    0x08c00000,
+    0x43000680,
+    0x4000c200,
+    0x23c00050,
+    0xd9004000,
+    0x33000087,
+    0x6b000000,
+    0x33600058,
+    0x41000440,
+    0x40008800,
+    0x6b008000,
+    0x33600055,
+    0x41008040,
+    0x40000c00,
+    0x2000004a,
+    0xd010c040,
+    0x41000c00,
+    0x2000004a,
+    0x6b004000,
+    0x33600065,
+    0x41004440,
+    0x40008a00,
+    0x6b00d000,
+    0x33600061,
+    0x4100d440,
+    0x40008e80,
+    0x2000004a,
+    0x4000d440,
+    0xd011c040,
+    0x41000e80,
+    0x2000004a,
+    0xd8004440,
+    0x33400076,
+    0x41008800,
+    0xd810d040,
+    0x40000c00,
+    0x3140006d,
+    0xd010c040,
+    0x40000c00,
+    0x6b008000,
+    0x33600073,
+    0x48200000,
+    0x41008040,
+    0x40000c00,
+    0x2000004a,
+    0xd010c040,
+    0x41000c00,
+    0x2000004a,
+    0xd8080440,
+    0x41008a00,
+    0xd81a8040,
+    0x40000e80,
+    0x3140007d,
+    0xd001c440,
+    0x40008e80,
+    0x6b00d000,
+    0x33600083,
+    0x48200000,
+    0x4100d440,
+    0x40008e80,
+    0x2000004a,
+    0x4000d440,
+    0xd011c040,
+    0x41000e80,
+    0x2000004a,
+    0x24000000,
+    0x3340008c,
+    0xd010c240,
+    0x40008000,
+    0x2000008f,
+    0xd010c000,
+    0x40008240,
+    0x2000008f,
+    0x24000000,
+    0x48400000,
+    0x48200000,
+    0x220000da,
+    0xd0004400,
+    0x220000c2,
+    0xd800c400,
+    0x31400094,
+    0x20000098,
+    0x24000000,
+    0x48200000,
+    0x220000da,
+    0x220000d1,
+    0x334000a0,
+    0xd8188040,
+    0x40008000,
+    0x200000a3,
+    0xd8188000,
+    0x40008040,
+    0x200000a3,
+    0x24000000,
+    0x40004680,
+    0x220000ae,
+    0x40000400,
+    0x4000d000,
+    0x40008680,
+    0x220000ae,
+    0x4000d200,
+    0x220000b2,
+    0x220000b1,
+    0x24000000,
+    0x40000200,
+    0x4000d800,
+    0x200000b2,
+    0x44000200,
+    0xc8004400,
+    0xc910ca00,
+    0xc808c000,
+    0xd0008200,
+    0xd4018a00,
+    0x40004400,
+    0x200000c2,
+    0x40000200,
+    0xca004400,
+    0xc910ca00,
+    0xc808c000,
+    0xd0008200,
+    0xd4018a00,
+    0x40004400,
+    0x200000c2,
+    0x48200000,
+    0x332000c6,
+    0xd810c040,
+    0x40008040,
+    0x200000c9,
+    0xd810c040,
+    0x40000c00,
+    0x200000c9,
+    0x40008000,
+    0xd800c400,
+    0x334000ce,
+    0x40008000,
+    0x200000d0,
+    0x40000400,
+    0x200000d0,
+    0x24000000,
+    0xd8004400,
+    0x334000d6,
+    0xd9004000,
+    0x48400000,
+    0x200000d9,
+    0xd8080400,
+    0x49400000,
+    0x200000d9,
+    0x24000000,
+    0x40000680,
+    0x40004400,
+    0x220000c2,
+    0x40000200,
+    0x48200000,
+    0x4000d400,
+    0x200000c2,
+    0x08c00000,
+    0x40008240,
+    0x43000200,
+    0xd808c400,
+    0x40004800,
+    0x22000047,
+    0x400086c0,
+    0x24000000,
+    0x08c00001,
+    0x45000000,
+    0x44000400,
+    0x22000047,
+    0x24000000,
+    0x40008680,
+    0x43000200,
+    0x43000640,
+    0x43000040,
+    0x44000000,
+    0x4100c240,
+    0x5180c000,
+    0x6a804000,
+    0x08c00000,
+    0xd0004400,
+    0xd4014c40,
+    0xd91a8800,
+    0x334000ff,
+    0x3300010b,
+    0x40008000,
+    0x40008840,
+    0x6a80c800,
+    0x08c00001,
+    0x6b004800,
+    0x33600103,
+    0x08c00000,
+    0x41004400,
+    0x41004c40,
+    0x40008200,
+    0x40008a40,
+    0x21c00109,
+    0x6d204000,
+    0x11800000,
+    0x200000f7,
+    0x51c08000,
+    0x310000ff,
+    0x6a80c800,
+    0x4000d400,
+    0x24000000,
+    0x2200011a,
+    0x00000000,
+    0x22000139,
+    0x00000000,
+    0x2200018f,
+    0x00000000,
+    0x2200014b,
+    0x00000000,
+    0x2200017d,
+    0x00000000,
+    0x220000ae,
+    0x4000da00,
+    0x400006c0,
+    0x44000000,
+    0x220000b2,
+    0x31800123,
+    0x09800000,
+    0x11800000,
+    0x20000127,
+    0x5180d000,
+    0x31000127,
+    0x44000000,
+    0x20000138,
+    0x220000b9,
+    0x6880d000,
+    0x31600130,
+    0x2000012b,
+    0x4000da00,
+    0x40000240,
+    0x220000b2,
+    0x40004840,
+    0x20000136,
+    0x26200136,
+    0x4000da00,
+    0x40000240,
+    0x220000b2,
+    0x40004800,
+    0x20000136,
+    0x28800127,
+    0x220000b1,
+    0x24000000,
+    0x44000400,
+    0x40004800,
+    0x08c00000,
+    0x22000047,
+    0x400080c0,
+    0x44000400,
+    0xd8188040,
+    0x40000e00,
+    0x4000ca00,
+    0x40004680,
+    0x4000cc00,
+    0x4000dc40,
+    0x2200014b,
+    0x44000040,
+    0xd8090e00,
+    0x40008240,
+    0x4000d400,
+    0x4000dc40,
+    0x51808800,
+    0x3100014f,
+    0xd910c000,
+    0x3340017c,
+    0x51c08800,
+    0x31000153,
+    0x51a08000,
+    0x20000155,
+    0x09e00000,
+    0x14bb8000,
+    0x5180c000,
+    0x15d60000,
+    0x09800000,
+    0x15930000,
+    0x3300015b,
+    0x31400163,
+    0x09800000,
+    0x159a0000,
+    0x43000200,
+    0x6a804000,
+    0xc808c000,
+    0x40000640,
+    0x43000600,
+    0x20000169,
+    0x43000200,
+    0x6ac04000,
+    0xc808c000,
+    0x40000600,
+    0x40000e40,
+    0x20000169,
+    0x10c00000,
+    0xd810c000,
+    0xda11c840,
+    0x33400170,
+    0x40000400,
+    0x40000c40,
+    0x2000016a,
+    0x48200000,
+    0x48c00000,
+    0x6b00c800,
+    0x31600175,
+    0x49c00000,
+    0x4100c840,
+    0x31c00178,
+    0x49200000,
+    0x4100c000,
+    0x40000e40,
+    0x40000600,
+    0x25c0016a,
+    0x24000000,
+    0xd9188000,
+    0x3140018e,
+    0x51a08000,
+    0x5180c000,
+    0x15d60000,
+    0x43000200,
+    0x6ac04000,
+    0xc808c000,
+    0x40000600,
+    0x10c00000,
+    0xd810c000,
+    0x3340018b,
+    0x40000400,
+    0x20000187,
+    0x4100c000,
+    0x40000600,
+    0x25c00187,
+    0x24000000,
+    0x40001400,
+    0x40001c40,
+    0x40005600,
+    0x2200014b,
+    0x400087c0,
+    0x40001400,
+    0x40001c40,
+    0x40005e00,
+    0x2200014b,
+    0x40008000,
+    0x40005e00,
+    0x4000f040,
+    0x40000e40,
+    0x2200011a,
+    0x40000780,
+    0x40000400,
+    0x40005600,
+    0x220000c2,
+    0x40000240,
+    0x40004880,
+    0x40005600,
+    0x4000e000,
+    0x40000640,
+    0x40009e80,
+    0x4000e800,
+    0x400006c0,
+    0x4000f800,
+    0x2200011a,
+    0x40001200,
+    0xd8004400,
+    0x22000088,
+    0x40000400,
+    0x2200017d,
+    0x40009200,
+    0xc8088000,
+    0x40000400,
+    0x40000c40,
+    0x40005600,
+    0x2200014b,
+    0xc8105800,
+    0x430007c0,
+    0xd01e0400,
+    0xd41f0c40,
+    0x40008000,
+    0x40008840,
+    0x24000000,
+    0x220001ed,
+    0x00000000,
+    0x220001d8,
+    0x00000000,
+    0x220002fd,
+    0x00000000,
+    0x220001e1,
+    0x00000000,
+    0x220001d5,
+    0x00000000,
+    0x22000226,
+    0x00000000,
+    0x220001d1,
+    0x00000000,
+    0x22000371,
+    0x00000000,
+    0x22000377,
+    0x00000000,
+    0x22000366,
+    0x00000000,
+    0x22000262,
+    0x2200037e,
+    0x22000267,
+    0x24000000,
+    0x48800000,
+    0x2200028e,
+    0x24000000,
+    0x440004c0,
+    0x22000280,
+    0x220002fd,
+    0x22000254,
+    0x22000262,
+    0x2200037e,
+    0x22000267,
+    0x22000248,
+    0x24000000,
+    0x44000480,
+    0x440004c0,
+    0x22000272,
+    0x22000280,
+    0x2200028e,
+    0x33c0038f,
+    0x22000254,
+    0x22000262,
+    0x2200037e,
+    0x22000267,
+    0x22000248,
+    0x24000000,
+    0x2200038c,
+    0x318001f3,
+    0x40003c80,
+    0x22000272,
+    0x2200035a,
+    0x200001f5,
+    0x44000480,
+    0x22000272,
+    0x48800000,
+    0x50a0f800,
+    0x11a00000,
+    0x2200024d,
+    0x23e001fb,
+    0x2000020f,
+    0x15fe8000,
+    0x21e0020f,
+    0x20000200,
+    0x22000254,
+    0x20000200,
+    0x220002fd,
+    0x22000254,
+    0x68e0f800,
+    0x20000204,
+    0x26200207,
+    0x2200028e,
+    0x20000207,
+    0x20000208,
+    0x28e001fe,
+    0x2200024d,
+    0x2000020f,
+    0x22000254,
+    0x2000020f,
+    0x2200025b,
+    0x2000020f,
+    0x220002fd,
+    0x22000254,
+    0x68a0f800,
+    0x3160021a,
+    0x20000214,
+    0x2200028e,
+    0x33c0038f,
+    0x20000217,
+    0x28a0020b,
+    0x22000254,
+    0x20000221,
+    0x2620021e,
+    0x2200028e,
+    0x2000021d,
+    0x2000021e,
+    0x28a0020d,
+    0x2200025b,
+    0x20000221,
+    0x22000262,
+    0x2200037e,
+    0x22000267,
+    0x22000248,
+    0x24000000,
+    0xd902c000,
+    0x31400245,
+    0xd90ac000,
+    0x31400245,
+    0x44000480,
+    0x4000dc00,
+    0x22000272,
+    0x40005000,
+    0x220000b9,
+    0x40000380,
+    0x40001200,
+    0x40004000,
+    0x220000b9,
+    0x40001200,
+    0x220000b2,
+    0x40000340,
+    0x40003200,
+    0x4000d800,
+    0x220000b2,
+    0x40001200,
+    0x220000b2,
+    0x400002c0,
+    0x40003a00,
+    0x4000d800,
+    0x220000b2,
+    0xd0005c00,
+    0x220000c2,
+    0xd0006c00,
+    0x220000c2,
+    0xd9007000,
+    0x20000247,
+    0x48000000,
+    0x20000247,
+    0x24000000,
+    0x40001c00,
+    0x40008080,
+    0x40005c00,
+    0x40008280,
+    0x24000000,
+    0x40001200,
+    0x400040c0,
+    0x40005000,
+    0x400002c0,
+    0x40009000,
+    0x400004c0,
+    0x24000000,
+    0x40002200,
+    0x400040c0,
+    0x40006000,
+    0x400002c0,
+    0x4000a000,
+    0x400004c0,
+    0x24000000,
+    0x40002200,
+    0x40004140,
+    0x40006000,
+    0x40000340,
+    0x4000a000,
+    0x40000540,
+    0x24000000,
+    0x40009800,
+    0x44000200,
+    0x220000b2,
+    0x400004c0,
+    0x24000000,
+    0x40001a00,
+    0x40004000,
+    0x40009a00,
+    0x220000b2,
+    0x40000200,
+    0x400040c0,
+    0x40005800,
+    0x40009a00,
+    0x220000b2,
+    0x400002c0,
+    0x24000000,
+    0x40001200,
+    0x4000d800,
+    0x220000b2,
+    0x40000200,
+    0x40004080,
+    0x40005000,
+    0x4000da00,
+    0x220000b2,
+    0x40000280,
+    0x40009000,
+    0x4000da00,
+    0x220000b2,
+    0x40000480,
+    0x24000000,
+    0x40001a00,
+    0x4000d800,
+    0x220000b2,
+    0x40000200,
+    0x400040c0,
+    0x40005800,
+    0x4000da00,
+    0x220000b2,
+    0x400002c0,
+    0x40009800,
+    0x4000da00,
+    0x220000b2,
+    0x400004c0,
+    0x24000000,
+    0x40001200,
+    0x40009800,
+    0x220000b2,
+    0x40000700,
+    0x40001a00,
+    0x40009000,
+    0x220000b2,
+    0x40000300,
+    0xd80ce400,
+    0x3100029a,
+    0x49c00000,
+    0x2000029b,
+    0x48c00000,
+    0x2000029c,
+    0x22000088,
+    0x40000500,
+    0xd00ce400,
+    0x220000c2,
+    0x40000540,
+    0x4000a000,
+    0x220000b9,
+    0x40000740,
+    0x4000a200,
+    0x220000b2,
+    0x40000780,
+    0x4000e800,
+    0x4000aa00,
+    0x220000b2,
+    0x40000340,
+    0x40005000,
+    0x40009a00,
+    0x220000b2,
+    0x40000580,
+    0x40005800,
+    0x40009200,
+    0x220000b2,
+    0x40000700,
+    0xd81cb380,
+    0x40007400,
+    0x22000088,
+    0x40000380,
+    0xd01cb000,
+    0x40000400,
+    0x220000c2,
+    0x400003c0,
+    0x40007000,
+    0x220000b9,
+    0x400005c0,
+    0x40009000,
+    0x40009a00,
+    0x220000b2,
+    0x40000700,
+    0x4000ba00,
+    0x220000b2,
+    0x40000740,
+    0xd8006c00,
+    0x22000088,
+    0x4000a200,
+    0x220000b2,
+    0x40000200,
+    0x40004100,
+    0x42006800,
+    0x40000400,
+    0x220000c2,
+    0xd00d0400,
+    0x220000c2,
+    0x40000500,
+    0x4200ec00,
+    0x220000c2,
+    0x40000200,
+    0xd8144000,
+    0x40000400,
+    0x22000088,
+    0x40000200,
+    0x40007000,
+    0x220000b2,
+    0x40000500,
+    0x40007800,
+    0x4000f200,
+    0x220000b2,
+    0xd8140740,
+    0x4000ec00,
+    0x22000088,
+    0x40000740,
+    0x6b00e800,
+    0x338002ef,
+    0x336002ea,
+    0x4000c200,
+    0xd008e840,
+    0x40000680,
+    0x48200000,
+    0x200002f5,
+    0x4000c200,
+    0xd008e800,
+    0x40000740,
+    0x48000000,
+    0x200002f5,
+    0x336002f2,
+    0x48200000,
+    0x200002f5,
+    0x4000c200,
+    0xd008e800,
+    0x40000740,
+    0x4100eb00,
+    0x4000e000,
+    0x200002f9,
+    0x40009800,
+    0x4000f200,
+    0x220000b2,
+    0x40000500,
+    0x24000000,
+    0x40009a00,
+    0x40005800,
+    0x220000b2,
+    0x42000400,
+    0x220000c2,
+    0x40000500,
+    0x33e0031b,
+    0x40001a00,
+    0x40004000,
+    0x220000b9,
+    0x40000780,
+    0x42000200,
+    0x40004400,
+    0x220000c2,
+    0xd000f400,
+    0x220000c2,
+    0x40000580,
+    0x40009800,
+    0x220000b9,
+    0x400004c0,
+    0x40003200,
+    0x4000d800,
+    0x220000b2,
+    0x40009a00,
+    0x220000b2,
+    0xd0160200,
+    0x40004400,
+    0x220000c2,
+    0x40000580,
+    0x2000032a,
+    0xd8039a00,
+    0x40004400,
+    0x22000088,
+    0x40000200,
+    0xd0039a40,
+    0x40004c00,
+    0x220000c2,
+    0x220000b2,
+    0x40000440,
+    0x40000200,
+    0x42000400,
+    0x220000c2,
+    0xd0004400,
+    0x220000c2,
+    0x40000580,
+    0x40001a00,
+    0x40005800,
+    0x220000b2,
+    0x400005c0,
+    0x4000b000,
+    0x220000b9,
+    0x40000380,
+    0x4000a000,
+    0x4000ba00,
+    0x220000b2,
+    0x400003c0,
+    0x4000a000,
+    0x220000b9,
+    0x40000700,
+    0x42007c00,
+    0x220000c2,
+    0x40000740,
+    0x42000400,
+    0x220000c2,
+    0x400003c0,
+    0x40007000,
+    0xd8007c00,
+    0x22000088,
+    0x4000a200,
+    0x220000b2,
+    0x40000400,
+    0x40008100,
+    0xd00fec00,
+    0x220000c2,
+    0xd8007400,
+    0x22000088,
+    0x4000b200,
+    0x220000b2,
+    0x400003c0,
+    0x40005800,
+    0x220000b9,
+    0x4000e200,
+    0x220000b2,
+    0x42000400,
+    0x220000c2,
+    0xd80f0400,
+    0x22000088,
+    0x40000300,
+    0x4000a000,
+    0x4000e200,
+    0x220000b2,
+    0x40000500,
+    0x24000000,
+    0x40001200,
+    0x40004000,
+    0x22000363,
+    0x40000200,
+    0x40004080,
+    0x40005000,
+    0x22000363,
+    0x40000280,
+    0x24000000,
+    0x40009200,
+    0x220000b2,
+    0x24000000,
+    0x44000000,
+    0x08800001,
+    0x6a800000,
+    0x43000200,
+    0xd8080400,
+    0x22000088,
+    0x40000200,
+    0xd9083000,
+    0x31000370,
+    0x49e00000,
+    0x24000000,
+    0x40001dc0,
+    0xd902b800,
+    0x31000376,
+    0x400055c0,
+    0xd90bb800,
+    0x24000000,
+    0x40001dc0,
+    0xd902b800,
+    0x3100037d,
+    0x40005800,
+    0xd00a0400,
+    0x220000c1,
+    0x24000000,
+    0x40009800,
+    0x44000400,
+    0x08c00000,
+    0x22000047,
+    0x40008000,
+    0x400004c0,
+    0x24000000,
+    0x44000000,
+    0xd91f0000,
+    0x3300038b,
+    0x43000000,
+    0xd91f0000,
+    0x3300038b,
+    0x24000000,
+    0x22000385,
+    0x33000390,
+    0x24000000,
+    0x00000043,
+    0x00000042,
+    0x00000041,
+    0x22000394,
+    0x00000000,
+    0x220003f1,
+    0x49800000,
+    0x22000371,
+    0x3300038f,
+    0x22000377,
+    0x3300038f,
+    0x44000480,
+    0x440004c0,
+    0x43000100,
+    0x43000300,
+    0x43000500,
+    0x22000272,
+    0x22000280,
+    0xe007fbc0,
+    0x330003a5,
+    0x2200028e,
+    0x33c0038f,
+    0x40001700,
+    0x40001f40,
+    0x40002680,
+    0x18000000,
+    0x4000e000,
+    0x40005040,
+    0x40009080,
+    0x4000e8c0,
+    0x40005900,
+    0x40009940,
+    0x40006180,
+    0x4000a1c0,
+    0x19000000,
+    0x50c03800,
+    0x50e0f800,
+    0x159b8000,
+    0x334003bf,
+    0x330003c7,
+    0x40001700,
+    0x4000e100,
+    0x40005700,
+    0x4000e300,
+    0x40009700,
+    0x4000e500,
+    0x16980000,
+    0x200003c8,
+    0x40001f00,
+    0x4000e100,
+    0x40005f00,
+    0x4000e300,
+    0x40009f00,
+    0x4000e500,
+    0x169c0000,
+    0x200003c8,
+    0x16980000,
+    0x11800000,
+    0x22000254,
+    0x220002fd,
+    0x22000254,
+    0x68803800,
+    0x336003d1,
+    0x6880f800,
+    0x336003da,
+    0x200003e7,
+    0x6880f800,
+    0x336003e1,
+    0x18000000,
+    0x40000700,
+    0x40000a80,
+    0x40001480,
+    0x19000000,
+    0x4000e080,
+    0x200003e8,
+    0x18000000,
+    0x40001f00,
+    0x40002280,
+    0x40002c80,
+    0x19000000,
+    0x4000e080,
+    0x200003e8,
+    0x4000d080,
+    0x18000000,
+    0x40003280,
+    0x40003c80,
+    0x19000000,
+    0x200003e8,
+    0x200003ea,
+    0x2200028e,
+    0x33c0038f,
+    0x288003c9,
+    0x22000254,
+    0x22000262,
+    0x2200037e,
+    0x22000267,
+    0x22000248,
+    0x24000000,
+    0x2200038c,
+    0x4000fa00,
+    0x40003fc0,
+    0x2200038c,
+    0x400047c0,
+    0x24000000,
+    0x22000403,
+    0x00000000,
+    0x2200043e,
+    0x00000000,
+    0x2200044d,
+    0x00000000,
+    0x2200045e,
+    0x00000000,
+    0x2200055b,
+    0x00000000,
+    0x22000531,
+    0x00000000,
+    0x2200038c,
+    0x31800408,
+    0x40003c80,
+    0x2200054f,
+    0x20000409,
+    0x44000480,
+    0x48800000,
+    0x50a0f800,
+    0x11a00000,
+    0x2200024d,
+    0x23e0040f,
+    0x20000423,
+    0x15fe8000,
+    0x21e00423,
+    0x20000414,
+    0x22000254,
+    0x20000414,
+    0x220004e6,
+    0x22000254,
+    0x68e0f800,
+    0x20000418,
+    0x2620041b,
+    0x22000479,
+    0x2000041b,
+    0x2000041c,
+    0x28e00412,
+    0x2200024d,
+    0x20000423,
+    0x22000254,
+    0x20000423,
+    0x2200025b,
+    0x20000423,
+    0x220004e6,
+    0x22000254,
+    0x68a0f800,
+    0x3160042e,
+    0x20000428,
+    0x22000479,
+    0x33c0038f,
+    0x2000042b,
+    0x28a0041f,
+    0x22000254,
+    0x20000435,
+    0x26200432,
+    0x22000479,
+    0x20000431,
+    0x20000432,
+    0x28a00421,
+    0x2200025b,
+    0x20000435,
+    0x44000400,
+    0x40009800,
+    0x08c00000,
+    0x22000047,
+    0x40008000,
+    0x400004c0,
+    0x22000545,
+    0x22000248,
+    0x24000000,
+    0x440004c0,
+    0x08c00000,
+    0x220004e6,
+    0x44000400,
+    0x4000a000,
+    0x22000047,
+    0x40008000,
+    0x400004c0,
+    0x40002500,
+    0x4000a0c0,
+    0x40006500,
+    0x4000a2c0,
+    0x22000545,
+    0x22000248,
+    0x24000000,
+    0x44000480,
+    0x440004c0,
+    0x08c00000,
+    0x22000479,
+    0x33c0038f,
+    0x44000400,
+    0x4000a000,
+    0x22000047,
+    0x40008000,
+    0x400004c0,
+    0x40002500,
+    0x4000a0c0,
+    0x40006500,
+    0x4000a2c0,
+    0x22000545,
+    0x22000248,
+    0x24000000,
+    0xd902c000,
+    0x31400476,
+    0xd90ac000,
+    0x31400476,
+    0x40005000,
+    0x2200052d,
+    0x40000380,
+    0x40001200,
+    0x40004000,
+    0x2200052d,
+    0x40001200,
+    0x22000531,
+    0x40000340,
+    0x40001200,
+    0x40004000,
+    0x40003200,
+    0x22000531,
+    0x40000300,
+    0xd0076c00,
+    0x220000c2,
+    0xd0006400,
+    0x220000c2,
+    0xd9007000,
+    0x20000478,
+    0x48000000,
+    0x20000478,
+    0x24000000,
+    0x40001200,
+    0x40009800,
+    0x22000531,
+    0x40000700,
+    0x40001a00,
+    0x40009000,
+    0x22000531,
+    0x40000300,
+    0xd80ce400,
+    0x31000485,
+    0x49c00000,
+    0x20000486,
+    0x48c00000,
+    0x20000487,
+    0x22000088,
+    0x40000500,
+    0xd00ce400,
+    0x220000c2,
+    0x40000580,
+    0x4000a000,
+    0x2200052d,
+    0x40000740,
+    0x4000a200,
+    0x22000531,
+    0x40000780,
+    0x4000e800,
+    0x4000b200,
+    0x22000531,
+    0x400006c0,
+    0x40005000,
+    0x40009a00,
+    0x22000531,
+    0x40000580,
+    0x40005800,
+    0x40009200,
+    0x22000531,
+    0x40000700,
+    0xd81cb380,
+    0x40007400,
+    0x22000088,
+    0x40000380,
+    0xd01cb000,
+    0x40000400,
+    0x220000c2,
+    0x400003c0,
+    0x40007000,
+    0x2200052d,
+    0x400005c0,
+    0x40009000,
+    0x40009a00,
+    0x22000531,
+    0x40000700,
+    0x4000ba00,
+    0x22000531,
+    0x40000740,
+    0xd800dc00,
+    0x22000088,
+    0x4000a200,
+    0x22000531,
+    0x40000200,
+    0x40004100,
+    0x4200d800,
+    0x40000400,
+    0x220000c2,
+    0xd01b0400,
+    0x220000c2,
+    0x40000500,
+    0x4200ec00,
+    0x220000c2,
+    0x40000200,
+    0xd8144000,
+    0x40000400,
+    0x22000088,
+    0x40000200,
+    0x40007000,
+    0x22000531,
+    0x40000500,
+    0x40007800,
+    0x4000f200,
+    0x22000531,
+    0xd8140740,
+    0x4000ec00,
+    0x22000088,
+    0x40000740,
+    0x6b00e800,
+    0x338004da,
+    0x336004d5,
+    0x4000c200,
+    0xd008e840,
+    0x40000680,
+    0x48200000,
+    0x200004e0,
+    0x4000c200,
+    0xd008e800,
+    0x40000740,
+    0x48000000,
+    0x200004e0,
+    0x336004dd,
+    0x48200000,
+    0x200004e0,
+    0x4000c200,
+    0xd008e800,
+    0x40000740,
+    0x4100eb00,
+    0x4000e000,
+    0x4000f200,
+    0x22000531,
+    0x40000500,
+    0x24000000,
+    0x40009a00,
+    0x40005800,
+    0x22000531,
+    0x42000400,
+    0x220000c2,
+    0x40000500,
+    0x40001a00,
+    0x40004000,
+    0x2200052d,
+    0x40000780,
+    0x42000400,
+    0x220000c2,
+    0xd000f400,
+    0x220000c2,
+    0x40000580,
+    0x40009800,
+    0x2200052d,
+    0x40003200,
+    0x22000531,
+    0xd0160200,
+    0x40004400,
+    0x220000c2,
+    0x40000580,
+    0x40001a00,
+    0x40005800,
+    0x22000531,
+    0x400005c0,
+    0x4000b000,
+    0x2200052d,
+    0x40000380,
+    0x4000a000,
+    0x4000ba00,
+    0x22000531,
+    0x400003c0,
+    0x4000a000,
+    0x2200052d,
+    0x40000700,
+    0x42007c00,
+    0x220000c2,
+    0x40000740,
+    0x42000400,
+    0x220000c2,
+    0x400003c0,
+    0x40007000,
+    0xd8007c00,
+    0x22000088,
+    0x4000a200,
+    0x22000531,
+    0x40000400,
+    0x40008100,
+    0xd00fec00,
+    0x220000c2,
+    0xd8007400,
+    0x22000088,
+    0x4000b200,
+    0x22000531,
+    0x400003c0,
+    0x40005800,
+    0x2200052d,
+    0x4000e200,
+    0x22000531,
+    0x42000400,
+    0x220000c2,
+    0xd80f0400,
+    0x22000088,
+    0x40000300,
+    0x4000a000,
+    0x4000e200,
+    0x22000531,
+    0x40000500,
+    0x24000000,
+    0x40000200,
+    0xca004400,
+    0x22000532,
+    0x24000000,
+    0xc8004400,
+    0x46008200,
+    0xd0088000,
+    0x43000400,
+    0x40000200,
+    0xd4088000,
+    0x24000000,
+    0x220004e6,
+    0x44000400,
+    0x4000a000,
+    0x22000047,
+    0x40008000,
+    0x400004c0,
+    0x40002500,
+    0x4000a0c0,
+    0x40006500,
+    0x4000a2c0,
+    0x22000545,
+    0x22000248,
+    0x24000000,
+    0x40001a00,
+    0x40009800,
+    0x22000531,
+    0x40000400,
+    0x400080c0,
+    0x40005800,
+    0x40009a00,
+    0x22000531,
+    0x400002c0,
+    0x24000000,
+    0x40001200,
+    0x40004000,
+    0x22000558,
+    0x40000200,
+    0x40004080,
+    0x40005000,
+    0x22000558,
+    0x40000280,
+    0x24000000,
+    0x40009200,
+    0x22000531,
+    0x24000000,
+    0x40004680,
+    0x40000200,
+    0x4000d800,
+    0x22000568,
+    0x40000400,
+    0x4000d000,
+    0x40008680,
+    0x40000200,
+    0x4000d800,
+    0x22000568,
+    0x4000d200,
+    0x22000568,
+    0x44000200,
+    0xc8004400,
+    0x46008780,
+    0x4000f440,
+    0xc910ca00,
+    0x46004780,
+    0xc808c000,
+    0x46000780,
+    0x4000f040,
+    0xd0008200,
+    0xd4018a00,
+    0x40004400,
+    0x200000c2,
+    0xc8004400,
+    0x46008200,
+    0x40004440,
+    0x24000000,
+    0x2200057a,
+    0x00000000,
+    0x220003f1,
+    0x49800000,
+    0x22000371,
+    0x3300038f,
+    0x22000377,
+    0x3300038f,
+    0x44000480,
+    0x440004c0,
+    0x43000100,
+    0x43000300,
+    0x43000500,
+    0xe007fbc0,
+    0x33000589,
+    0x22000479,
+    0x33c0038f,
+    0x40001700,
+    0x40001f40,
+    0x40002680,
+    0x18000000,
+    0x4000e000,
+    0x40005040,
+    0x40009080,
+    0x4000e8c0,
+    0x40005900,
+    0x40009940,
+    0x40006180,
+    0x4000a1c0,
+    0x19000000,
+    0x51c03800,
+    0x51e0f800,
+    0x159b8000,
+    0x334005a3,
+    0x330005ab,
+    0x40001700,
+    0x4000e100,
+    0x40005700,
+    0x4000e300,
+    0x40009700,
+    0x4000e500,
+    0x16980000,
+    0x200005ac,
+    0x40001f00,
+    0x4000e100,
+    0x40005f00,
+    0x4000e300,
+    0x40009f00,
+    0x4000e500,
+    0x169c0000,
+    0x200005ac,
+    0x16980000,
+    0x11800000,
+    0x16f00000,
+    0x22000254,
+    0x220004e6,
+    0x22000254,
+    0x68e03800,
+    0x336005b6,
+    0x68e0f800,
+    0x336005bf,
+    0x200005cc,
+    0x68e0f800,
+    0x336005c6,
+    0x18000000,
+    0x40000700,
+    0x40000a80,
+    0x40001480,
+    0x19000000,
+    0x4000e080,
+    0x200005cd,
+    0x18000000,
+    0x40001f00,
+    0x40002280,
+    0x40002c80,
+    0x19000000,
+    0x4000e080,
+    0x200005cd,
+    0x4000d080,
+    0x18000000,
+    0x40003280,
+    0x40003c80,
+    0x19000000,
+    0x200005cd,
+    0x200005cf,
+    0x22000479,
+    0x33c0038f,
+    0x28e005ae,
+    0x22000254,
+    0x44000400,
+    0x40009800,
+    0x08c00000,
+    0x22000047,
+    0x40008000,
+    0x400004c0,
+    0x22000545,
+    0x22000248,
+    0x24000000,
+};
+
+
+#endif
diff --git a/drivers/crypto/sifive-vic/vic-pka-tools.c b/drivers/crypto/sifive-vic/vic-pka-tools.c
new file mode 100644
index 000000000000..21ea9edf4136
--- /dev/null
+++ b/drivers/crypto/sifive-vic/vic-pka-tools.c
@@ -0,0 +1,366 @@
+/*
+ ******************************************************************************
+ * @file  vic-sec.c
+ * @author  StarFive Technology
+ * @version  V1.0
+ * @date  08/13/2020
+ * @brief
+ ******************************************************************************
+ * @copy
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+ * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+ * TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE FOR ANY
+ * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+ * FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+ * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ * <h2><center>&copy; COPYRIGHT 2020 Shanghai StarFive Technology Co., Ltd. </center></h2>
+ */
+
+#include <crypto/scatterwalk.h>
+
+#include "vic-sec.h"
+#include "vic-pka.h"
+#include "vic-pka-hw.h"
+
+#define MAX(a, b) (((a)>(b)) ? (a) : (b))
+
+/*
+ * Determine the base radix for the given operand size,
+ *   ceiling(lg(size/8))
+ * where size > 16 bytes.
+ * Returns 0 if the size is invalid.
+ */
+static unsigned elppka_base_radix(unsigned size)
+{
+	if (size <= 16)  return 0; /* Error */
+	if (size <= 32)  return 2;
+	if (size <= 64)  return 3;
+	if (size <= 128) return 4;
+	if (size <= 256) return 5;
+	if (size <= 512) return 6;
+
+	return 0;
+}
+
+/*
+ * Helper to compute the operand page size, which depends only on the base
+ * radix.
+ */
+static unsigned elppka_page_size(unsigned size)
+{
+	unsigned ret;
+
+	ret = elppka_base_radix(size);
+	if (!ret)
+		return ret;
+	return 8 << ret;
+}
+
+/*
+ * Check that the given PKA operand index is valid for a particular bank and
+ * operand size.  The bank and size values themselves are not validated.
+ */
+static int index_is_valid(const struct pka_config *cfg, unsigned bank,
+			  unsigned index, unsigned size)
+{
+	unsigned ecc_max_bytes, rsa_max_bytes, abc_storage, d_storage;
+
+	ecc_max_bytes = cfg->ecc_size >> 3;
+	rsa_max_bytes = cfg->rsa_size >> 3;
+
+	if (size > ecc_max_bytes && size > rsa_max_bytes)
+		return 0;
+	if (index > 7)
+		return 0;
+
+	abc_storage = MAX(ecc_max_bytes*8, rsa_max_bytes*2);
+	d_storage   = MAX(ecc_max_bytes*8, rsa_max_bytes*4);
+
+	if (bank == PKA_OPERAND_D) {
+		return index < d_storage / size;
+	} else {
+		return index < abc_storage / size;
+	}
+}
+
+/*
+ * Determine the offset (in 32-bit words) of a particular operand in the PKA
+ * memory map.
+ * Returns the (non-negative) offset on success, or -errno on failure.
+ */
+static int operand_base_offset(const struct pka_config *cfg, unsigned bank,
+			       unsigned index, unsigned size)
+{
+	unsigned pagesize;
+	int ret;
+
+	pagesize = elppka_page_size(size);
+	if (!pagesize)
+		return CRYPTO_INVALID_SIZE;
+
+	if (!index_is_valid(cfg, bank, index, pagesize))
+		return CRYPTO_NOT_FOUND;
+
+	switch (bank) {
+	case PKA_OPERAND_A:
+		ret = PKA_OPERAND_A_BASE;
+		break;
+	case PKA_OPERAND_B:
+		ret = PKA_OPERAND_B_BASE;
+		break;
+	case PKA_OPERAND_C:
+		ret = PKA_OPERAND_C_BASE;
+		break;
+	case PKA_OPERAND_D:
+		ret = PKA_OPERAND_D_BASE;
+		break;
+	default:
+		return CRYPTO_INVALID_ARGUMENT;
+	}
+
+	return ret + index * (pagesize>>2);
+}
+
+/* Parse out the fields from a type-0 BUILD_CONF register in bc. */
+static void elppka_get_config_type0(uint32_t bc, struct pka_config *out)
+{
+	struct pka_config cfg = {0};
+
+	if (bc & (1ul << PKA_BC_FW_HAS_RAM)) {
+		cfg.fw_ram_size = 256u << ((bc >> PKA_BC_FW_RAM_SZ)
+					   & ((1ul << PKA_BC_FW_RAM_SZ_BITS)-1));
+	}
+	if (bc & (1ul << PKA_BC_FW_HAS_ROM)) {
+		cfg.fw_rom_size = 256u << ((bc >> PKA_BC_FW_ROM_SZ)
+					   & ((1ul << PKA_BC_FW_ROM_SZ_BITS)-1));
+	}
+
+	cfg.alu_size = 32u << ((bc >> PKA_BC_ALU_SZ)
+			       & ((1ul << PKA_BC_ALU_SZ_BITS)-1));
+	cfg.rsa_size = 512u << ((bc >> PKA_BC_RSA_SZ)
+				& ((1ul << PKA_BC_RSA_SZ_BITS)-1));
+	cfg.ecc_size = 256u << ((bc >> PKA_BC_ECC_SZ)
+				& ((1ul << PKA_BC_ECC_SZ_BITS)-1));
+
+	*out = cfg;
+}
+
+/* Parse out the fields from a type-1 BUILD_CONF register in bc. */
+static void elppka_get_config_type1(uint32_t bc, struct pka_config *out)
+{
+	struct pka_config cfg = {0};
+	uint32_t tmp;
+
+	tmp = (bc >> PKA_BC1_FW_RAM_SZ) & ((1ul << PKA_BC1_FW_RAM_SZ_BITS)-1);
+	if (tmp)
+		cfg.fw_ram_size = 256u << (tmp-1);
+
+	tmp = (bc >> PKA_BC1_FW_ROM_SZ) & ((1ul << PKA_BC1_FW_ROM_SZ_BITS)-1);
+	if (tmp)
+		cfg.fw_rom_size = 256u << (tmp-1);
+
+	tmp = (bc >> PKA_BC1_RSA_SZ) & ((1ul << PKA_BC1_RSA_SZ_BITS)-1);
+	if (tmp)
+		cfg.rsa_size = 512u << (tmp-1);
+
+	tmp = (bc >> PKA_BC1_ECC_SZ) & ((1ul << PKA_BC1_ECC_SZ_BITS)-1);
+	if (tmp)
+		cfg.ecc_size = 256u << (tmp-1);
+
+	tmp = (bc >> PKA_BC1_ALU_SZ) & ((1ul << PKA_BC1_ALU_SZ_BITS)-1);
+	cfg.alu_size = 32u << tmp;
+
+	*out = cfg;
+}
+
+/* Read out PKA H/W configuration into config structure. */
+static int elppka_get_config(uint32_t *regs, struct pka_config *out)
+{
+	uint32_t bc = vic_pka_io_read32(&regs[PKA_BUILD_CONF]);
+
+	unsigned type = bc >> PKA_BC_FORMAT_TYPE;
+	type &= (1ul << PKA_BC_FORMAT_TYPE_BITS) - 1;
+
+	switch (type) {
+	case 0:
+		elppka_get_config_type0(bc, out);
+		break;
+	case 1:
+	case 2: /* Type 2 has same format as type 1 */
+		elppka_get_config_type1(bc, out);
+		break;
+	}
+
+	/* RAM/ROM base addresses depend on core version */
+	if (type < 2) {
+		out->ram_offset = PKA_FIRMWARE_BASE;
+		out->rom_offset = PKA_FIRMWARE_BASE + out->fw_ram_size;
+	} else {
+		out->ram_offset = out->rom_offset = PKA_FIRMWARE_T2_BASE;
+		if (out->fw_ram_size)
+			out->rom_offset = PKA_FIRMWARE_T2_SPLIT;
+	}
+
+	return 0;
+}
+
+int elppka_start(struct pka_state *pka, uint32_t entry, uint32_t flags,
+		 unsigned size)
+{
+	uint32_t ctrl, base;
+
+	base = elppka_base_radix(size);
+	if (!base)
+		return CRYPTO_INVALID_SIZE;
+
+	ctrl = base << PKA_CTRL_BASE_RADIX;
+
+	/* Handle ECC-521 oddities as a special case. */
+	if (size == PKA_ECC521_OPERAND_SIZE) {
+		flags |= 1ul << PKA_FLAG_F1;
+		ctrl  |= PKA_CTRL_M521_ECC521 << PKA_CTRL_M521_MODE;
+
+		/* Round up partial radix to multiple of ALU size. */
+		size = (512 + pka->cfg.alu_size)/8;
+	}
+
+	ctrl |= (size & (size-1) ? (size+3)/4 : 0) << PKA_CTRL_PARTIAL_RADIX;
+	ctrl |= 1ul << PKA_CTRL_GO;
+
+	vic_pka_io_write32(&pka->regbase[PKA_INDEX_I], 0);
+	vic_pka_io_write32(&pka->regbase[PKA_INDEX_J], 0);
+	vic_pka_io_write32(&pka->regbase[PKA_INDEX_K], 0);
+	vic_pka_io_write32(&pka->regbase[PKA_INDEX_L], 0);
+
+	vic_pka_io_write32(&pka->regbase[PKA_F_STACK], 0);
+	vic_pka_io_write32(&pka->regbase[PKA_FLAGS], flags);
+	vic_pka_io_write32(&pka->regbase[PKA_ENTRY], entry);
+	vic_pka_io_write32(&pka->regbase[PKA_CTRL],  ctrl);
+
+	vic_pka_io_write32(&pka->regbase[PKA_IRQ_EN], 1 << PKA_IRQ_EN_STAT);
+	pka->pka_done = 0;
+	pka->pka_err = 0;
+
+	return 0;
+}
+
+void elppka_abort(struct pka_state *pka)
+{
+	vic_pka_io_write32(&pka->regbase[PKA_CTRL], 1 << PKA_CTRL_STOP_RQST);
+}
+
+int elppka_get_status(struct pka_state *pka, unsigned *code)
+{
+	uint32_t status = vic_pka_io_read32(&pka->regbase[PKA_RC]);
+
+	if (status & (1 << PKA_RC_BUSY)) {
+		return CRYPTO_INPROGRESS;
+	}
+
+	if (code) {
+		*code = (status >> PKA_RC_REASON) & ((1 << PKA_RC_REASON_BITS)-1);
+	}
+
+	return 0;
+}
+
+int elppka_load_operand(struct pka_state *pka, unsigned bank, unsigned index,
+			unsigned size, const uint8_t *data)
+{
+	uint32_t *opbase, tmp;
+	unsigned i, n;
+	int rc;
+
+	rc = operand_base_offset(&pka->cfg, bank, index, size);
+	if (rc < 0)
+		return rc;
+
+	opbase = pka->regbase + rc;
+	n = size >> 2;
+
+	for (i = 0; i < n; i++) {
+		/*
+		 * For lengths that are not a multiple of 4, the incomplete word is
+		 * at the _start_ of the data buffer, so we must add the remainder.
+		 */
+		memcpy(&tmp, data+((n-i-1)<<2)+(size&3), 4);
+		vic_pka_io_write32(&opbase[i], tmp);
+	}
+
+	/* Write the incomplete word, if any. */
+	if (size & 3) {
+		tmp = 0;
+		memcpy((char *)&tmp + sizeof tmp - (size&3), data, size & 3);
+		vic_pka_io_write32(&opbase[i++], tmp);
+	}
+
+	/* Zero the remainder of the operand. */
+	for (n = elppka_page_size(size) >> 2; i < n; i++) {
+		vic_pka_io_write32(&opbase[i], 0);
+	}
+
+	return 0;
+}
+
+int elppka_unload_operand(struct pka_state *pka, unsigned bank, unsigned index,
+			  unsigned size, uint8_t *data)
+{
+	uint32_t *opbase, tmp;
+	unsigned i, n;
+	int rc;
+
+	rc = operand_base_offset(&pka->cfg, bank, index, size);
+	if (rc < 0)
+		return rc;
+
+	opbase = pka->regbase + rc;
+	n = size >> 2;
+
+	for (i = 0; i < n; i++) {
+		tmp = vic_pka_io_read32(&opbase[i]);
+		memcpy(data+((n-i-1)<<2)+(size&3), &tmp, 4);
+	}
+
+	if (size & 3) {
+		tmp = vic_pka_io_read32(&opbase[i]);
+		memcpy(data, (char *)&tmp + sizeof tmp - (size&3), size & 3);
+	}
+
+	return 0;
+}
+
+void elppka_set_byteswap(struct pka_state *pka, int swap)
+{
+	uint32_t val = vic_pka_io_read32(&pka->regbase[PKA_CONF]);
+
+	if (swap) {
+		val |= 1 << PKA_CONF_BYTESWAP;
+	} else {
+		val &= ~(1 << PKA_CONF_BYTESWAP);
+	}
+
+	vic_pka_io_write32(&pka->regbase[PKA_CONF], val);
+}
+
+int elppka_setup(struct pka_state *pka)
+{
+	const unsigned char big[4]    = { 0x00, 0x11, 0x22, 0x33 };
+	const unsigned char little[4] = { 0x33, 0x22, 0x11, 0x00 };
+	uint32_t testval = 0x00112233;
+	int rc;
+
+	rc = elppka_get_config(pka->regbase, &pka->cfg);
+	if (rc < 0)
+		return rc;
+
+	/* Try to automatically determine byteswap setting */
+	if (!memcmp(&testval, big, sizeof testval)) {
+		elppka_set_byteswap(pka, 0);
+	} else if (!memcmp(&testval, little, sizeof testval)) {
+		elppka_set_byteswap(pka, 1);
+	}
+
+	return 0;
+}
diff --git a/drivers/crypto/sifive-vic/vic-pka.c b/drivers/crypto/sifive-vic/vic-pka.c
new file mode 100644
index 000000000000..66c13a31b413
--- /dev/null
+++ b/drivers/crypto/sifive-vic/vic-pka.c
@@ -0,0 +1,1316 @@
+/*
+ ******************************************************************************
+ * @file  vic-pka.c
+ * @author  StarFive Technology
+ * @version  V1.0
+ * @date  08/13/2020
+ * @brief
+ ******************************************************************************
+ * @copy
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+ * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+ * TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE FOR ANY
+ * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+ * FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+ * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ * <h2><center>&copy; COPYRIGHT 2020 Shanghai StarFive Technology Co., Ltd. </center></h2>
+ */
+#include <linux/mod_devicetable.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/crypto.h>
+#include <linux/io.h>
+
+#include <crypto/scatterwalk.h>
+
+#include "vic-sec.h"
+#include "vic-pka-hw.h"
+
+#define ERROR(fmt, ...)  printk("ERROR %s() ln %d:" fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__)
+
+static int pka_wait(struct vic_sec_dev *sdev)
+{
+	struct pka_state *pka = &sdev->pka;
+	int ret = -1;
+	mutex_lock(&sdev->doing);
+	if(pka->pka_done || pka->pka_err)
+		ret = 0;
+	mutex_unlock(&sdev->doing);
+	return ret;
+	//return wait_cond_timeout(pka->pka_done || pka->pka_err, 10, 40000000);
+}
+
+#define PKA_LOAD(pka, bank, index, size, para)				\
+	if (para) {							\
+		rc = elppka_load_operand(pka, bank, index, size, para); \
+		if (rc) {						\
+			ERROR("failed to load a param\r\n");		\
+			return -EIO;					\
+		}							\
+	}
+
+#define PKA_UNLOAD(pka, bank, index, size, para)			\
+	if (para) {							\
+		rc = elppka_unload_operand(pka, bank, index, size, para); \
+		if (rc) {						\
+			ERROR("failed to unload a param\r\n");		\
+			return -EIO;					\
+		}							\
+	}
+
+#define PKA_RUN(sdev, pka, func, flags, size)				\
+	do {								\
+		mutex_lock(&sdev->doing);				\
+		elppka_start(pka, func, flags, size);			\
+		rc = pka_wait(sdev);					\
+		if (rc) {						\
+			ERROR("failed\r\n");				\
+			return rc;					\
+		}							\
+	} while (0)
+
+
+
+/**
+   Base Modular Arithmetic Library Functions
+
+   The Base Modular Arithmetic library suite provides a set of modular arithmetic operations commonly used by
+   cryptographic applications. These include Montgomery precomputation operations and other generic modular
+   operations.
+**/
+
+static int vic_rsa_calc_rinv(struct vic_sec_ctx *ctx, u32 size,
+			     const u8 *m,
+			     u8 *rinv) // C0
+{
+	struct vic_sec_dev *sdev = ctx->sdev;
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_RUN(sdev, pka, PKA_CALC_R_INV, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_C, 0, size, rinv);
+	return rc;
+}
+
+static int vic_rsa_calc_mp(struct vic_sec_ctx *ctx, u32 size,
+			   const u8 *rinv, // C0
+			   const u8 *m, // D0
+			   u8 *mp) // D1
+{
+	struct vic_sec_dev *sdev = ctx->sdev;
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_D, 2, size, rinv);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_RUN(sdev, pka, PKA_CALC_MP, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_D, 1, size, mp);
+	return rc;
+}
+
+static int vic_rsa_calc_rsqr(struct vic_sec_ctx *ctx, u32 size,
+			     const u8 *rinv, // C0
+			     const u8 *m, // D0
+			     const u8 *mp, // D1
+			     u8 *rsqr) // D3
+{
+	struct vic_sec_dev *sdev = ctx->sdev;
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_C, 0, size, rinv);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_LOAD(pka, PKA_OPERAND_D, 1, size, mp);
+	PKA_RUN(sdev, pka, PKA_CALC_R_SQR, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_D, 3, size, rsqr);
+	return rc;
+}
+
+
+static int vic_rsa_calc_modexp(struct vic_sec_ctx *ctx, const u8 *src, // A0
+			       u32 full_width, // F0
+			       u8 *dst,
+			       int enc) // A0
+{
+	struct vic_sec_dev *sdev = ctx->sdev;
+	struct pka_state *pka = &ctx->sdev->pka;
+	struct vic_rsa_key *rsa_key = &ctx->rsa_key;
+	size_t size = rsa_key->key_sz;
+	int rc;
+
+	PKA_LOAD(pka, PKA_OPERAND_A, 0, size, src);
+	if(enc) {
+		PKA_LOAD(pka, PKA_OPERAND_D, 2, size, rsa_key->e);
+	} else {
+		PKA_LOAD(pka, PKA_OPERAND_D, 2, size, rsa_key->d);
+	}
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, rsa_key->n);
+	PKA_LOAD(pka, PKA_OPERAND_D, 1, size, rsa_key->mp);
+	PKA_LOAD(pka, PKA_OPERAND_D, 3, size, rsa_key->rsqr);
+	PKA_RUN(sdev, pka, PKA_MODEXP, (full_width&0x1)<<PKA_FLAG_F0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 0, size, dst);
+	return rc;
+}
+
+static int vic_rsa_crt(struct vic_sec_ctx *ctx, u32 size,
+		       const u8 *msg_lo, // A2
+		       const u8 *msg_hi, // A3
+		       u32 full_width, // F0
+		       u8 *c_lo, // A0
+		       u8 *c_hi) // A1
+{
+	struct vic_sec_dev *sdev = ctx->sdev;
+	struct pka_state *pka = &ctx->sdev->pka;
+	struct vic_rsa_key *rsa_key = &ctx->rsa_key;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 2, size, msg_lo);
+	PKA_LOAD(pka, PKA_OPERAND_A, 3, size, msg_hi);
+	PKA_LOAD(pka, PKA_OPERAND_B, 2, size, rsa_key->p);
+	PKA_LOAD(pka, PKA_OPERAND_B, 3, size, rsa_key->q);
+	PKA_LOAD(pka, PKA_OPERAND_C, 2, size, rsa_key->qinv);
+	PKA_LOAD(pka, PKA_OPERAND_C, 3, size, rsa_key->dp);
+	PKA_LOAD(pka, PKA_OPERAND_D, 2, size, rsa_key->dq);
+	PKA_LOAD(pka, PKA_OPERAND_D, 5, size, rsa_key->rsqr_p);
+	PKA_LOAD(pka, PKA_OPERAND_D, 4, size, rsa_key->pmp);
+	PKA_LOAD(pka, PKA_OPERAND_D, 3, size, rsa_key->rsqr_q);
+	PKA_LOAD(pka, PKA_OPERAND_D, 6, size, rsa_key->qmp);
+	PKA_RUN(sdev, pka, PKA_CRT, (full_width&0x1)<<PKA_FLAG_F0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 0, size, c_lo);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 1, size, c_hi);
+	return rc;
+}
+#if 0
+static int pka_modmult(struct vic_sec_ctx *ctx, u32 size,
+		       const u8 *x, // A0
+		       const u8 *y, // B0
+		       const u8 *m, // D0
+		       const u8 *mp, // D1
+		       const u8 *r_sqr, // D3
+		       u8 *c) // A0
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 0, size, x);
+	PKA_LOAD(pka, PKA_OPERAND_B, 0, size, y);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_LOAD(pka, PKA_OPERAND_D, 1, size, mp);
+	PKA_LOAD(pka, PKA_OPERAND_D, 3, size, r_sqr);
+	PKA_RUN(pka, PKA_MODMULT, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 0, size, c);
+	return rc;
+}
+
+static int pka_modadd(struct vic_sec_ctx *ctx, u32 size,
+		      const u8 *x, // A0
+		      const u8 *y, // B0
+		      const u8 *m, // D0
+		      u8 *c) // A0
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 0, size, x);
+	PKA_LOAD(pka, PKA_OPERAND_B, 0, size, y);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_RUN(pka, PKA_MODADD, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 0, size, c);
+	return rc;
+}
+
+static int pka_modsub(struct vic_sec_ctx *ctx, u32 size,
+		      const u8 *x, // A0
+		      const u8 *y, // B0
+		      const u8 *m, // D0
+		      u8 *c) // A0
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 0, size, x);
+	PKA_LOAD(pka, PKA_OPERAND_B, 0, size, y);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_RUN(pka, PKA_MODSUB, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 0, size, c);
+	return rc;
+}
+
+static int pka_reduce(struct vic_sec_ctx *ctx, u32 size,
+		      const u8 *x, // C0
+		      const u8 *m, // D0
+		      u8 *c) // A0
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_C, 0, size, x);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_RUN(pka, PKA_REDUCE, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 0, size, c);
+	return rc;
+}
+
+static int pka_moddiv(struct vic_sec_ctx *ctx, u32 size,
+		      const u8 *y, // C0
+		      const u8 *x, // A0
+		      const u8 *m, // D0
+		      u8 *c) // C0
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_C, 0, size, y);
+	PKA_LOAD(pka, PKA_OPERAND_A, 0, size, x);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_RUN(pka, PKA_MODDIV, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_C, 0, size, c);
+	return rc;
+}
+
+static int pka_modinv(struct vic_sec_ctx *ctx, u32 size,
+		      const u8 *x, // A0
+		      const u8 *m, // D0
+		      u8 *c) // C0
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 0, size, x);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_RUN(pka, PKA_MODINV, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_C, 0, size, c);
+	return rc;
+}
+
+static int pka_mult(struct vic_sec_ctx *ctx, u32 size,
+		    const u8 *a, // A0
+		    const u8 *b, // B0
+		    u8 *c_lo, // C0
+		    u8 *c_hi) // C1
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 0, size, a);
+	PKA_LOAD(pka, PKA_OPERAND_B, 0, size, b);
+	PKA_RUN(pka, PKA_MULT, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_C, 0, size, c_lo);
+	PKA_UNLOAD(pka, PKA_OPERAND_C, 1, size, c_hi);
+	return rc;
+}
+
+static int vic_rsa_crt_key_setup(struct vic_sec_ctx *ctx) // A3
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	struct vic_rsa_key *rsa_key = &ctx->rsa_key;
+	size_t size = rsa_key->key_sz >> 1;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, rsa_key->p);
+	PKA_LOAD(pka, PKA_OPERAND_B, 1, size, rsa_key->q);
+	PKA_LOAD(pka, PKA_OPERAND_D, 1, size, rsa_key->d + size);
+	PKA_LOAD(pka, PKA_OPERAND_D, 3, size, rsa_key->d);
+	PKA_RUN(pka, PKA_CRT_KEY_SETUP, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_B, 1, size, rsa_key->dp);
+	PKA_UNLOAD(pka, PKA_OPERAND_C, 0, size, rsa_key->dq);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 3, size, rsa_key->qinv);
+	return rc;
+}
+
+static int pka_rsa_bit_serial_mod(struct vic_sec_ctx *ctx, u32 size,
+				  const u8 *x, // C0
+				  const u8 *m, // D0
+				  u8 *c) // C0
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_C, 0, size, x);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_RUN(pka, PKA_BIT_SERIAL_MOD, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_C, 0, size, c);
+	return rc;
+}
+
+static int pka_rsa_bit_serial_mod_dp(struct vic_sec_ctx *ctx, u32 size,
+				     const u8 *x_lo, // C0
+				     const u8 *x_hi, // C1
+				     const u8 *m, // D0
+				     u8 *c) // C0
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_C, 0, size, x_lo);
+	PKA_LOAD(pka, PKA_OPERAND_C, 1, size, x_hi);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_RUN(pka, PKA_BIT_SERIAL_MOD_DP, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_C, 0, size, c);
+	return rc;
+}
+
+
+static int pka_ecc_pmult(struct vic_sec_ctx *ctx, u32 size,
+			 const u8 *px, // A2
+			 const u8 *py, // B2
+			 const u8 *a, // A6
+			 const u8 *k, // D7
+			 const u8 *w, // A7
+			 const u8 *p, // D0
+			 const u8 *pp, // D1
+			 const u8 *r_sqr_p, // D3
+			 u32 blinding, // F0
+			 u32 is_a_m3, // F3
+			 u8 *qx, // A2
+			 u8 *qy) // B2
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	u32 flags;
+
+	PKA_LOAD(pka, PKA_OPERAND_A, 2, size, px);
+	PKA_LOAD(pka, PKA_OPERAND_B, 2, size, py);
+	PKA_LOAD(pka, PKA_OPERAND_A, 6, size, a);
+	PKA_LOAD(pka, PKA_OPERAND_D, 7, size, k);
+	PKA_LOAD(pka, PKA_OPERAND_A, 7, size, w);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, p);
+	PKA_LOAD(pka, PKA_OPERAND_D, 1, size, pp);
+	PKA_LOAD(pka, PKA_OPERAND_D, 3, size, r_sqr_p);
+	flags = ((blinding&0x1)<<PKA_FLAG_F0) |
+		((is_a_m3&0x1)<<PKA_FLAG_F3);
+	PKA_RUN(pka, PKA_PMULT, flags, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 2, size, qx);
+	PKA_UNLOAD(pka, PKA_OPERAND_B, 2, size, qy);
+	return rc;
+}
+
+static int pka_ecc_padd(struct vic_sec_ctx *ctx, u32 size,
+			const u8 *px, // A2
+			const u8 *py, // B2
+			const u8 *qx, // A3
+			const u8 *qy, // B3
+			const u8 *a, // A6
+			const u8 *p, // D0
+			const u8 *pp, // D1
+			const u8 *r_sqr_p, // D3
+			u8 *rx, // A2
+			u8 *ry) // B2
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 2, size, px);
+	PKA_LOAD(pka, PKA_OPERAND_B, 2, size, py);
+	PKA_LOAD(pka, PKA_OPERAND_A, 3, size, qx);
+	PKA_LOAD(pka, PKA_OPERAND_B, 3, size, qy);
+	PKA_LOAD(pka, PKA_OPERAND_A, 6, size, a);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, p);
+	PKA_LOAD(pka, PKA_OPERAND_D, 1, size, pp);
+	PKA_LOAD(pka, PKA_OPERAND_D, 3, size, r_sqr_p);
+	PKA_RUN(pka, PKA_PADD, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 2, size, rx);
+	PKA_UNLOAD(pka, PKA_OPERAND_B, 2, size, ry);
+	return rc;
+}
+
+static int pka_ecc_pdbl(struct vic_sec_ctx *ctx, u32 size,
+			const u8 *px, // A3
+			const u8 *py, // B3
+			const u8 *a, // A6
+			const u8 *p, // D0
+			const u8 *pp, // D1
+			const u8 *r_sqr_p, // D3
+			u8 *qx, // A2
+			u8 *qy) // B2
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 3, size, px);
+	PKA_LOAD(pka, PKA_OPERAND_B, 3, size, py);
+	PKA_LOAD(pka, PKA_OPERAND_A, 6, size, a);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, p);
+	PKA_LOAD(pka, PKA_OPERAND_D, 1, size, pp);
+	PKA_LOAD(pka, PKA_OPERAND_D, 3, size, r_sqr_p);
+	PKA_RUN(pka, PKA_PDBL, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 2, size, qx);
+	PKA_UNLOAD(pka, PKA_OPERAND_B, 2, size, qy);
+	return rc;
+}
+
+static int pka_ecc_pver(struct vic_sec_ctx *ctx, u32 size,
+			const u8 *px, // A2
+			const u8 *py, // B2
+			const u8 *a, // A6
+			const u8 *b, // A7
+			const u8 *p, // D0
+			const u8 *pp, // D1
+			const u8 *r_sqr_p, // D3
+			u32 *ok) // Z
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 2, size, px);
+	PKA_LOAD(pka, PKA_OPERAND_B, 2, size, py);
+	PKA_LOAD(pka, PKA_OPERAND_A, 6, size, a);
+	PKA_LOAD(pka, PKA_OPERAND_A, 7, size, b);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, p);
+	PKA_LOAD(pka, PKA_OPERAND_D, 1, size, pp);
+	PKA_LOAD(pka, PKA_OPERAND_D, 3, size, r_sqr_p);
+	PKA_RUN(pka, PKA_PVER, 0, size);
+	if (ok) {
+		u32 flags = vic_pka_io_read32((void *)&pka->regbase[PKA_FLAGS]);
+		*ok = (flags>>PKA_FLAG_ZERO)&0x1;
+	}
+	return rc;
+}
+
+static int pka_ecc_shamir(struct vic_sec_ctx *ctx, u32 size,
+			  const u8 *px, // A2
+			  const u8 *py, // B2
+			  const u8 *qx, // A3
+			  const u8 *qy, // B3
+			  const u8 *a, // A6
+			  const u8 *k, // A7
+			  const u8 *l, // D7
+			  const u8 *p, // D0
+			  const u8 *pp, // D1
+			  const u8 *r_sqr_p, // D3
+			  u32 is_a_m3, // F3
+			  u8 *rx, // A2
+			  u8 *ry) // B2
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 2, size, px);
+	PKA_LOAD(pka, PKA_OPERAND_B, 2, size, py);
+	PKA_LOAD(pka, PKA_OPERAND_A, 3, size, qx);
+	PKA_LOAD(pka, PKA_OPERAND_B, 3, size, qy);
+	PKA_LOAD(pka, PKA_OPERAND_A, 6, size, a);
+	PKA_LOAD(pka, PKA_OPERAND_A, 7, size, k);
+	PKA_LOAD(pka, PKA_OPERAND_D, 7, size, l);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, p);
+	PKA_LOAD(pka, PKA_OPERAND_D, 1, size, pp);
+	PKA_LOAD(pka, PKA_OPERAND_D, 3, size, r_sqr_p);
+	PKA_RUN(pka, PKA_SHAMIR, (is_a_m3&0x1)<<PKA_FLAG_F3, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 2, size, rx);
+	PKA_UNLOAD(pka, PKA_OPERAND_B, 2, size, ry);
+	return rc;
+}
+
+
+static int pka_ecc_pmult_521(struct vic_sec_ctx *ctx, u32 size,
+			     const u8 *px, // A2
+			     const u8 *py, // B2
+			     const u8 *a, // A6
+			     const u8 *k, // D7
+			     const u8 *w, // A7
+			     const u8 *p, // D0
+			     u32 blinding, // F0
+			     u8 *qx, // A2
+			     u8 *qy) // B2
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+
+	PKA_LOAD(pka, PKA_OPERAND_A, 2, size, px);
+	PKA_LOAD(pka, PKA_OPERAND_B, 2, size, py);
+	PKA_LOAD(pka, PKA_OPERAND_A, 6, size, a);
+	PKA_LOAD(pka, PKA_OPERAND_D, 7, size, k);
+	PKA_LOAD(pka, PKA_OPERAND_A, 7, size, w);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, p);
+	PKA_RUN(pka, PKA_PMULT_521, (blinding&0x1)<<PKA_FLAG_F0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 2, size, qx);
+	PKA_UNLOAD(pka, PKA_OPERAND_B, 2, size, qy);
+	return rc;
+}
+
+static int pka_ecc_padd_521(struct vic_sec_ctx *ctx, u32 size,
+			    const u8 *px, // A2
+			    const u8 *py, // B2
+			    const u8 *qx, // A3
+			    const u8 *qy, // B3
+			    const u8 *p, // D0
+			    u8 *rx, // A2
+			    u8 *ry) // B2
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 2, size, px);
+	PKA_LOAD(pka, PKA_OPERAND_B, 2, size, py);
+	PKA_LOAD(pka, PKA_OPERAND_A, 3, size, qx);
+	PKA_LOAD(pka, PKA_OPERAND_B, 3, size, qy);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, p);
+	PKA_RUN(pka, PKA_PADD_521, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 2, size, rx);
+	PKA_UNLOAD(pka, PKA_OPERAND_B, 2, size, ry);
+	return rc;
+}
+
+static int pka_ecc_pdbl_521(struct vic_sec_ctx *ctx, u32 size,
+			    const u8 *px, // A3
+			    const u8 *py, // B3
+			    const u8 *a, // A6
+			    const u8 *p, // D0
+			    const u8 *pp, // D1
+			    const u8 *r_sqr_p, // D3
+			    u8 *qx, // A2
+			    u8 *qy) // B2
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 3, size, px);
+	PKA_LOAD(pka, PKA_OPERAND_B, 3, size, py);
+	PKA_LOAD(pka, PKA_OPERAND_A, 6, size, a);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, p);
+	PKA_LOAD(pka, PKA_OPERAND_D, 1, size, pp);
+	PKA_LOAD(pka, PKA_OPERAND_D, 3, size, r_sqr_p);
+	PKA_RUN(pka, PKA_PDBL_521, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 2, size, qx);
+	PKA_UNLOAD(pka, PKA_OPERAND_B, 2, size, qy);
+	return rc;
+}
+
+static int pka_ecc_pver_521(struct vic_sec_ctx *ctx, u32 size,
+			    const u8 *px, // A2
+			    const u8 *py, // B2
+			    const u8 *a, // A6
+			    const u8 *b, // A7
+			    const u8 *p, // D0
+			    u32 *ok) // Z
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 2, size, px);
+	PKA_LOAD(pka, PKA_OPERAND_B, 2, size, py);
+	PKA_LOAD(pka, PKA_OPERAND_A, 6, size, a);
+	PKA_LOAD(pka, PKA_OPERAND_A, 7, size, b);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, p);
+	PKA_RUN(pka, PKA_PVER_521, 0, size);
+	if (ok) {
+		u32 flags = vic_pka_io_read32((void *)&pka->regbase[PKA_FLAGS]);
+		*ok = (flags>>PKA_FLAG_ZERO)&0x1;
+	}
+	return rc;
+}
+
+static int pka_ecc_modmult_521(struct vic_sec_ctx *ctx, u32 size,
+			       const u8 *x, // A0
+			       const u8 *y, // B0
+			       const u8 *m, // D0
+			       u8 *c) // A0
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 0, size, x);
+	PKA_LOAD(pka, PKA_OPERAND_B, 0, size, y);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_RUN(pka, PKA_MODMULT_521, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 0, size, c);
+	return rc;
+}
+
+static int pka_ecc_m_521_montmult(struct vic_sec_ctx *ctx, u32 size,
+				  const u8 *x, // A0
+				  const u8 *y, // B0
+				  const u8 *m, // D0
+				  const u8 *mp, // D1
+				  const u8 *r_sqr, // D3
+				  u8 *c) // A0
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 0, size, x);
+	PKA_LOAD(pka, PKA_OPERAND_B, 0, size, y);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, m);
+	PKA_LOAD(pka, PKA_OPERAND_D, 1, size, mp);
+	PKA_LOAD(pka, PKA_OPERAND_D, 3, size, r_sqr);
+	PKA_RUN(pka, PKA_M_521_MONTMULT, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 0, size, c);
+	return rc;
+}
+
+static int pka_ecc_shamir_521(struct vic_sec_ctx *ctx, u32 size,
+			      const u8 *px, // A2
+			      const u8 *py, // B2
+			      const u8 *qx, // A3
+			      const u8 *qy, // B3
+			      const u8 *a, // A6
+			      const u8 *k, // A7
+			      const u8 *l, // D7
+			      const u8 *p, // D0
+			      u8 *rx, // A2
+			      u8 *ry) // B2
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	int rc;
+	PKA_LOAD(pka, PKA_OPERAND_A, 2, size, px);
+	PKA_LOAD(pka, PKA_OPERAND_B, 2, size, py);
+	PKA_LOAD(pka, PKA_OPERAND_A, 3, size, qx);
+	PKA_LOAD(pka, PKA_OPERAND_B, 3, size, qy);
+	PKA_LOAD(pka, PKA_OPERAND_A, 6, size, a);
+	PKA_LOAD(pka, PKA_OPERAND_A, 7, size, k);
+	PKA_LOAD(pka, PKA_OPERAND_D, 7, size, l);
+	PKA_LOAD(pka, PKA_OPERAND_D, 0, size, p);
+	PKA_RUN(pka, PKA_SHAMIR_521, 0, size);
+	PKA_UNLOAD(pka, PKA_OPERAND_A, 2, size, rx);
+	PKA_UNLOAD(pka, PKA_OPERAND_B, 2, size, ry);
+	return rc;
+}
+
+static void pka_clear_state(struct vic_sec_ctx *ctx)
+{
+	struct pka_state *pka = &ctx->sdev->pka;
+	pka->pka_done = 0;
+	pka->pka_err = 0;
+}
+#endif
+static void vic_rsa_free_key(struct vic_rsa_key *key)
+{
+	if(key->d)
+		kfree_sensitive(key->d);
+	if(key->p)
+		kfree_sensitive(key->p);
+	if(key->q)
+		kfree_sensitive(key->q);
+	if(key->dp)
+		kfree_sensitive(key->dp);
+	if(key->dq)
+		kfree_sensitive(key->dq);
+	if(key->qinv)
+		kfree_sensitive(key->qinv);
+	if(key->rinv)
+		kfree_sensitive(key->rinv);
+	if(key->rinv_p)
+		kfree_sensitive(key->rinv_p);
+	if(key->rinv_q)
+		kfree_sensitive(key->rinv_q);
+	if(key->mp)
+		kfree_sensitive(key->mp);
+	if(key->rsqr)
+		kfree_sensitive(key->rsqr);
+	if(key->rsqr_p)
+		kfree_sensitive(key->rsqr_p);
+	if(key->rsqr_q)
+		kfree_sensitive(key->rsqr_q);
+	if(key->pmp)
+		kfree_sensitive(key->pmp);
+	if(key->qmp)
+		kfree_sensitive(key->qmp);
+	if(key->e)
+		kfree(key->e);
+	if(key->n)
+		kfree(key->n);
+	memset(key, 0, sizeof(*key));
+}
+
+static int vic_rsa_pre_cal(struct vic_sec_ctx *ctx)
+{
+	struct vic_rsa_key *rsa_key = &ctx->rsa_key;
+	size_t size = rsa_key->key_sz;
+	int ret = -ENOMEM;
+
+	rsa_key->rinv = kzalloc(size, GFP_KERNEL);
+	if(!rsa_key->rinv)
+		goto err;
+
+	rsa_key->mp = kzalloc(size, GFP_KERNEL);
+	if(!rsa_key->mp)
+		goto err;
+
+	rsa_key->rsqr = kzalloc(size, GFP_KERNEL);
+	if(!rsa_key->rsqr)
+		goto err;
+
+	ret = vic_rsa_calc_rinv(ctx, size, rsa_key->n, rsa_key->rinv);
+	if(ret)
+		return ret;
+	ret = vic_rsa_calc_mp(ctx, size, rsa_key->rinv,rsa_key->n,rsa_key->mp);
+	if(ret)
+		return ret;
+
+	ret = vic_rsa_calc_rsqr(ctx, size, rsa_key->rinv, rsa_key->n, rsa_key->mp,
+				rsa_key->rsqr);
+
+ err:
+	return ret;
+}
+
+static int vic_rsa_pre_cal_crt(struct vic_sec_ctx *ctx)
+{
+	struct vic_rsa_key *rsa_key = &ctx->rsa_key;
+	int ret = -ENOMEM;
+	size_t size = rsa_key->key_sz >> 1;
+
+	rsa_key->rinv_p = kzalloc(size, GFP_KERNEL);
+	if(!rsa_key->rinv_p)
+		goto err;
+
+	rsa_key->rinv_q = kzalloc(size, GFP_KERNEL);
+	if(!rsa_key->rinv_q)
+		goto err;
+
+	rsa_key->pmp = kzalloc(size, GFP_KERNEL);
+	if(!rsa_key->pmp)
+		goto err;
+
+	rsa_key->qmp = kzalloc(size, GFP_KERNEL);
+	if(!rsa_key->qmp)
+		goto err;
+
+	rsa_key->rsqr_p = kzalloc(size, GFP_KERNEL);
+	if(!rsa_key->rsqr_p)
+		goto err;
+
+	rsa_key->rsqr_q = kzalloc(size, GFP_KERNEL);
+	if(!rsa_key->rsqr_q)
+		goto err;
+
+	ret = vic_rsa_calc_rinv(ctx, size, rsa_key->p, rsa_key->rinv_p);
+	if(ret)
+		return ret;
+
+	ret = vic_rsa_calc_mp(ctx, size, rsa_key->rinv_p, rsa_key->p, rsa_key->pmp);
+	if(ret)
+		return ret;
+
+	ret = vic_rsa_calc_rsqr(ctx, size, rsa_key->rinv_p, rsa_key->p, rsa_key->pmp,
+				rsa_key->rsqr_p);
+	if(ret)
+		return ret;
+
+
+	ret = vic_rsa_calc_rinv(ctx, size, rsa_key->q, rsa_key->rinv_q);
+	if(ret)
+		return ret;
+
+	ret = vic_rsa_calc_mp(ctx, size, rsa_key->rinv_q, rsa_key->q, rsa_key->qmp);
+	if(ret)
+		return ret;
+
+	ret = vic_rsa_calc_rsqr(ctx, size, rsa_key->rinv_q, rsa_key->q, rsa_key->qmp,
+				rsa_key->rsqr_q);
+
+ err:
+	return ret;
+}
+
+static int vic_rsa_enc_core(struct vic_sec_ctx *ctx, int enc)
+{
+	struct vic_sec_dev *sdev = ctx->sdev;
+	struct vic_sec_request_ctx *rctx = sdev->rctx;
+	struct vic_rsa_key *key = &ctx->rsa_key;
+	size_t data_len, total, count, data_offset;
+	int ret = 0;
+
+	rctx->offset = 0;
+	total = 0;
+
+
+	while(total < sdev->total_in) {
+		count = min (sdev->data_buf_len, sdev->total_in);
+		count = min (count, key->key_sz);
+		memset(sdev->data, 0, key->key_sz);
+		data_offset = key->key_sz - count;
+		data_len = vic_cryp_get_from_sg(rctx, rctx->offset, count, data_offset);
+		if(data_len < 0)
+			return data_len;
+		if(data_len != count) {
+			return -EINVAL;
+		}
+		if(!enc && key->crt_mode) {
+			size_t size = key->key_sz >> 1;
+			ret = vic_rsa_crt(ctx, size, sdev->data + size, sdev->data,
+					  0,sdev->data + key->key_sz + size, sdev->data + key->key_sz);
+		} else {
+			ret = vic_rsa_calc_modexp(ctx, sdev->data, 0, sdev->data + key->key_sz, enc);
+		}
+		if(ret) {
+			return ret;
+		}
+
+		sg_copy_buffer(rctx->out_sg,sg_nents(rctx->out_sg), sdev->data + key->key_sz,
+			       key->key_sz, rctx->offset, 0);
+
+		rctx->offset += data_len;
+		total += data_len;
+	}
+
+	return ret;
+}
+
+static int vic_rsa_enc(struct akcipher_request *req)
+{
+	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
+	struct vic_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+	struct vic_rsa_key *key = &ctx->rsa_key;
+	struct vic_sec_request_ctx *rctx = akcipher_request_ctx(req);
+	int ret = 0;
+
+	if (unlikely(!key->n || !key->e))
+		return -EINVAL;
+
+
+	if (req->dst_len < key->key_sz) {
+		req->dst_len = key->key_sz;
+		dev_err(ctx->sdev->dev, "Output buffer length less than parameter n\n");
+		return -EOVERFLOW;
+	}
+
+	rctx->sg = req->src;
+	rctx->out_sg = req->dst;
+	rctx->sdev = ctx->sdev;
+	ctx->sdev->rctx = rctx;
+	ctx->sdev->total_in = req->src_len;
+	ctx->sdev->total_out = req->dst_len;
+
+	ret = vic_rsa_pre_cal(ctx);
+	if(ret) {
+		return ret;
+	}
+
+	ret = vic_rsa_enc_core(ctx, 1);
+
+	return ret;
+}
+
+static int vic_rsa_dec(struct akcipher_request *req)
+{
+	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
+	struct vic_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+	struct vic_rsa_key *key = &ctx->rsa_key;
+	struct vic_sec_request_ctx *rctx = akcipher_request_ctx(req);
+	int ret = 0;
+
+	if (unlikely(!key->n || !key->d))
+		return -EINVAL;
+
+	if (req->dst_len < key->key_sz) {
+		req->dst_len = key->key_sz;
+		dev_err(ctx->sdev->dev, "Output buffer length less than parameter n\n");
+		return -EOVERFLOW;
+	}
+
+	rctx->sg = req->src;
+	rctx->out_sg = req->dst;
+	rctx->sdev = ctx->sdev;
+	ctx->sdev->rctx = rctx;
+	ctx->sdev->total_in = req->src_len;
+	ctx->sdev->total_out = req->dst_len;
+
+	if(key->crt_mode) {
+		ret = vic_rsa_pre_cal_crt(ctx);
+	} else {
+		ret = vic_rsa_pre_cal(ctx);
+	}
+
+	if(ret) {
+		return ret;
+	}
+
+	ret = vic_rsa_enc_core(ctx, 0);
+	return ret;
+}
+
+static unsigned long vic_rsa_enc_fn_id(unsigned int len)
+{
+	unsigned int bitslen = len << 3;
+
+	switch (bitslen) {
+		//case 256:
+	case 512:
+	case 768:
+	case 1024:
+	case 1536:
+	case 2048:
+	case 3072:
+	case 4096:
+		return 0;
+	default:
+		return -EINVAL;
+	};
+}
+
+static int vic_rsa_set_n(struct vic_rsa_key *rsa_key, const char *value,
+			 size_t vlen)
+{
+	const char *ptr = value;
+	int ret;
+
+	while (!*ptr && vlen) {
+		ptr++;
+		vlen--;
+	}
+
+	rsa_key->key_sz = vlen;
+	ret = -EINVAL;
+	/* invalid key size provided */
+	if (vic_rsa_enc_fn_id(rsa_key->key_sz))
+		goto err;
+
+	ret = -ENOMEM;
+	rsa_key->n = kmemdup(ptr, rsa_key->key_sz, GFP_KERNEL);
+	if (!rsa_key->n)
+		goto err;
+
+	return 0;
+ err:
+	rsa_key->key_sz = 0;
+	rsa_key->n = NULL;
+	return ret;
+}
+
+static int vic_rsa_set_e(struct vic_rsa_key *rsa_key, const char *value,
+			 size_t vlen)
+{
+	const char *ptr = value;
+
+	while (!*ptr && vlen) {
+		ptr++;
+		vlen--;
+	}
+
+	if (!rsa_key->key_sz || !vlen || vlen > rsa_key->key_sz) {
+		rsa_key->e = NULL;
+		return -EINVAL;
+	}
+
+	rsa_key->e = kzalloc(rsa_key->key_sz, GFP_KERNEL);
+	if (!rsa_key->e)
+		return -ENOMEM;
+
+	memcpy(rsa_key->e + (rsa_key->key_sz - vlen), ptr, vlen);
+	return 0;
+}
+
+static int vic_rsa_set_d(struct vic_rsa_key *rsa_key, const char *value,
+			 size_t vlen)
+{
+	const char *ptr = value;
+	int ret;
+
+	while (!*ptr && vlen) {
+		ptr++;
+		vlen--;
+	}
+
+	ret = -EINVAL;
+	if (!rsa_key->key_sz || !vlen || vlen > rsa_key->key_sz)
+		goto err;
+
+	ret = -ENOMEM;
+	rsa_key->d = kzalloc(rsa_key->key_sz, GFP_KERNEL);
+	if (!rsa_key->d)
+		goto err;
+
+	memcpy(rsa_key->d + (rsa_key->key_sz - vlen), ptr, vlen);
+	return 0;
+ err:
+	rsa_key->d = NULL;
+	return ret;
+}
+
+static void vic_rsa_drop_leading_zeros(const char **ptr, unsigned int *len)
+{
+	while (!**ptr && *len) {
+		(*ptr)++;
+		(*len)--;
+	}
+}
+
+static void vic_rsa_setkey_crt(struct vic_rsa_key *rsa_key, struct rsa_key *raw_key)
+{
+	const char *ptr;
+	unsigned int len;
+	unsigned int half_key_sz = rsa_key->key_sz / 2;
+
+	/* p */
+	ptr = raw_key->p;
+	len = raw_key->p_sz;
+	vic_rsa_drop_leading_zeros(&ptr, &len);
+	if (!len) {
+		goto err;
+	}
+	rsa_key->p = kzalloc(half_key_sz, GFP_KERNEL);
+	if (!rsa_key->p) {
+		goto err;
+	}
+	memcpy(rsa_key->p + (half_key_sz - len), ptr, len);
+
+	/* q */
+	ptr = raw_key->q;
+	len = raw_key->q_sz;
+	vic_rsa_drop_leading_zeros(&ptr, &len);
+	if (!len) {
+		goto free_p;
+	}
+	rsa_key->q = kzalloc(half_key_sz, GFP_KERNEL);
+	if (!rsa_key->q) {
+		goto free_p;
+	}
+	memcpy(rsa_key->q + (half_key_sz - len), ptr, len);
+
+	/* dp */
+	ptr = raw_key->dp;
+	len = raw_key->dp_sz;
+	vic_rsa_drop_leading_zeros(&ptr, &len);
+	if (!len) {
+		goto free_q;
+	}
+	rsa_key->dp = kzalloc(half_key_sz, GFP_KERNEL);
+	if (!rsa_key->dp) {
+		goto free_q;
+	}
+	memcpy(rsa_key->dp + (half_key_sz - len), ptr, len);
+
+	/* dq */
+	ptr = raw_key->dq;
+	len = raw_key->dq_sz;
+	vic_rsa_drop_leading_zeros(&ptr, &len);
+	if (!len) {
+		goto free_dp;
+	}
+	rsa_key->dq = kzalloc(half_key_sz, GFP_KERNEL);
+	if (!rsa_key->dq) {
+		goto free_dp;
+	}
+	memcpy(rsa_key->dq + (half_key_sz - len), ptr, len);
+
+	/* qinv */
+	ptr = raw_key->qinv;
+	len = raw_key->qinv_sz;
+	vic_rsa_drop_leading_zeros(&ptr, &len);
+	if (!len) {
+		goto free_dq;
+	}
+	rsa_key->qinv = kzalloc(half_key_sz, GFP_KERNEL);
+	if (!rsa_key->qinv) {
+		goto free_dq;
+	}
+	memcpy(rsa_key->qinv + (half_key_sz - len), ptr, len);
+
+	rsa_key->crt_mode = true;
+	return;
+
+ free_dq:
+	memset(rsa_key->dq, '\0', half_key_sz);
+	kfree_sensitive(rsa_key->dq);
+	rsa_key->dq = NULL;
+ free_dp:
+	memset(rsa_key->dp, '\0', half_key_sz);
+	kfree_sensitive(rsa_key->dp);
+	rsa_key->dp = NULL;
+ free_q:
+	memset(rsa_key->q, '\0', half_key_sz);
+	kfree_sensitive(rsa_key->q);
+	rsa_key->q = NULL;
+ free_p:
+	memset(rsa_key->p, '\0', half_key_sz);
+	kfree_sensitive(rsa_key->p);
+	rsa_key->p = NULL;
+ err:
+	rsa_key->crt_mode = false;
+}
+
+static int vic_rsa_setkey(struct crypto_akcipher *tfm, const void *key,
+			  unsigned int keylen, bool private)
+{
+	struct vic_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+	struct rsa_key raw_key = {NULL};
+	struct vic_rsa_key *rsa_key = &ctx->rsa_key;
+	int ret;
+
+	vic_rsa_free_key(rsa_key);
+
+	if (private)
+		ret = rsa_parse_priv_key(&raw_key, key, keylen);
+	else
+		ret = rsa_parse_pub_key(&raw_key, key, keylen);
+	if (ret < 0)
+		goto free;
+
+	ret = vic_rsa_set_n(rsa_key, raw_key.n, raw_key.n_sz);
+	if (ret < 0)
+		goto free;
+	ret = vic_rsa_set_e(rsa_key, raw_key.e, raw_key.e_sz);
+	if (ret < 0)
+		goto free;
+	if (private) {
+		ret = vic_rsa_set_d(rsa_key, raw_key.d, raw_key.d_sz);
+		if (ret < 0)
+			goto free;
+		vic_rsa_setkey_crt(rsa_key, &raw_key);
+	}
+
+	if (!rsa_key->n || !rsa_key->e) {
+		/* invalid key provided */
+		ret = -EINVAL;
+		goto free;
+	}
+	if (private && !rsa_key->d) {
+		/* invalid private key provided */
+		ret = -EINVAL;
+		goto free;
+	}
+
+	return 0;
+ free:
+	vic_rsa_free_key(rsa_key);
+	return ret;
+}
+
+static int vic_rsa_set_pub_key(struct crypto_akcipher *tfm, const void *key,
+			       unsigned int keylen)
+{
+	return vic_rsa_setkey(tfm, key, keylen, false);
+}
+
+static int vic_rsa_set_priv_key(struct crypto_akcipher *tfm, const void *key,
+				unsigned int keylen)
+{
+	return vic_rsa_setkey(tfm, key, keylen, true);
+}
+
+static unsigned int vic_rsa_max_size(struct crypto_akcipher *tfm)
+{
+	struct vic_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+
+	return ctx->rsa_key.key_sz;
+}
+
+static int vic_pka_reload_firmware(struct pka_state *pka)
+{
+	u32 fw_words, i, *fw;
+	int ret = 0;
+
+	fw_words = sizeof(PKA_FW)/sizeof(u32);
+	if (fw_words > pka->cfg.fw_ram_size) {
+		ERROR("large firmware\r\n");
+		return -EINVAL;
+	}
+
+	fw = (u32 *)(pka->regbase + pka->cfg.ram_offset);
+	for (i = 0; i < fw_words; fw++, i++) {
+		vic_pka_io_write32(fw, PKA_FW[i]);
+	}
+
+	return ret;
+}
+
+/* Per session pkc's driver context creation function */
+static int vic_rsa_init_tfm(struct crypto_akcipher *tfm)
+{
+	struct vic_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+
+	//akcipher_set_reqsize(tfm, sizeof(struct vic_sec_request_ctx));
+	ctx->sdev = vic_sec_find_dev(ctx);
+
+	if (!ctx->sdev)
+		return -ENODEV;
+	mutex_lock(&ctx->sdev->lock);
+	vic_clk_enable(ctx->sdev,PKA_CLK);
+	vic_pka_reload_firmware(&ctx->sdev->pka);
+
+	return 0;
+}
+
+/* Per session pkc's driver context cleanup function */
+static void vic_rsa_exit_tfm(struct crypto_akcipher *tfm)
+{
+	struct vic_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+	struct vic_rsa_key *key = (struct vic_rsa_key *)&ctx->rsa_key;
+
+	vic_rsa_free_key(key);
+	vic_clk_disable(ctx->sdev,PKA_CLK);
+	mutex_unlock(&ctx->sdev->lock);
+	//vic_jr_free(ctx->dev);
+}
+
+irqreturn_t vic_pka_irq_done(struct vic_sec_dev *sdev)
+{
+	struct pka_state *pka = &sdev->pka;
+	u32 status;
+
+	status = vic_pka_io_read32((void *)&sdev->pka.regbase[PKA_F_STACK]);
+	if (status & 0xF) {
+		pka->pka_err |= BIT(PKA_F_STACK);
+	}
+
+	status = vic_pka_io_read32((void *)&sdev->pka.regbase[PKA_STATUS]);
+	if (!(status & BIT(PKA_STAT_IRQ))) {
+		pka->pka_err |= BIT(PKA_STAT_IRQ);
+	}
+
+	status = vic_pka_io_read32((void *)&sdev->pka.regbase[PKA_RC]);
+	if (status & 0x00FF0000) {
+		pka->pka_err |= BIT(PKA_RC);
+	}
+
+	vic_pka_io_write32(&sdev->pka.regbase[PKA_STATUS], BIT(PKA_STAT_IRQ));
+
+	status = vic_pka_io_read32((void *)&sdev->pka.regbase[PKA_STATUS]);
+	if (status & BIT(PKA_STAT_IRQ)) {
+		pka->pka_err |= BIT(PKA_STAT_IRQ);
+	}
+
+	pka->pka_done = 1;
+	status = vic_pka_io_read32((void *)&sdev->pka.regbase[PKA_IRQ_EN]);
+
+	//up(&sdev->core_running);
+	return IRQ_WAKE_THREAD;
+}
+
+static struct akcipher_alg vic_rsa = {
+	.encrypt = vic_rsa_enc,
+	.decrypt = vic_rsa_dec,
+	.sign = vic_rsa_dec,
+	.verify = vic_rsa_enc,
+	.set_pub_key = vic_rsa_set_pub_key,
+	.set_priv_key = vic_rsa_set_priv_key,
+	.max_size = vic_rsa_max_size,
+	.init = vic_rsa_init_tfm,
+	.exit = vic_rsa_exit_tfm,
+	.reqsize = sizeof(struct vic_sec_request_ctx),
+	.base = {
+		.cra_name = "rsa",
+		.cra_driver_name = "rsa-vic",
+		.cra_flags = CRYPTO_ALG_TYPE_AKCIPHER |
+		            CRYPTO_ALG_ASYNC,
+		.cra_priority = 3000,
+		.cra_module = THIS_MODULE,
+		.cra_ctxsize = sizeof(struct vic_sec_ctx),
+	},
+};
+
+int vic_pka_init(struct pka_state *pka)
+{
+	u32 fw_words, i, *fw;
+	int ret = 0;
+
+	ret = elppka_setup(pka);
+	if(ret)
+		return ret;
+
+	fw_words = sizeof(PKA_FW)/sizeof(u32);
+	if (fw_words > pka->cfg.fw_ram_size) {
+		ERROR("large firmware\r\n");
+		return -EINVAL;
+	}
+
+	fw = (u32 *)(pka->regbase + pka->cfg.ram_offset);
+	for (i = 0; i < fw_words; fw++, i++) {
+		vic_pka_io_write32(fw, PKA_FW[i]);
+	}
+
+	vic_pka_io_write32(&pka->regbase[PKA_IRQ_EN], 1 << PKA_IRQ_EN_STAT);
+
+	vic_pka_io_write32(&pka->regbase[PKA_WATCHDOG], 100000000);
+
+	return ret;
+}
+
+int vic_pka_register_algs(void)
+{
+	int ret;
+
+	ret = crypto_register_akcipher(&vic_rsa);
+	if (ret)
+		printk("VIC RSA registration failed\n");
+
+	return ret;
+}
+
+int vic_pka_unregister_algs(void)
+{
+	crypto_unregister_akcipher(&vic_rsa);
+	return 0;
+}
diff --git a/drivers/crypto/sifive-vic/vic-pka.h b/drivers/crypto/sifive-vic/vic-pka.h
new file mode 100644
index 000000000000..429815793a48
--- /dev/null
+++ b/drivers/crypto/sifive-vic/vic-pka.h
@@ -0,0 +1,173 @@
+#ifndef __VIC_PKA_H__
+#define __VIC_PKA_H__
+#include <crypto/internal/akcipher.h>
+#include <crypto/internal/rsa.h>
+
+#define CRYPTO_OK                      (   0)
+#define CRYPTO_FAILED                  (  -1)
+#define CRYPTO_INPROGRESS              (  -2)
+#define CRYPTO_INVALID_HANDLE          (  -3)
+#define CRYPTO_INVALID_CONTEXT         (  -4)
+#define CRYPTO_INVALID_SIZE            (  -5)
+#define CRYPTO_NOT_INITIALIZED         (  -6)
+#define CRYPTO_NO_MEM                  (  -7)
+#define CRYPTO_INVALID_ALG             (  -8)
+#define CRYPTO_INVALID_KEY_SIZE        (  -9)
+#define CRYPTO_INVALID_ARGUMENT        ( -10)
+#define CRYPTO_MODULE_DISABLED         ( -11)
+#define CRYPTO_NOT_IMPLEMENTED         ( -12)
+#define CRYPTO_INVALID_BLOCK_ALIGNMENT ( -13)
+#define CRYPTO_INVALID_MODE            ( -14)
+#define CRYPTO_INVALID_KEY             ( -15)
+#define CRYPTO_AUTHENTICATION_FAILED   ( -16)
+#define CRYPTO_INVALID_IV_SIZE         ( -17)
+#define CRYPTO_MEMORY_ERROR            ( -18)
+#define CRYPTO_LAST_ERROR              ( -19)
+#define CRYPTO_HALTED                  ( -20)
+#define CRYPTO_TIMEOUT                 ( -21)
+#define CRYPTO_SRM_FAILED              ( -22)
+#define CRYPTO_COMMON_ERROR_MAX        (-100)
+#define CRYPTO_INVALID_ICV_KEY_SIZE    (-100)
+#define CRYPTO_INVALID_PARAMETER_SIZE  (-101)
+#define CRYPTO_SEQUENCE_OVERFLOW       (-102)
+#define CRYPTO_DISABLED                (-103)
+#define CRYPTO_INVALID_VERSION         (-104)
+#define CRYPTO_FATAL                   (-105)
+#define CRYPTO_INVALID_PAD             (-106)
+#define CRYPTO_FIFO_FULL               (-107)
+#define CRYPTO_INVALID_SEQUENCE        (-108)
+#define CRYPTO_INVALID_FIRMWARE        (-109)
+#define CRYPTO_NOT_FOUND               (-110)
+#define CRYPTO_CMD_FIFO_INACTIVE       (-111)
+
+enum PKA_ENTRY_E {
+	PKA_MODMULT           = 10, //0x0a
+	PKA_MODADD            = 11, //0x0b
+	PKA_MODSUB            = 12, //0x0c
+	PKA_MODDIV            = 13, //0x0d
+	PKA_MODINV            = 14, //0x0e
+	PKA_REDUCE            = 15, //0x0f
+	PKA_CALC_MP           = 16, //0x10
+	PKA_CALC_R_INV        = 17, //0x11
+	PKA_CALC_R_SQR        = 18, //0x12
+	PKA_MULT              = 19, //0x13
+	PKA_MODEXP            = 20, //0x14
+	PKA_CRT_KEY_SETUP     = 21, //0x15
+	PKA_CRT               = 22, //0x16
+	PKA_BIT_SERIAL_MOD_DP = 23, //0x17
+	PKA_BIT_SERIAL_MOD    = 24, //0x18
+	PKA_PMULT             = 25, //0x19
+	PKA_PDBL              = 26, //0x1a
+	PKA_PDBL_STD_PRJ      = 27, //0x1b
+	PKA_PADD              = 28, //0x1c
+	PKA_PADD_STD_PRJ      = 29, //0x1d
+	PKA_PVER              = 30, //0x1e
+	PKA_STD_PRJ_TO_AFFINE = 31, //0x1f
+	PKA_IS_P_EQUAL_Q      = 32, //0x20
+	PKA_IS_P_REFLECT_Q    = 33, //0x21
+	PKA_IS_A_M3           = 34, //0x22
+	PKA_SHAMIR            = 35, //0x23
+	PKA_PMULT_521         = 36, //0x24
+	PKA_PDBL_521          = 37, //0x25
+	PKA_PADD_521          = 38, //0x26
+	PKA_PVER_521          = 39, //0x27
+	PKA_M_521_MONTMULT    = 40, //0x28
+	PKA_MODMULT_521       = 41, //0x29
+	PKA_SHAMIR_521        = 42, //0x2a
+};
+
+struct pka_state {
+	u32 *regbase;
+
+	struct pka_config {
+		unsigned alu_size, rsa_size, ecc_size;
+		unsigned fw_ram_size, fw_rom_size;
+		unsigned ram_offset, rom_offset;
+	} cfg;
+	uint32_t pka_done;
+	uint32_t pka_err;
+};
+
+struct pka_fw {
+	unsigned long ram_size, rom_size;
+	const char *errmsg;
+
+	struct pka_fw_tag {
+		unsigned long origin, tag_length, timestamp, md5_coverage;
+		unsigned char md5[16];
+	} ram_tag, rom_tag;
+
+	/* For internal use */
+	struct elppka_fw_priv *priv;
+};
+
+struct vic_rsa_key {
+	u8 *n;
+	u8 *e;
+	u8 *d;
+	u8 *p;
+	u8 *q;
+	u8 *dp;
+	u8 *dq;
+	u8 *qinv;
+	u8 *rinv;
+	u8 *rinv_p;
+	u8 *rinv_q;
+	u8 *mp;
+	u8 *rsqr;
+	u8 *rsqr_p;
+	u8 *rsqr_q;
+	u8 *pmp;
+	u8 *qmp;
+	size_t key_sz;
+	bool crt_mode;
+};
+
+enum {
+	PKA_OPERAND_A,
+	PKA_OPERAND_B,
+	PKA_OPERAND_C,
+	PKA_OPERAND_D,
+	PKA_OPERAND_MAX
+};
+
+static inline void vic_pka_io_write32(void *addr, unsigned long val)
+{
+	writel(val,addr);
+}
+
+static inline unsigned int vic_pka_io_read32(void *addr)
+{
+	return readl(addr);
+}
+
+int elppka_setup(struct pka_state *pka);
+
+int elppka_start(struct pka_state *pka, uint32_t entry, uint32_t flags,
+		 unsigned size);
+void elppka_abort(struct pka_state *pka);
+int elppka_get_status(struct pka_state *pka, unsigned *code);
+
+int elppka_load_operand(struct pka_state *pka, unsigned bank, unsigned index,
+			unsigned size, const uint8_t *data);
+int elppka_unload_operand(struct pka_state *pka, unsigned bank, unsigned index,
+			  unsigned size, uint8_t *data);
+
+void elppka_set_byteswap(struct pka_state *pka, int swap);
+
+/* Firmware image handling */
+int elppka_fw_parse(struct pka_fw *fw, const unsigned char *data,
+		    unsigned long len);
+void elppka_fw_free(struct pka_fw *fw);
+
+int elppka_fw_lookup_entry(struct pka_fw *fw, const char *entry);
+
+int elppka_fw_load(struct pka_state *pka, struct pka_fw *fw);
+
+/* The firmware timestamp epoch (2009-11-11 11:00:00Z) as a UNIX timestamp. */
+#define PKA_FW_TS_EPOCH 1257937200ull
+
+/* Resolution of the timestamp, in seconds. */
+#define PKA_FW_TS_RESOLUTION 20
+
+#endif
diff --git a/drivers/crypto/sifive-vic/vic-sec.c b/drivers/crypto/sifive-vic/vic-sec.c
new file mode 100644
index 000000000000..7d75f033d03e
--- /dev/null
+++ b/drivers/crypto/sifive-vic/vic-sec.c
@@ -0,0 +1,308 @@
+/*
+ ******************************************************************************
+ * @file  vic-sec.c
+ * @author  StarFive Technology
+ * @version  V1.0
+ * @date  08/13/2020
+ * @brief
+ ******************************************************************************
+ * @copy
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+ * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+ * TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE FOR ANY
+ * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+ * FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+ * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ * <h2><center>&copy; COPYRIGHT 2020 Shanghai StarFive Technology Co., Ltd. </center></h2>
+ */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+
+#include <crypto/aes.h>
+#include <crypto/des.h>
+#include <crypto/scatterwalk.h>
+#include <crypto/internal/aead.h>
+
+#include "vic-sec.h"
+
+#define DRIVER_NAME             "vic-sec"
+
+#define CRYP_AUTOSUSPEND_DELAY	50
+
+struct vic_dev_list {
+	struct list_head        dev_list;
+	spinlock_t              lock; /* protect dev_list */
+};
+
+static struct vic_dev_list dev_list = {
+	.dev_list = LIST_HEAD_INIT(dev_list.dev_list),
+	.lock     = __SPIN_LOCK_UNLOCKED(dev_list.lock),
+};
+
+struct vic_sec_dev *vic_sec_find_dev(struct vic_sec_ctx *ctx)
+{
+	struct vic_sec_dev *sdev = NULL, *tmp;
+
+	spin_lock_bh(&dev_list.lock);
+	if (!ctx->sdev) {
+		list_for_each_entry(tmp, &dev_list.dev_list, list) {
+			sdev = tmp;
+			break;
+		}
+		ctx->sdev = sdev;
+	} else {
+		sdev = ctx->sdev;
+	}
+
+	spin_unlock_bh(&dev_list.lock);
+
+	return sdev;
+}
+
+static irqreturn_t vic_cryp_irq_thread(int irq, void *arg)
+{
+	struct vic_sec_dev *sdev = (struct vic_sec_dev *) arg;
+
+	mutex_unlock(&sdev->doing);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t vic_cryp_irq(int irq, void *arg)
+{
+	struct vic_sec_dev *sdev = (struct vic_sec_dev *) arg;
+	irqreturn_t ret = IRQ_WAKE_THREAD;
+
+	if(sdev->status.aes_busy || sdev->status.sha_busy) {
+		sdev->status.v = readl(sdev->io_base + SEC_STATUS_REG);
+		writel(sdev->status.v, sdev->io_base + SEC_STATUS_REG);
+	} else {
+		ret = vic_pka_irq_done(sdev);
+	}
+
+	return ret;
+}
+static const struct of_device_id vic_dt_ids[] = {
+	{ .compatible = "starfive,vic-sec", .data = NULL},
+	{},
+};
+MODULE_DEVICE_TABLE(of, vic_dt_ids);
+
+extern void vic_hash_test(struct vic_sec_dev *sdev);
+
+static int vic_cryp_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct vic_sec_dev *sdev;
+	struct resource *res;
+	int irq, ret;
+	int pages = 0;
+
+	sdev = devm_kzalloc(dev, sizeof(*sdev), GFP_KERNEL);
+	if (!sdev)
+		return -ENOMEM;
+
+	sdev->dev = dev;
+
+	mutex_init(&sdev->lock);
+	mutex_init(&sdev->doing);
+
+	sdev->io_base = devm_platform_ioremap_resource_byname(pdev, "secmem");
+	if (IS_ERR(sdev->io_base))
+		return PTR_ERR(sdev->io_base);
+
+	sdev->clk_base = devm_platform_ioremap_resource_byname(pdev, "secclk");
+	if (IS_ERR(sdev->clk_base))
+		return PTR_ERR(sdev->clk_base);
+
+	sdev->pka.regbase = sdev->io_base + PKA_IO_BASE_OFFSET;
+
+	/* pka irq handle check */
+	sdev->status.v = 0;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(dev, "Cannot get IRQ resource\n");
+		return irq;
+	}
+
+	ret = devm_request_threaded_irq(dev, irq, vic_cryp_irq,
+					vic_cryp_irq_thread, IRQF_ONESHOT,
+					dev_name(dev), sdev);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't get interrupt working.\n");
+		return ret;
+	}
+
+	sdev->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(sdev->clk)) {
+		dev_err(dev, "Could not get clock\n");
+		return PTR_ERR(sdev->clk);
+	}
+
+	ret = clk_prepare_enable(sdev->clk);
+	if (ret) {
+		dev_err(sdev->dev, "Failed to enable clock\n");
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, sdev);
+
+	spin_lock(&dev_list.lock);
+	list_add(&sdev->list, &dev_list.dev_list);
+	spin_unlock(&dev_list.lock);
+
+	pages = get_order(VIC_AES_MSG_RAM_SIZE);
+
+	sdev->data = (void *)__get_free_pages(GFP_KERNEL, pages);
+	if (!sdev->data) {
+		dev_err(sdev->dev, "Can't allocate pages when unaligned\n");
+		return -EFAULT;
+	}
+	sdev->data_buf_len = VIC_AES_BUF_RAM_SIZE;
+	sdev->pages_count = pages;
+
+	/* Initialize crypto engine */
+	sdev->engine = crypto_engine_alloc_init(dev, 1);
+	if (!sdev->engine) {
+		ret = -ENOMEM;
+		goto err_engine;
+	}
+
+	ret = crypto_engine_start(sdev->engine);
+	if (ret)
+		goto err_engine_start;
+
+	ret = vic_hash_register_algs();
+	if (ret) {
+		goto err_algs_sha;
+	}
+
+	vic_clk_enable(sdev,AES_CLK);
+	ret = vic_aes_register_algs();
+	if (ret) {
+		vic_clk_disable(sdev,AES_CLK);
+		dev_err(dev, "Could not register algs\n");
+		goto err_algs_aes;
+	}
+	vic_clk_disable(sdev,AES_CLK);
+
+	vic_clk_enable(sdev,PKA_CLK);
+	ret = vic_pka_init(&sdev->pka);
+	if (ret) {
+		vic_clk_disable(sdev,PKA_CLK);
+		dev_err(dev, "pka init error\n");
+		goto err_pka_init;
+	}
+
+	ret = vic_pka_register_algs();
+	if (ret) {
+		vic_clk_disable(sdev,PKA_CLK);
+		dev_err(dev, "Could not register algs\n");
+		goto err_algs_pka;
+	}
+	vic_clk_disable(sdev,PKA_CLK);
+	dev_info(dev, "Initialized\n");
+
+	return 0;
+
+err_algs_pka:
+err_pka_init:
+	vic_aes_unregister_algs();
+err_algs_aes:
+	vic_hash_unregister_algs();
+err_engine_start:
+	crypto_engine_exit(sdev->engine);
+err_engine:
+err_algs_sha:
+	free_pages((unsigned long)sdev->data, pages);
+	spin_lock(&dev_list.lock);
+	list_del(&sdev->list);
+	spin_unlock(&dev_list.lock);
+
+	clk_disable_unprepare(sdev->clk);
+
+	return ret;
+}
+
+static int vic_cryp_remove(struct platform_device *pdev)
+{
+	struct vic_sec_dev *sdev = platform_get_drvdata(pdev);
+
+	if (!sdev)
+		return -ENODEV;
+
+
+	vic_pka_unregister_algs();
+	vic_aes_unregister_algs();
+	vic_hash_unregister_algs();
+
+	crypto_engine_exit(sdev->engine);
+
+	free_pages((unsigned long)sdev->data, sdev->pages_count);
+
+	spin_lock(&dev_list.lock);
+	list_del(&sdev->list);
+	spin_unlock(&dev_list.lock);
+
+	clk_disable_unprepare(sdev->clk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int vic_cryp_runtime_suspend(struct device *dev)
+{
+	struct vic_sec_dev *cryp = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(cryp->clk);
+
+	return 0;
+}
+
+static int vic_cryp_runtime_resume(struct device *dev)
+{
+	struct vic_sec_dev *cryp = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(cryp->clk);
+	if (ret) {
+		dev_err(cryp->dev, "Failed to prepare_enable clock\n");
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops vic_cryp_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+	SET_RUNTIME_PM_OPS(vic_cryp_runtime_suspend,
+			   vic_cryp_runtime_resume, NULL)
+};
+
+static struct platform_driver vic_cryp_driver = {
+	.probe  = vic_cryp_probe,
+	.remove = vic_cryp_remove,
+	.driver = {
+		.name           = DRIVER_NAME,
+		.pm		= &vic_cryp_pm_ops,
+		.of_match_table = vic_dt_ids,
+	},
+};
+
+module_platform_driver(vic_cryp_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Huan Feng <huan.feng@starfivetech.com>");
+MODULE_DESCRIPTION("Starfive VIC CRYP SHA and AES driver");
diff --git a/drivers/crypto/sifive-vic/vic-sec.h b/drivers/crypto/sifive-vic/vic-sec.h
new file mode 100644
index 000000000000..0967127cad0a
--- /dev/null
+++ b/drivers/crypto/sifive-vic/vic-sec.h
@@ -0,0 +1,446 @@
+#ifndef __VIC_SEC_H__
+#define __VIC_SEC_H__
+
+#include <crypto/aes.h>
+#include <crypto/sha.h>
+#include <crypto/engine.h>
+#include <linux/delay.h>
+
+#include "vic-pka.h"
+
+#define SEC_IE_REG      0x00
+#define SEC_STATUS_REG  0x04
+
+#define MAX_KEY_SIZE		SHA512_BLOCK_SIZE
+
+#define AES_ABLK        1
+#define AES_AEAD        2
+
+#define SHA_CLK 1
+#define AES_CLK 2
+#define PKA_CLK 3
+
+#define AES_CLK_OFFSET 0x0
+#define SHA_CLK_OFFSET 0x4
+#define PKA_CLK_OFFSET 0x8
+
+#define HASH_OP_UPDATE			1
+#define HASH_OP_FINAL			2
+
+#define CFG_REGS_LEN 	32
+
+#define PKA_IO_BASE_OFFSET (32*1024)
+
+union vic_sec_ie {
+	u32 v;
+	struct {
+		u32 sec_done_ie    	:1 ;
+		u32 mac_valid_ie	:1 ;
+		u32 rsvd_0         	:30;
+	};
+};
+
+union vic_sec_status {
+	u32 v;
+	struct {
+		u32 sec_done       	:1 ;
+		u32 aes_mac_valid  	:1 ;
+		u32 aes_busy 	   	:1 ;
+		u32 sha_busy       	:1 ;
+		u32 rsvd_1         	:28;
+	};
+};
+
+#define swap32(val) (						\
+		     (((u32)(val) << 24) & (u32)0xFF000000) |	\
+		     (((u32)(val) <<  8) & (u32)0x00FF0000) |	\
+		     (((u32)(val) >>  8) & (u32)0x0000FF00) |	\
+		     (((u32)(val) >> 24) & (u32)0x000000FF))
+
+static inline void vic_write_n (void *addr, const u8 *value, unsigned int count)
+{
+	unsigned int *data = (unsigned int *) value;
+	int loop = count >> 2;
+
+	for (; loop--; data++, addr += sizeof(unsigned int))
+		writel_relaxed(swap32(*data), addr);
+
+	if(unlikely(count & 0x3)) {
+		int ext = count & 0x3;
+		value = (u8 *)data;
+		for(; ext; ext--){
+			writeb_relaxed(*(value + ext - 1), addr + 4 - ext);
+		}
+	}
+}
+
+static inline void vic_read_n (void *addr, unsigned char *out, unsigned int count)
+{
+	unsigned int *data = (unsigned int *) out;
+	int loop = count >> 2;
+
+	for (; loop--; data++, addr += sizeof(unsigned int))
+		*data = swap32(readl_relaxed(addr));
+
+	if(unlikely(count & 0x3)) {
+		int ext = count & 0x3;
+		out = (u8 *)data;
+		for(; ext; ext-- )
+			*(out + ext - 1) = readb_relaxed(addr + 4 - ext);
+	}
+}
+
+struct vic_sec_ctx {
+	struct crypto_engine_ctx enginectx;
+	struct vic_sec_dev      *sdev;
+	struct crypto_aead      *sw_cipher;
+	unsigned long           flags;
+
+	u8			key[MAX_KEY_SIZE];
+	int                     keylen;
+	int                     begin_new;
+	struct vic_rsa_key      rsa_key;
+};
+
+struct vic_sec_dev {
+	struct list_head        list;
+	struct device           *dev;
+	struct clk		*clk;
+	void __iomem		*io_base;
+	void __iomem		*clk_base;
+	void                *data;
+	//void                *data_out;
+	int                 pages_count;
+	struct vic_sec_ctx   *ctx;
+	struct vic_sec_request_ctx *rctx;
+
+	struct ahash_request	*req;
+	struct crypto_engine	*engine;
+
+	unsigned long           flags;
+
+	union vic_sec_ie        ie;
+	union vic_sec_status    status;
+	struct mutex 			doing;
+
+	struct mutex            lock; /* protects req / areq */
+	struct skcipher_request *sreq;
+	struct aead_request     *areq;
+
+	size_t			        data_buf_len;
+	size_t			        data_offset;
+	size_t                  authsize;
+
+	size_t                  total_in;
+	size_t                  total_out;
+
+	bool                    sgs_copied;
+
+	int                     in_sg_len;
+	int                     out_sg_len;
+
+	struct scatter_walk     in_walk;
+	struct scatter_walk     out_walk;
+
+	u32                     last_ctr[4];
+	u32 					ctr_over_count;
+	u32                     gcm_ctr;
+
+   struct pka_state pka;
+   char fw_name[32];
+
+   /*
+    * If you hold a reference to the firmware (obtained by pka_get_firmware),
+    * then the fw pointer is guaranteed to remain valid until the reference is
+    * dropped; otherwise, one must only access the fw pointer while holding
+    * the fw_mutex.
+    */
+   struct pka_fw_priv *fw;
+   struct mutex fw_mutex;
+
+   /*
+    * Rather than access PKA flags register directly, store flags to be used
+    * for the next operation in work_flags, and cache flags from the previous
+    * operation in saved_flags.
+    */
+   u32 work_flags, saved_flags;
+};
+
+// aes
+
+#define VIC_AES_QUEUE_SIZE		512
+#define VIC_AES_BUF_ORDER		2
+
+#define VIC_AES_CTRL_REG    0x40
+#define VIC_AES_CFG_REGS    0x44
+
+#define VIC_AES_MSG_RAM_OFFSET  (16*1024)
+#define VIC_AES_MSG_RAM_SIZE    (8*1024)
+// 8160 is mod(32) and mod(24)
+#define VIC_AES_BUF_RAM_SIZE    8160
+
+#define VIC_AES_CTX_RAM_OFFSET  (VIC_AES_MSG_RAM_OFFSET + VIC_AES_MSG_RAM_SIZE)
+#define VIC_AES_CTX_RAM_SIZE    (4*1024)
+
+#define VIC_AES_CTX_KEYS_OFS    0x00
+#define VIC_AES_CTX_KEYS_SIZE   0x20
+#define VIC_AES_CTX_CTR_OFS     0x30
+#define VIC_AES_CTX_CTR_SIZE    0x20
+#define VIC_AES_CTX_IV_OFS      0x40
+#define VIC_AES_CTX_IV_SIZE     0x10
+#define VIC_AES_CTX_MAC_OFS     0x50
+#define VIC_AES_CTX_MAC_SIZE    0x10
+
+#define VIC_AES_IV_LEN          AES_BLOCK_SIZE
+#define VIC_AES_CTR_LEN         AES_BLOCK_SIZE
+
+union vic_aes_ctrl {
+	unsigned int v;
+	struct {
+		unsigned int aes_mode        :4 ;
+#define VIC_AES_MODE_ECB    0
+#define VIC_AES_MODE_CBC    1
+#define VIC_AES_MODE_CTR    2
+#define VIC_AES_MODE_CCM    3
+#define VIC_AES_MODE_CMAC   4
+#define VIC_AES_MODE_GCM    5
+#define VIC_AES_MODE_OFB    7
+#define VIC_AES_MODE_CFB    8
+		unsigned int aes_encrypt     :1 ;
+#define VIC_AES_DECRYPT     0
+#define VIC_AES_ENCRYPT     1
+		unsigned int aes_msg_begin   :1 ;
+		unsigned int aes_msg_end     :1 ;
+		unsigned int aes_str_ctx     :1 ; // Stores intermediate context data back into context memory.
+		unsigned int aes_ret_ctx     :1 ; // Retrieves intermediate context data from context memory.
+		unsigned int aes_inv_key     :1 ;
+		unsigned int aes_str_inv_key :1 ;
+		unsigned int rsvd_0          :1 ;
+		unsigned int aes_key_sz      :2 ;
+#define VIC_AES_KEY_SZ_128  0
+#define VIC_AES_KEY_SZ_192  1
+#define VIC_AES_KEY_SZ_256  2
+		unsigned int rsvd_1          :17; // [30:14]
+		unsigned int aes_start       :1 ;
+	};
+};
+
+union vic_aes_cfg {
+	unsigned int vs[1];
+	struct {
+		// 0x44
+		unsigned int aes_tag_msg_addr :13;
+		unsigned int rsvd_0           :18; // [30:13]
+		unsigned int aes_str_tag2msg  :1 ;
+
+		// 0x48
+		unsigned int authsize         :4; //unsigned int aes_mac_len      :4 ;
+		unsigned int rsvd_1           :28; // [31:4]
+
+		// 0x4C
+		unsigned int aes_blk_idx      :9 ;
+#define VIC_AES_BLK_SIZE    0x10
+#define VIC_AES_BLKS_NUM    512 //8k/0x10
+		unsigned int rsvd_2           :23; // [31:9]
+
+		// 0x50
+		unsigned int aes_ctx_idx      :5 ;
+#define VIC_AES_CTX_SIZE    0x60
+#define VIC_AES_CTXS_NUM    32 //4k/0x60
+		unsigned int rsvd_3           :27; // [31:5]
+
+		// 0x54
+		unsigned int aes_assoclen     :14; //aes_aad_len      :14;
+		unsigned int rsvd_4           :18; // [31:14]
+
+		// 0x58
+		unsigned int aes_n_bytes      :14; // Number of bytes of message to cipher in current operation.
+		unsigned int rsvd_5           :18; // [31:14]
+
+		// 0x5C
+		unsigned int aes_tot_n_bytes  :28; // Total length of message data (across all segments), not including AD, to process. Required in CCM and GCM modes.
+		unsigned int rsvd_6           :4 ; // [31:28]
+
+		// 0x60
+		unsigned int aes_assoclen_tot :28; //aes_aad_len_tot  :28;
+		unsigned int rsvd_7           :4 ; // [31:28]
+	};
+};
+
+#define KEY_SET_FLAG    1
+#define IV_SET_FLAG     (1 << 1)
+#define CTR_SET_FLAG    (1 << 2)
+#define AD_SET_FLAG     (1 << 3)
+#define MAC_SET_FLAG    (1 << 4)
+
+
+extern void  vic_aes_irq_complete(int irq, void *arg);
+
+// sha
+#define HASH_BUFLEN			256
+
+#define HASH_AUTOSUSPEND_DELAY		50
+#define CTX_BLOCK_SIZE                  64
+#define VIC_MAX_ALIGN_SIZE              128
+
+union vic_sha_ctrl {
+	u32 v;
+	struct {
+		// 0x80
+		u32 sha_mode           :4 ;
+#define SHA_MODE_224            0
+#define SHA_MODE_256            1
+#define SHA_MODE_384            2
+#define SHA_MODE_512            3
+#define SHA_MODE_1              4
+#define SHA_MODE_MD5            5
+#define SHA_MODE_512_DIV_224    7
+#define SHA_MODE_512_DIV_256    8
+		u32 sha_hmac           :1 ;
+		u32 sha_sslmac         :1 ;
+		u32 sha_msg_begin      :1 ;
+		u32 sha_msg_end        :1 ;
+		u32 sha_store_ctx      :1 ;
+		u32 sha_retrieve_ctx   :1 ;
+		u32 rsvd_0             :21; // [30:10]
+		u32 sha_start          :1 ;
+	};
+};
+
+union vic_sha_cfg {
+	u32 vs[1];
+	struct {
+		// 0x84
+#define SHA_CTX_MSG_ADDR 0x100
+#define SHA_CTX_MSG_ADDR_ROUNDS 0x100
+		u32 sha_ctx_msg_addr   :13;
+		u32 rsvd_0             :18; // [30:13]
+		u32 sha_store_ctx_2msg :1 ;
+
+		// 0x88
+		u32 sha_secret_bytes   :8 ;
+		u32 sha_secret_addr    :11;
+		u32 rsvd_1             :13; // [31:19]
+
+		// 0x8C
+		u32 sha_num_bytes      :14;
+		u32 rsvd_2             :18; // [31:14]
+
+		// 0x90
+		u32 sha_icv_len        :6 ;
+		u32 rsvd_3             :26; // [31:6]
+
+		// 0x94
+		u32 sha_ctx_idx        :6 ;
+		u32 rsvd_4             :26; // [31:6]
+
+		// 0x98
+		u32 sha_blk_idx        :7 ;
+		u32 rsvd_5             :25; // [31:7]
+
+		// 0x9C
+		u32 sha_tot_bytes      :26;
+		u32 rsvd_6             :6 ; // [31:26]
+
+		// 0xA0
+		u32 sha_seqn0             ;
+	};
+};
+
+struct vic_sec_request_ctx {
+	struct vic_sec_dev	*sdev;
+	unsigned long		mode;
+	unsigned long		flags;
+	unsigned long		op;
+
+	u8 digest[CTX_BLOCK_SIZE] __aligned(sizeof(u32));
+	size_t			digcnt;
+	size_t			bufcnt;
+	size_t			buflen;
+	size_t			cmac_up_len;
+
+	size_t			assoclen;
+	unsigned int            is_load;
+	unsigned int             req_type;
+
+
+	struct scatterlist	*sg;
+	struct scatterlist	*out_sg;
+	unsigned int		offset;
+	unsigned int		total;
+	unsigned long			msg_tot;
+
+	union vic_aes_cfg       aes_cfg;
+	union vic_aes_ctrl      aes_ctrl;
+	union vic_sha_cfg       sha_cfg;
+	union vic_sha_ctrl      sha_ctrl;
+	unsigned int 	        last_block_idx;
+
+	u8 buffer[HASH_BUFLEN] __aligned(sizeof(u32));
+};
+
+static inline void vic_clk_enable(struct vic_sec_dev *sdev, int type)
+{
+	u32 val;
+
+	switch(type) {
+	case AES_CLK:
+		val = readl(sdev->clk_base + AES_CLK_OFFSET);
+		val &= ~(0x1 << 31);
+		val |= 0x1 << 31;
+		writel(val, sdev->clk_base + AES_CLK_OFFSET);
+		break;
+	case PKA_CLK:
+		val = readl(sdev->clk_base + PKA_CLK_OFFSET);
+		val &= ~(0x1 << 31);
+		val |= 0x1 << 31;
+		writel(val, sdev->clk_base + PKA_CLK_OFFSET);
+		break;
+	}
+}
+
+static inline void vic_clk_disable(struct vic_sec_dev *sdev, int type)
+{
+	u32 val;
+
+	switch(type) {
+	case AES_CLK:
+		val = readl(sdev->clk_base + AES_CLK_OFFSET);
+		val &= ~(0x1 << 31);
+		val |= 0x0 << 31;
+		writel(val, sdev->clk_base + AES_CLK_OFFSET);
+		break;
+	case PKA_CLK:
+		val = readl(sdev->clk_base + PKA_CLK_OFFSET);
+		val &= ~(0x1 << 31);
+		val |= 0x0 << 31;
+		writel(val, sdev->clk_base + PKA_CLK_OFFSET);
+		break;
+	}
+}
+
+#if 0
+struct vic_hash_algs_info {
+	struct ahash_alg	*algs_list;
+	size_t			size;
+};
+
+struct vic_hash_pdata {
+	struct vic_hash_algs_info	*algs_info;
+	size_t				algs_info_size;
+};
+#endif
+extern int vic_aes_register_algs(void);
+extern int vic_aes_unregister_algs(void);
+extern struct vic_sec_dev *vic_sec_find_dev(struct vic_sec_ctx *ctx);
+extern int vic_cryp_get_from_sg(struct vic_sec_request_ctx *rctx, size_t offset,
+								size_t count,size_t data_offset);
+
+extern int vic_hash_register_algs(void);
+extern int vic_hash_unregister_algs(void);
+
+extern int vic_pka_register_algs(void);
+extern int vic_pka_unregister_algs(void);
+extern irqreturn_t vic_pka_irq_done(struct vic_sec_dev *sdev);
+extern int vic_pka_init(struct pka_state *pka);
+#endif
diff --git a/drivers/crypto/sifive-vic/vic-sha.c b/drivers/crypto/sifive-vic/vic-sha.c
new file mode 100644
index 000000000000..efdc9a2bbd01
--- /dev/null
+++ b/drivers/crypto/sifive-vic/vic-sha.c
@@ -0,0 +1,1101 @@
+/*
+ ******************************************************************************
+ * @file  vic-sha.c
+ * @author  StarFive Technology
+ * @version  V1.0
+ * @date  08/13/2020
+ * @brief
+ ******************************************************************************
+ * @copy
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+ * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+ * TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE FOR ANY
+ * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+ * FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+ * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ * <h2><center>&copy; COPYRIGHT 2020 Shanghai StarFive Technology Co., Ltd. </center></h2>
+ */
+
+#include <linux/clk.h>
+#include <linux/crypto.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+
+#include <crypto/engine.h>
+#include <crypto/hash.h>
+#include <crypto/md5.h>
+#include <crypto/scatterwalk.h>
+
+#include <crypto/internal/hash.h>
+
+#include "vic-sec.h"
+
+#define HASH_IE          0x00
+#define HASH_STATUS      0x04
+#define HASH_CTRL        0x80
+#define HASH_CFG        0x84
+
+#define SHA_MSG_RAM_OFFSET  (16*1024)
+#define SHA_MSG_RAM_SIZE    (8*1024)
+#define SHA_CTX_RAM_OFFSET  (SHA_MSG_RAM_OFFSET + SHA_MSG_RAM_SIZE)
+#define SHA_CTX_RAM_SIZE    (4*1024)
+#define SHA_SEC_RAM_OFFSET  (SHA_CTX_RAM_OFFSET + SHA_CTX_RAM_SIZE)
+#define SHA_SEC_RAM_SIZE    (2*1024)
+
+
+#define HASH_FLAGS_INIT			BIT(0)
+#define HASH_FLAGS_FINAL		BIT(3)
+#define HASH_FLAGS_FINUP		BIT(4)
+
+#define HASH_FLAGS_ALGO_MASK		GENMASK(8, 13)
+#define HASH_FLAGS_MD5			BIT(8)
+#define HASH_FLAGS_SHA1			BIT(9)
+#define HASH_FLAGS_SHA224		BIT(10)
+#define HASH_FLAGS_SHA256		BIT(11)
+#define HASH_FLAGS_SHA384		BIT(12)
+#define HASH_FLAGS_SHA512		BIT(13)
+#define HASH_FLAGS_ERRORS		BIT(14)
+#define HASH_FLAGS_HMAC			BIT(15)
+
+static inline int vic_hash_wait_busy(struct vic_sec_dev *hdev)
+{
+	int ret = -1;
+
+	mutex_lock(&hdev->doing);
+	if(hdev->status.sec_done && (!hdev->status.sha_busy))
+		ret = 0;
+	mutex_unlock(&hdev->doing);
+	return ret;
+	//return wait_cond_timeout(hdev->status.sec_done && (!hdev->status.sha_busy), 10, 10000);
+}
+
+static int vic_hash_write_key(struct vic_sec_dev *hdev)
+{
+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(hdev->req);
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+	int keylen = ctx->keylen;
+	void *key = ctx->key;
+
+	if (keylen) {
+		vic_write_n(hdev->io_base + SHA_SEC_RAM_OFFSET, key, keylen);
+	}
+
+	return 0;
+}
+
+static void vic_hash_append_sg(struct vic_sec_request_ctx *rctx)
+{
+	size_t count;
+
+	while ((rctx->bufcnt < rctx->buflen) && rctx->total) {
+		count = min(rctx->sg->length - rctx->offset, rctx->total);
+		count = min(count, rctx->buflen - rctx->bufcnt);
+
+		if (count <= 0) {
+			if ((rctx->sg->length == 0) && !sg_is_last(rctx->sg)) {
+				rctx->sg = sg_next(rctx->sg);
+				continue;
+			} else {
+				break;
+			}
+		}
+
+		scatterwalk_map_and_copy(rctx->buffer + rctx->bufcnt, rctx->sg,
+					 rctx->offset, count, 0);
+
+		rctx->bufcnt += count;
+		rctx->offset += count;
+		rctx->total -= count;
+
+		if (rctx->offset == rctx->sg->length) {
+			rctx->sg = sg_next(rctx->sg);
+			if (rctx->sg)
+				rctx->offset = 0;
+			else
+				rctx->total = 0;
+		}
+	}
+}
+
+static int vic_sha_start(struct vic_sec_request_ctx *rctx)
+{
+	struct vic_sec_dev *sdev = rctx->sdev;
+	int loop, int_len = sizeof(unsigned int);
+
+	if(sdev->status.sha_busy) {
+		return -EBUSY;
+	}
+
+	for(loop = 0; loop < CFG_REGS_LEN / int_len; loop++) {
+		writel(*(rctx->sha_cfg.vs + loop), sdev->io_base + HASH_CFG + loop * int_len);
+	}
+	sdev->ie.sec_done_ie = 1;
+	mutex_lock(&sdev->doing);
+
+	writel(sdev->ie.v, sdev->io_base + HASH_IE);
+	sdev->status.sha_busy = 1;
+	sdev->status.sec_done = 0;
+	rctx->sha_ctrl.sha_start = 1;
+	writel(rctx->sha_ctrl.v, sdev->io_base + HASH_CTRL);
+
+	return 0;
+}
+
+static int vic_hash_xmit_cpu(struct vic_sec_dev *sdev,
+			       struct vic_sec_request_ctx *rctx, int final)
+{
+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(sdev->req);
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+	int length = rctx->bufcnt;
+	int ret = -EINPROGRESS;
+
+	memset(&rctx->sha_cfg,0,sizeof(rctx->sha_cfg));
+	memset(&rctx->sha_ctrl,0,sizeof(rctx->sha_ctrl));
+
+	if (final) {
+		if(rctx->msg_tot){
+			rctx->sha_cfg.sha_num_bytes = length;
+			rctx->sha_cfg.sha_tot_bytes = rctx->msg_tot + length;
+			rctx->sha_cfg.sha_store_ctx_2msg = 1;
+			rctx->sha_cfg.sha_ctx_msg_addr = SHA_CTX_MSG_ADDR;
+			rctx->sha_cfg.sha_ctx_idx = 0;
+			rctx->sha_ctrl.sha_mode = rctx->mode;
+			rctx->sha_ctrl.sha_msg_end = 1;
+			rctx->sha_ctrl.sha_retrieve_ctx = 1;
+		} else {
+			rctx->sha_cfg.sha_num_bytes = length;
+			rctx->sha_cfg.sha_tot_bytes = length;
+			rctx->sha_cfg.sha_store_ctx_2msg = 1;
+			rctx->sha_cfg.sha_ctx_msg_addr = SHA_CTX_MSG_ADDR;
+			rctx->sha_cfg.sha_ctx_idx = 0;
+
+			rctx->sha_ctrl.sha_mode = rctx->mode;
+			rctx->sha_ctrl.sha_msg_begin = 1;
+			rctx->sha_ctrl.sha_msg_end = 1;
+			rctx->sha_ctrl.sha_store_ctx = 1;
+		}
+		sdev->flags |= HASH_FLAGS_FINAL;
+		ret = 0;
+	} else {
+		rctx->msg_tot += length;
+
+		rctx->sha_cfg.sha_num_bytes = length;
+		rctx->sha_cfg.sha_ctx_idx = 0;
+
+		rctx->sha_ctrl.sha_store_ctx = 1;
+		rctx->sha_ctrl.sha_mode = rctx->mode;
+		if(rctx->last_block_idx == 0){
+			rctx->sha_ctrl.sha_msg_begin = 1;
+		} else {
+			rctx->sha_ctrl.sha_retrieve_ctx = 1;
+		}
+
+		rctx->last_block_idx = 1;
+	}
+
+	if (rctx->flags & HASH_FLAGS_HMAC) {
+		rctx->sha_cfg.sha_secret_bytes = ctx->keylen;
+		rctx->sha_ctrl.sha_hmac = 1;
+	}
+
+	// put_msg
+	vic_write_n(sdev->io_base + SHA_MSG_RAM_OFFSET, rctx->buffer, rctx->bufcnt);
+
+	//set key
+	vic_hash_write_key(sdev);
+
+	//start
+	vic_sha_start(rctx);
+
+	//wait();
+	if(vic_hash_wait_busy(sdev))
+		ret = -ETIMEDOUT;
+
+	return ret;
+}
+
+static int vic_hash_update_cpu(struct vic_sec_dev *hdev)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(hdev->req);
+	int err = 0, final;
+
+	dev_dbg(hdev->dev, "%s flags %lx\n", __func__, rctx->flags);
+
+	final = (rctx->flags & HASH_FLAGS_FINUP);
+
+	while ((rctx->total >= rctx->buflen) ||
+	       (rctx->bufcnt + rctx->total >= rctx->buflen)) {
+		vic_hash_append_sg(rctx);
+
+		err = vic_hash_xmit_cpu(hdev, rctx, 0);
+		rctx->bufcnt = 0;
+	}
+
+	vic_hash_append_sg(rctx);
+
+	if (final) {
+		err = vic_hash_xmit_cpu(hdev, rctx,
+					(rctx->flags & HASH_FLAGS_FINUP));
+		rctx->bufcnt = 0;
+	} else {
+		err = vic_hash_xmit_cpu(hdev, rctx,
+					0);
+		rctx->bufcnt = 0;
+	}
+
+	return err;
+}
+
+static int vic_hash_init(struct ahash_request *req)
+{
+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct vic_sec_dev *hdev = ctx->sdev;
+
+	memset(rctx,0,sizeof(struct vic_sec_request_ctx));
+
+	rctx->sdev = hdev;
+
+	rctx->sdev->req = req;
+
+	rctx->digcnt = crypto_ahash_digestsize(tfm);
+	switch (rctx->digcnt) {
+	case MD5_DIGEST_SIZE:
+		rctx->mode = SHA_MODE_MD5;
+		break;
+	case SHA1_DIGEST_SIZE:
+		rctx->mode = SHA_MODE_1;
+		break;
+	case SHA224_DIGEST_SIZE:
+		rctx->mode = SHA_MODE_224;
+		break;
+	case SHA256_DIGEST_SIZE:
+		rctx->mode = SHA_MODE_256;
+		break;
+	case SHA384_DIGEST_SIZE:
+		rctx->mode = SHA_MODE_384;
+		break;
+	case SHA512_DIGEST_SIZE:
+		rctx->mode = SHA_MODE_512;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	rctx->bufcnt = 0;
+	rctx->buflen = HASH_BUFLEN;
+	rctx->total = 0;
+	rctx->msg_tot = 0;
+	rctx->offset = 0;
+	rctx->is_load = 0;
+	rctx->last_block_idx = 0;
+
+	memset(rctx->buffer, 0, HASH_BUFLEN);
+
+	if (ctx->flags & HASH_FLAGS_HMAC)
+		rctx->flags |= HASH_FLAGS_HMAC;
+
+	dev_dbg(hdev->dev, "%s Flags %lx\n", __func__, rctx->flags);
+
+	return 0;
+}
+
+static int vic_hash_update_req(struct vic_sec_dev *hdev)
+{
+	return vic_hash_update_cpu(hdev);
+}
+
+static int vic_hash_final_req(struct vic_sec_dev *hdev)
+{
+	struct ahash_request *req = hdev->req;
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+	int err;
+
+	err = vic_hash_xmit_cpu(hdev, rctx, 1);
+
+	rctx->bufcnt = 0;
+
+
+	return err;
+}
+
+static void vic_hash_set_ctx(struct ahash_request *req)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+
+	vic_write_n(rctx->sdev->io_base + SHA_CTX_RAM_OFFSET,
+		   rctx->digest, CTX_BLOCK_SIZE);
+}
+
+static void vic_hash_copy_hash(struct ahash_request *req)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+	unsigned int hashsize;
+
+	switch (rctx->mode) {
+	case SHA_MODE_MD5:
+		hashsize = MD5_DIGEST_SIZE;
+		break;
+	case SHA_MODE_1:
+		hashsize = SHA1_DIGEST_SIZE;
+		break;
+	case SHA_MODE_224:
+		hashsize = SHA224_DIGEST_SIZE;
+		break;
+	case SHA_MODE_256:
+		hashsize = SHA256_DIGEST_SIZE;
+		break;
+	case SHA_MODE_384:
+		hashsize = SHA384_DIGEST_SIZE;
+		break;
+	case SHA_MODE_512:
+		hashsize = SHA512_DIGEST_SIZE;
+		break;
+	default:
+		return;
+	}
+
+	vic_read_n(rctx->sdev->io_base + SHA_MSG_RAM_OFFSET + rctx->sha_cfg.sha_ctx_msg_addr,
+		   rctx->digest, hashsize);
+}
+
+static int vic_hash_finish(struct ahash_request *req)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+
+	if (!req->result)
+		return -EINVAL;
+
+	memcpy(req->result, rctx->digest, rctx->digcnt);
+
+	return 0;
+}
+
+static void vic_hash_finish_req(struct ahash_request *req, int err)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct vic_sec_dev *hdev = rctx->sdev;
+
+	if (!err && (HASH_FLAGS_FINAL & hdev->flags)) {
+		vic_hash_copy_hash(req);
+		err = vic_hash_finish(req);
+		hdev->flags &= ~(HASH_FLAGS_FINAL |
+				 HASH_FLAGS_INIT | HASH_FLAGS_HMAC);
+	} else {
+		rctx->flags |= HASH_FLAGS_ERRORS;
+	}
+
+	crypto_finalize_hash_request(hdev->engine, req, err);
+}
+
+static int vic_hash_one_request(struct crypto_engine *engine, void *areq);
+static int vic_hash_prepare_req(struct crypto_engine *engine, void *areq);
+
+static int vic_hash_handle_queue(struct vic_sec_dev *hdev,
+				   struct ahash_request *req)
+{
+	return crypto_transfer_hash_request_to_engine(hdev->engine, req);
+}
+
+static int vic_hash_prepare_req(struct crypto_engine *engine, void *areq)
+{
+	struct ahash_request *req = container_of(areq, struct ahash_request,
+						 base);
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
+	struct vic_sec_dev *hdev = ctx->sdev;
+	struct vic_sec_request_ctx *rctx;
+
+	if (!hdev) {
+		return -ENODEV;
+	}
+
+	rctx = ahash_request_ctx(req);
+
+	dev_dbg(hdev->dev, "processing new req, op: %lu, nbytes %d\n",
+		rctx->op, req->nbytes);
+
+	return 0;
+}
+
+static int vic_hash_one_request(struct crypto_engine *engine, void *areq)
+{
+	struct ahash_request *req = container_of(areq, struct ahash_request,
+						 base);
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
+	struct vic_sec_dev *hdev = ctx->sdev;
+	struct vic_sec_request_ctx *rctx;
+	int err = 0;
+
+	if (!hdev) {
+		return -ENODEV;
+	}
+
+	rctx = ahash_request_ctx(req);
+
+	if(rctx->is_load) {
+		vic_hash_set_ctx(req);
+		rctx->is_load = 0;
+	}
+
+	if (rctx->op == HASH_OP_UPDATE){
+		err = vic_hash_update_req(hdev);
+	} else if (rctx->op == HASH_OP_FINAL) {
+		err = vic_hash_final_req(hdev);
+	}
+
+	if (err != -EINPROGRESS)
+	/* done task will not finish it, so do it here */
+		vic_hash_finish_req(req, err);
+
+	return 0;
+}
+
+static int vic_hash_enqueue(struct ahash_request *req, unsigned int op)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct vic_sec_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+	struct vic_sec_dev *hdev = ctx->sdev;
+
+	rctx->op = op;
+
+	return vic_hash_handle_queue(hdev, req);
+}
+
+static int vic_hash_update(struct ahash_request *req)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+
+	if (!req->nbytes)
+		return 0;
+
+	rctx->total = req->nbytes;
+	rctx->sg = req->src;
+	rctx->offset = 0;
+
+	if ((rctx->total >= rctx->buflen) ||
+	       (rctx->bufcnt + rctx->total >= rctx->buflen)) {
+		if(rctx->is_load) {
+			vic_hash_set_ctx(req);
+			rctx->is_load = 0;
+		}
+		while ((rctx->total >= rctx->buflen) ||
+		       (rctx->bufcnt + rctx->total >= rctx->buflen)) {
+			vic_hash_append_sg(rctx);
+
+			vic_hash_xmit_cpu(rctx->sdev, rctx, 0);
+			rctx->bufcnt = 0;
+		}
+		rctx->is_load = 1;
+		vic_read_n(rctx->sdev->io_base + SHA_CTX_RAM_OFFSET,
+			   rctx->digest, CTX_BLOCK_SIZE);
+	}
+
+	if ((rctx->bufcnt + rctx->total < rctx->buflen)) {
+		vic_hash_append_sg(rctx);
+		return 0;
+	}
+
+
+	return vic_hash_enqueue(req, HASH_OP_UPDATE);
+}
+
+static int vic_hash_final(struct ahash_request *req)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+
+	rctx->flags |= HASH_FLAGS_FINUP;
+
+	return vic_hash_enqueue(req, HASH_OP_FINAL);
+}
+
+static int vic_hash_finup(struct ahash_request *req)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+	int err1, err2;
+
+	rctx->flags |= HASH_FLAGS_FINUP;
+
+	err1 = vic_hash_update(req);
+
+	if (err1 == -EINPROGRESS || err1 == -EBUSY) {
+		return err1;
+	}
+
+	/*
+	 * final() has to be always called to cleanup resources
+	 * even if update() failed, except EINPROGRESS
+	 */
+	err2 = vic_hash_final(req);
+
+	return err1 ?: err2;
+}
+
+static int vic_hash_digest(struct ahash_request *req)
+{
+	return vic_hash_init(req) ?: vic_hash_finup(req);
+}
+
+static int vic_hash_export(struct ahash_request *req, void *out)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+
+	memcpy(out, rctx, sizeof(*rctx));
+
+	return 0;
+}
+
+static int vic_hash_import(struct ahash_request *req, const void *in)
+{
+	struct vic_sec_request_ctx *rctx = ahash_request_ctx(req);
+
+	memcpy(rctx, in, sizeof(*rctx));
+
+	return 0;
+}
+#if 0
+static int vic_hash224_setkey(struct crypto_ahash *tfm,
+			     const u8 *key, unsigned int keylen)
+{
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+
+	if (keylen <= SHA224_BLOCK_SIZE) {
+		memcpy(ctx->key, key, keylen);
+		ctx->keylen = keylen;
+	} else {
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+#endif
+#if 0
+static int vic_hash256_setkey(struct crypto_ahash *tfm,
+			     const u8 *key, unsigned int keylen)
+{
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+
+	if (keylen <= SHA256_BLOCK_SIZE) {
+		memcpy(ctx->key, key, keylen);
+		ctx->keylen = keylen;
+	} else {
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int vic_hash384_setkey(struct crypto_ahash *tfm,
+			     const u8 *key, unsigned int keylen)
+{
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+
+	if (keylen <= SHA384_BLOCK_SIZE) {
+		memcpy(ctx->key, key, keylen);
+		ctx->keylen = keylen;
+	} else {
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+#else
+static int vic_hmac_setkey(struct crypto_ahash *tfm,
+			     const u8 *key, unsigned int keylen)
+{
+	unsigned int digestsize = crypto_ahash_digestsize(tfm);
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+	struct crypto_wait wait;
+	struct ahash_request *req;
+	struct scatterlist sg;
+	unsigned int blocksize;
+	struct crypto_ahash *ahash_tfm;
+	u8 *buf;
+	int ret;
+	const char *alg_name;
+
+	blocksize = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));
+
+	if (keylen <= blocksize) {
+		memcpy(ctx->key, key, keylen);
+		ctx->keylen = keylen;
+		return 0;
+	}
+
+	if (digestsize == SHA256_DIGEST_SIZE)
+		alg_name = "vic-sha256";
+	else if (digestsize == SHA384_DIGEST_SIZE)
+		alg_name = "vic-sha384";
+	else
+		return -EINVAL;
+
+	ctx->keylen = digestsize;
+	ahash_tfm = crypto_alloc_ahash(alg_name, 0, 0);
+	if (IS_ERR(ahash_tfm))
+		return PTR_ERR(ahash_tfm);
+
+	req = ahash_request_alloc(ahash_tfm, GFP_KERNEL);
+	if (!req) {
+		ret = -ENOMEM;
+		goto err_free_ahash;
+	}
+
+	crypto_init_wait(&wait);
+	ahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				   crypto_req_done, &wait);
+	crypto_ahash_clear_flags(ahash_tfm, ~0);
+
+	buf = kzalloc(keylen + VIC_MAX_ALIGN_SIZE, GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto err_free_req;
+	}
+
+	memcpy(buf, key, keylen);
+	sg_init_one(&sg, buf, keylen);
+	ahash_request_set_crypt(req, &sg, ctx->key, keylen);
+
+	ret = crypto_wait_req(crypto_ahash_digest(req), &wait);
+
+err_free_req:
+	ahash_request_free(req);
+err_free_ahash:
+	crypto_free_ahash(ahash_tfm);
+	return ret;
+}
+#endif
+
+#if 0
+static int vic_hash512_setkey(struct crypto_ahash *tfm,
+			     const u8 *key, unsigned int keylen)
+{
+	struct vic_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+
+	if (keylen <= SHA512_BLOCK_SIZE) {
+		memcpy(ctx->key, key, keylen);
+		ctx->keylen = keylen;
+	} else {
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+#endif
+static int vic_hash_cra_init_algs(struct crypto_tfm *tfm,
+				    const char *algs_hmac_name)
+{
+	struct vic_sec_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	ctx->sdev = vic_sec_find_dev(ctx);
+
+	if (!ctx->sdev)
+		return -ENODEV;
+
+	mutex_lock(&ctx->sdev->lock);
+
+	crypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),
+				 sizeof(struct vic_sec_request_ctx));
+
+	ctx->keylen = 0;
+
+	if (algs_hmac_name)
+		ctx->flags |= HASH_FLAGS_HMAC;
+
+	ctx->enginectx.op.do_one_request = vic_hash_one_request;
+	ctx->enginectx.op.prepare_request = vic_hash_prepare_req;
+	ctx->enginectx.op.unprepare_request = NULL;
+	return 0;
+}
+
+static int vic_hash_cra_init(struct crypto_tfm *tfm)
+{
+	return vic_hash_cra_init_algs(tfm, NULL);
+}
+
+static void vic_hash_cra_exit(struct crypto_tfm *tfm)
+{
+	struct vic_sec_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	mutex_unlock(&ctx->sdev->lock);
+}
+#if 0
+static int vic_hash_cra_md5_init(struct crypto_tfm *tfm)
+{
+	return vic_hash_cra_init_algs(tfm, "md5");
+}
+
+static int vic_hash_cra_sha1_init(struct crypto_tfm *tfm)
+{
+	return vic_hash_cra_init_algs(tfm, "sha1");
+}
+
+static int vic_hash_cra_sha224_init(struct crypto_tfm *tfm)
+{
+	return vic_hash_cra_init_algs(tfm, "sha224");
+}
+#endif
+static int vic_hash_cra_sha256_init(struct crypto_tfm *tfm)
+{
+	return vic_hash_cra_init_algs(tfm, "sha256");
+}
+
+static int vic_hash_cra_sha384_init(struct crypto_tfm *tfm)
+{
+	return vic_hash_cra_init_algs(tfm, "sha384");
+}
+#if 0
+static int vic_hash_cra_sha512_init(struct crypto_tfm *tfm)
+{
+	return vic_hash_cra_init_algs(tfm, "sha512");
+}
+#endif
+static struct ahash_alg algs_md5_sha512[] = {
+#if 0
+	{
+		.init = vic_hash_init,
+		.update = vic_hash_update,
+		.final = vic_hash_final,
+		.finup = vic_hash_finup,
+		.digest = vic_hash_digest,
+		.export = vic_hash_export,
+		.import = vic_hash_import,
+		.halg = {
+			.digestsize = MD5_DIGEST_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "md5",
+				.cra_driver_name = "vic-md5",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = MD5_HMAC_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_hash_cra_init,
+				.cra_exit = vic_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = vic_hash_init,
+		.update = vic_hash_update,
+		.final = vic_hash_final,
+		.finup = vic_hash_finup,
+		.digest = vic_hash_digest,
+		.export = vic_hash_export,
+		.import = vic_hash_import,
+		.setkey = vic_hash_setkey,
+		.halg = {
+			.digestsize = MD5_DIGEST_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "hmac(md5)",
+				.cra_driver_name = "vic-hmac-md5",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = MD5_HMAC_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_hash_cra_md5_init,
+				.cra_exit = vic_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = vic_hash_init,
+		.update = vic_hash_update,
+		.final = vic_hash_final,
+		.finup = vic_hash_finup,
+		.digest = vic_hash_digest,
+		.export = vic_hash_export,
+		.import = vic_hash_import,
+		.halg = {
+			.digestsize = SHA1_DIGEST_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "sha1",
+				.cra_driver_name = "vic-sha1",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = SHA1_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_hash_cra_init,
+				.cra_exit = vic_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = vic_hash_init,
+		.update = vic_hash_update,
+		.final = vic_hash_final,
+		.finup = vic_hash_finup,
+		.digest = vic_hash_digest,
+		.export = vic_hash_export,
+		.import = vic_hash_import,
+		.setkey = vic_hash_setkey,
+		.halg = {
+			.digestsize = SHA1_DIGEST_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "hmac(sha1)",
+				.cra_driver_name = "vic-hmac-sha1",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = SHA1_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_hash_cra_sha1_init,
+				.cra_exit = vic_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+
+	{
+		.init = vic_hash_init,
+		.update = vic_hash_update,
+		.final = vic_hash_final,
+		.finup = vic_hash_finup,
+		.digest = vic_hash_digest,
+		.export = vic_hash_export,
+		.import = vic_hash_import,
+		.halg = {
+			.digestsize = SHA224_DIGEST_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "sha224",
+				.cra_driver_name = "vic-sha224",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = SHA224_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_hash_cra_init,
+				.cra_exit = vic_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = vic_hash_init,
+		.update = vic_hash_update,
+		.final = vic_hash_final,
+		.finup = vic_hash_finup,
+		.digest = vic_hash_digest,
+		.export = vic_hash_export,
+		.import = vic_hash_import,
+		.setkey = vic_hash224_setkey,
+		.halg = {
+			.digestsize = SHA224_DIGEST_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "hmac(sha224)",
+				.cra_driver_name = "vic-hmac-sha224",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = SHA224_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_hash_cra_sha224_init,
+				.cra_exit = vic_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+#endif
+	{
+		.init = vic_hash_init,
+		.update = vic_hash_update,
+		.final = vic_hash_final,
+		.finup = vic_hash_finup,
+		.digest = vic_hash_digest,
+		.export = vic_hash_export,
+		.import = vic_hash_import,
+		.halg = {
+			.digestsize = SHA256_DIGEST_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "sha256",
+				.cra_driver_name = "vic-sha256",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = SHA256_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_hash_cra_init,
+				.cra_exit = vic_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = vic_hash_init,
+		.update = vic_hash_update,
+		.final = vic_hash_final,
+		.finup = vic_hash_finup,
+		.digest = vic_hash_digest,
+		.export = vic_hash_export,
+		.import = vic_hash_import,
+		.setkey = vic_hmac_setkey,
+		.halg = {
+			.digestsize = SHA256_DIGEST_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "hmac(sha256)",
+				.cra_driver_name = "vic-hmac-sha256",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = SHA256_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_hash_cra_sha256_init,
+				.cra_exit = vic_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = vic_hash_init,
+		.update = vic_hash_update,
+		.final = vic_hash_final,
+		.finup = vic_hash_finup,
+		.digest = vic_hash_digest,
+		.export = vic_hash_export,
+		.import = vic_hash_import,
+		.halg = {
+			.digestsize = SHA384_DIGEST_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "sha384",
+				.cra_driver_name = "vic-sha384",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = SHA384_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_hash_cra_init,
+				.cra_exit = vic_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = vic_hash_init,
+		.update = vic_hash_update,
+		.final = vic_hash_final,
+		.finup = vic_hash_finup,
+		.digest = vic_hash_digest,
+		.setkey = vic_hmac_setkey,
+		.export = vic_hash_export,
+		.import = vic_hash_import,
+		.halg = {
+			.digestsize = SHA384_DIGEST_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "hmac(sha384)",
+				.cra_driver_name = "vic-hmac-sha384",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+				             CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = SHA384_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_hash_cra_sha384_init,
+				.cra_exit = vic_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+#if 0
+	{
+		.init = vic_hash_init,
+		.update = vic_hash_update,
+		.final = vic_hash_final,
+		.finup = vic_hash_finup,
+		.digest = vic_hash_digest,
+		.export = vic_hash_export,
+		.import = vic_hash_import,
+		.halg = {
+			.digestsize = SHA512_DIGEST_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "sha512",
+				.cra_driver_name = "vic-sha512",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = SHA512_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_hash_cra_init,
+				.cra_exit = vic_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = vic_hash_init,
+		.update = vic_hash_update,
+		.final = vic_hash_final,
+		.finup = vic_hash_finup,
+		.digest = vic_hash_digest,
+		.setkey = vic_hash512_setkey,
+		.export = vic_hash_export,
+		.import = vic_hash_import,
+		.halg = {
+			.digestsize = SHA512_DIGEST_SIZE,
+			.statesize = sizeof(struct vic_sec_request_ctx),
+			.base = {
+				.cra_name = "hmac(sha512)",
+				.cra_driver_name = "vic-hmac-sha512",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_TYPE_AHASH,
+				.cra_blocksize = SHA512_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct vic_sec_ctx),
+				.cra_alignmask = 3,
+				.cra_init = vic_hash_cra_sha512_init,
+				.cra_exit = vic_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+#endif
+};
+
+int vic_hash_register_algs()
+{
+	int ret = 0;
+
+	ret = crypto_register_ahashes(algs_md5_sha512, ARRAY_SIZE(algs_md5_sha512));
+
+	return ret;
+}
+
+int vic_hash_unregister_algs()
+{
+	crypto_unregister_ahashes(algs_md5_sha512, ARRAY_SIZE(algs_md5_sha512));
+	return 0;
+}
diff --git a/drivers/i2c/busses/i2c-designware-core.h b/drivers/i2c/busses/i2c-designware-core.h
index eb5ef4d0f463..1e92d57ccd2f 100644
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@ -284,6 +284,8 @@ struct dw_i2c_dev {
 	int			(*init)(struct dw_i2c_dev *dev);
 	int			(*set_sda_hold_time)(struct dw_i2c_dev *dev);
 	int			mode;
+	int			scl_gpio;
+	int			sda_gpio;
 	struct i2c_bus_recovery_info rinfo;
 	bool			suspended;
 };
diff --git a/drivers/i2c/busses/i2c-designware-master.c b/drivers/i2c/busses/i2c-designware-master.c
index d6425ad6e6a3..f023df4dabcc 100644
--- a/drivers/i2c/busses/i2c-designware-master.c
+++ b/drivers/i2c/busses/i2c-designware-master.c
@@ -20,6 +20,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
+#include <linux/gpio-starfive-vic.h>
 
 #include "i2c-designware-core.h"
 
@@ -171,6 +172,58 @@ static int i2c_dw_set_timings_master(struct dw_i2c_dev *dev)
 	return ret;
 }
 
+static void i2c_dw_configure_gpio(struct dw_i2c_dev *dev)
+{
+	if((dev->scl_gpio > 0) && (dev->sda_gpio > 0)) {
+		switch(dev->adapter.nr) {
+		case 0:
+			SET_GPIO_dout_LOW(dev->scl_gpio);
+			SET_GPIO_dout_LOW(dev->sda_gpio);
+			SET_GPIO_doen_reverse_(dev->scl_gpio,1);
+			SET_GPIO_doen_reverse_(dev->sda_gpio,1);
+			SET_GPIO_doen_i2c0_pad_sck_oe(dev->scl_gpio);
+			SET_GPIO_doen_i2c0_pad_sda_oe(dev->sda_gpio);
+			SET_GPIO_i2c0_pad_sck_in(dev->scl_gpio);
+			SET_GPIO_i2c0_pad_sda_in(dev->sda_gpio);
+			break;
+		case 1:
+			SET_GPIO_dout_LOW(dev->scl_gpio);
+			SET_GPIO_dout_LOW(dev->sda_gpio);
+			SET_GPIO_doen_reverse_(dev->scl_gpio,1);
+			SET_GPIO_doen_reverse_(dev->sda_gpio,1);
+			SET_GPIO_doen_i2c1_pad_sck_oe(dev->scl_gpio);
+			SET_GPIO_doen_i2c1_pad_sda_oe(dev->sda_gpio);
+			SET_GPIO_i2c1_pad_sck_in(dev->scl_gpio);
+			SET_GPIO_i2c1_pad_sda_in(dev->sda_gpio);
+			break;
+		case 2:
+			SET_GPIO_dout_LOW(dev->scl_gpio);
+			SET_GPIO_dout_LOW(dev->sda_gpio);
+			SET_GPIO_doen_reverse_(dev->scl_gpio,1);
+			SET_GPIO_doen_reverse_(dev->sda_gpio,1);
+			SET_GPIO_doen_i2c2_pad_sck_oe(dev->scl_gpio);
+			SET_GPIO_doen_i2c2_pad_sda_oe(dev->sda_gpio);
+			SET_GPIO_i2c2_pad_sck_in(dev->scl_gpio);
+			SET_GPIO_i2c2_pad_sda_in(dev->sda_gpio);
+			break;
+		case 3:
+			SET_GPIO_dout_LOW(dev->scl_gpio);
+			SET_GPIO_dout_LOW(dev->sda_gpio);
+			SET_GPIO_doen_reverse_(dev->scl_gpio,1);
+			SET_GPIO_doen_reverse_(dev->sda_gpio,1);
+			SET_GPIO_doen_i2c3_pad_sck_oe(dev->scl_gpio);
+			SET_GPIO_doen_i2c3_pad_sda_oe(dev->sda_gpio);
+			SET_GPIO_i2c3_pad_sck_in(dev->scl_gpio);
+			SET_GPIO_i2c3_pad_sda_in(dev->sda_gpio);
+			break;
+		default:
+			dev_warn(dev->dev, "NOTE: i2c adapter number is invalid\n");
+		}
+	}
+	else
+		dev_warn(dev->dev, "NOTE: scl/sda gpio number is invalid !\n");
+}
+
 /**
  * i2c_dw_init() - Initialize the designware I2C master hardware
  * @dev: device private data
@@ -805,6 +858,8 @@ int i2c_dw_probe_master(struct dw_i2c_dev *dev)
 		dev_err(dev->dev, "failure adding adapter: %d\n", ret);
 	pm_runtime_put_noidle(dev->dev);
 
+	i2c_dw_configure_gpio(dev);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(i2c_dw_probe_master);
diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 63eeacc0baec..d6d760e393d8 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -22,6 +22,7 @@
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_gpio.h>
 #include <linux/platform_data/i2c-designware.h>
 #include <linux/platform_device.h>
 #include <linux/pm.h>
@@ -32,6 +33,7 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/suspend.h>
+#include <linux/gpio-starfive-vic.h>
 
 #include "i2c-designware-core.h"
 
@@ -45,12 +47,12 @@ static u32 starfive_i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
 {
 	u32 val;
 
-	if(!device_property_read_u32(dev->dev, "clock-frequency", &val)) {
-		dev_info(dev->dev, "Using 'clock-frequency' : %u / 1000", val);
+	if(!device_property_read_u32(dev->dev, "clocks", &val)) {
+		dev_info(dev->dev, "Using 'clocks' : %u / 1000", val);
 		return (val / 1000);
 	} else {
-		dev_info(dev->dev, "Using the static setting value: 1000");
-		return 1000;
+		dev_info(dev->dev, "Using the static setting value: 49500");
+		return 49500;
 	}
 }
 #endif
@@ -222,6 +224,7 @@ static const struct dmi_system_id dw_i2c_hwmon_class_dmi[] = {
 static int dw_i2c_plat_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
+	struct device_node *np = pdev->dev.of_node;
 	struct i2c_adapter *adap;
 	struct dw_i2c_dev *dev;
 	struct i2c_timings *t;
@@ -238,6 +241,8 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	dev->flags = (uintptr_t)device_get_match_data(&pdev->dev);
 	dev->dev = &pdev->dev;
 	dev->irq = irq;
+	dev->scl_gpio = of_get_named_gpio(np, "scl-gpio", 0);
+	dev->sda_gpio = of_get_named_gpio(np, "sda-gpio", 0);
 	platform_set_drvdata(pdev, dev);
 
 	ret = dw_i2c_plat_request_regs(dev);
diff --git a/usr/gen_initramfs_list.sh b/usr/gen_initramfs_list.sh
new file mode 100755
index 000000000000..0aad760fcd8c
--- /dev/null
+++ b/usr/gen_initramfs_list.sh
@@ -0,0 +1,328 @@
+#!/bin/sh
+# Copyright (C) Martin Schlemmer <azarah@nosferatu.za.org>
+# Copyright (C) 2006 Sam Ravnborg <sam@ravnborg.org>
+#
+# Released under the terms of the GNU GPL
+#
+# Generate a cpio packed initramfs. It uses gen_init_cpio to generate
+# the cpio archive, and then compresses it.
+# The script may also be used to generate the inputfile used for gen_init_cpio
+# This script assumes that gen_init_cpio is located in usr/ directory
+
+# error out on errors
+set -e
+
+usage() {
+cat << EOF
+Usage:
+$0 [-o <file>] [-u <uid>] [-g <gid>] {-d | <cpio_source>} ...
+	-o <file>      Create compressed initramfs file named <file> using
+		       gen_init_cpio and compressor depending on the extension
+	-u <uid>       User ID to map to user ID 0 (root).
+		       <uid> is only meaningful if <cpio_source> is a
+		       directory.  "squash" forces all files to uid 0.
+	-g <gid>       Group ID to map to group ID 0 (root).
+		       <gid> is only meaningful if <cpio_source> is a
+		       directory.  "squash" forces all files to gid 0.
+	<cpio_source>  File list or directory for cpio archive.
+		       If <cpio_source> is a .cpio file it will be used
+		       as direct input to initramfs.
+	-d             Output the default cpio list.
+
+All options except -o and -l may be repeated and are interpreted
+sequentially and immediately.  -u and -g states are preserved across
+<cpio_source> options so an explicit "-u 0 -g 0" is required
+to reset the root/group mapping.
+EOF
+}
+
+# awk style field access
+# $1 - field number; rest is argument string
+field() {
+	shift $1 ; echo $1
+}
+
+list_default_initramfs() {
+	# echo usr/kinit/kinit
+	:
+}
+
+default_initramfs() {
+	cat <<-EOF >> ${output}
+		# This is a very simple, default initramfs
+
+		dir /dev 0755 0 0
+		nod /dev/console 0600 0 0 c 5 1
+		dir /root 0700 0 0
+		# file /kinit usr/kinit/kinit 0755 0 0
+		# slink /init kinit 0755 0 0
+	EOF
+}
+
+filetype() {
+	local argv1="$1"
+
+	# symlink test must come before file test
+	if [ -L "${argv1}" ]; then
+		echo "slink"
+	elif [ -f "${argv1}" ]; then
+		echo "file"
+	elif [ -d "${argv1}" ]; then
+		echo "dir"
+	elif [ -b "${argv1}" -o -c "${argv1}" ]; then
+		echo "nod"
+	elif [ -p "${argv1}" ]; then
+		echo "pipe"
+	elif [ -S "${argv1}" ]; then
+		echo "sock"
+	else
+		echo "invalid"
+	fi
+	return 0
+}
+
+list_print_mtime() {
+	:
+}
+
+print_mtime() {
+	local my_mtime="0"
+
+	if [ -e "$1" ]; then
+		my_mtime=$(find "$1" -printf "%T@\n" | sort -r | head -n 1)
+	fi
+
+	echo "# Last modified: ${my_mtime}" >> ${output}
+	echo "" >> ${output}
+}
+
+list_parse() {
+	if [ -L "$1" ]; then
+		return
+	fi
+	echo "$1" | sed 's/:/\\:/g; s/$/ \\/'
+}
+
+# for each file print a line in following format
+# <filetype> <name> <path to file> <octal mode> <uid> <gid>
+# for links, devices etc the format differs. See gen_init_cpio for details
+parse() {
+	local location="$1"
+	local name="/${location#${srcdir}}"
+	# change '//' into '/'
+	name=$(echo "$name" | sed -e 's://*:/:g')
+	local mode="$2"
+	local uid="$3"
+	local gid="$4"
+	local ftype=$(filetype "${location}")
+	# remap uid/gid to 0 if necessary
+	[ "$root_uid" = "squash" ] && uid=0 || [ "$uid" -eq "$root_uid" ] && uid=0
+	[ "$root_gid" = "squash" ] && gid=0 || [ "$gid" -eq "$root_gid" ] && gid=0
+	local str="${mode} ${uid} ${gid}"
+
+	[ "${ftype}" = "invalid" ] && return 0
+	[ "${location}" = "${srcdir}" ] && return 0
+
+	case "${ftype}" in
+		"file")
+			str="${ftype} ${name} ${location} ${str}"
+			;;
+		"nod")
+			local dev=`LC_ALL=C ls -l "${location}"`
+			local maj=`field 5 ${dev}`
+			local min=`field 6 ${dev}`
+			maj=${maj%,}
+
+			[ -b "${location}" ] && dev="b" || dev="c"
+
+			str="${ftype} ${name} ${str} ${dev} ${maj} ${min}"
+			;;
+		"slink")
+			local target=`readlink "${location}"`
+			str="${ftype} ${name} ${target} ${str}"
+			;;
+		*)
+			str="${ftype} ${name} ${str}"
+			;;
+	esac
+
+	echo "${str}" >> ${output}
+
+	return 0
+}
+
+unknown_option() {
+	printf "ERROR: unknown option \"$arg\"\n" >&2
+	printf "If the filename validly begins with '-', " >&2
+	printf "then it must be prefixed\n" >&2
+	printf "by './' so that it won't be interpreted as an option." >&2
+	printf "\n" >&2
+	usage >&2
+	exit 1
+}
+
+list_header() {
+	:
+}
+
+header() {
+	printf "\n#####################\n# $1\n" >> ${output}
+}
+
+# process one directory (incl sub-directories)
+dir_filelist() {
+	${dep_list}header "$1"
+
+	srcdir=$(echo "$1" | sed -e 's://*:/:g')
+	dirlist=$(find "${srcdir}" -printf "%p %m %U %G\n" | LANG=C sort)
+
+	# If $dirlist is only one line, then the directory is empty
+	if [  "$(echo "${dirlist}" | wc -l)" -gt 1 ]; then
+		${dep_list}print_mtime "$1"
+
+		echo "${dirlist}" | \
+		while read x; do
+			${dep_list}parse ${x}
+		done
+	fi
+}
+
+# if only one file is specified and it is .cpio file then use it direct as fs
+# if a directory is specified then add all files in given direcotry to fs
+# if a regular file is specified assume it is in gen_initramfs format
+input_file() {
+	source="$1"
+	if [ -f "$1" ]; then
+		${dep_list}header "$1"
+		is_cpio="$(echo "$1" | sed 's/^.*\.cpio\(\..*\)\{0,1\}/cpio/')"
+		if [ $2 -eq 0 -a ${is_cpio} = "cpio" ]; then
+			cpio_file=$1
+			echo "$1" | grep -q '^.*\.cpio\..*' && is_cpio_compressed="compressed"
+			[ ! -z ${dep_list} ] && echo "$1"
+			return 0
+		fi
+		if [ -z ${dep_list} ]; then
+			print_mtime "$1" >> ${output}
+			cat "$1"         >> ${output}
+		else
+		        echo "$1 \\"
+			cat "$1" | while read type dir file perm ; do
+				if [ "$type" = "file" ]; then
+					echo "$file \\";
+				fi
+			done
+		fi
+	elif [ -d "$1" ]; then
+		dir_filelist "$1"
+	else
+		echo "  ${prog}: Cannot open '$1'" >&2
+		exit 1
+	fi
+}
+
+prog=$0
+root_uid=0
+root_gid=0
+dep_list=
+cpio_file=
+cpio_list=
+output="/dev/stdout"
+output_file=""
+is_cpio_compressed=
+compr="gzip -n -9 -f"
+
+arg="$1"
+case "$arg" in
+	"-l")	# files included in initramfs - used by kbuild
+		dep_list="list_"
+		echo "deps_initramfs := $0 \\"
+		shift
+		;;
+	"-o")	# generate compressed cpio image named $1
+		shift
+		output_file="$1"
+		cpio_list="$(mktemp ${TMPDIR:-/tmp}/cpiolist.XXXXXX)"
+		output=${cpio_list}
+		echo "$output_file" | grep -q "\.gz$" \
+                && [ -x "`which gzip 2> /dev/null`" ] \
+                && compr="gzip -n -9 -f"
+		echo "$output_file" | grep -q "\.bz2$" \
+                && [ -x "`which bzip2 2> /dev/null`" ] \
+                && compr="bzip2 -9 -f"
+		echo "$output_file" | grep -q "\.lzma$" \
+                && [ -x "`which lzma 2> /dev/null`" ] \
+                && compr="lzma -9 -f"
+		echo "$output_file" | grep -q "\.xz$" \
+                && [ -x "`which xz 2> /dev/null`" ] \
+                && compr="xz --check=crc32 --lzma2=dict=1MiB"
+		echo "$output_file" | grep -q "\.lzo$" \
+                && [ -x "`which lzop 2> /dev/null`" ] \
+                && compr="lzop -9 -f"
+		echo "$output_file" | grep -q "\.lz4$" \
+                && [ -x "`which lz4 2> /dev/null`" ] \
+                && compr="lz4 -l -9 -f"
+		echo "$output_file" | grep -q "\.cpio$" && compr="cat"
+		shift
+		;;
+esac
+while [ $# -gt 0 ]; do
+	arg="$1"
+	shift
+	case "$arg" in
+		"-u")	# map $1 to uid=0 (root)
+			root_uid="$1"
+			[ "$root_uid" = "-1" ] && root_uid=$(id -u || echo 0)
+			shift
+			;;
+		"-g")	# map $1 to gid=0 (root)
+			root_gid="$1"
+			[ "$root_gid" = "-1" ] && root_gid=$(id -g || echo 0)
+			shift
+			;;
+		"-d")	# display default initramfs list
+			default_list="$arg"
+			${dep_list}default_initramfs
+			;;
+		"-h")
+			usage
+			exit 0
+			;;
+		*)
+			case "$arg" in
+				"-"*)
+					unknown_option
+					;;
+				*)	# input file/dir - process it
+					input_file "$arg" "$#"
+					;;
+			esac
+			;;
+	esac
+done
+
+# If output_file is set we will generate cpio archive and compress it
+# we are careful to delete tmp files
+if [ ! -z ${output_file} ]; then
+	if [ -z ${cpio_file} ]; then
+		timestamp=
+		if test -n "$KBUILD_BUILD_TIMESTAMP"; then
+			timestamp="$(date -d"$KBUILD_BUILD_TIMESTAMP" +%s || :)"
+			if test -n "$timestamp"; then
+				timestamp="-t $timestamp"
+			fi
+		fi
+		cpio_tfile="$(mktemp ${TMPDIR:-/tmp}/cpiofile.XXXXXX)"
+		usr/gen_init_cpio $timestamp ${cpio_list} > ${cpio_tfile}
+	else
+		cpio_tfile=${cpio_file}
+	fi
+	rm ${cpio_list}
+	if [ "${is_cpio_compressed}" = "compressed" ]; then
+		cat ${cpio_tfile} > ${output_file}
+	else
+		(cat ${cpio_tfile} | ${compr}  - > ${output_file}) \
+		|| (rm -f ${output_file} ; false)
+	fi
+	[ -z ${cpio_file} ] && rm ${cpio_tfile}
+fi
+exit 0
-- 
2.30.0

