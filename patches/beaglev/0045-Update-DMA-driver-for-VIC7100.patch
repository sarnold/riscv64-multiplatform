From b0e974f75b6e6f8abfc8d4b7ba8435c7aa409ac3 Mon Sep 17 00:00:00 2001
From: Tom <support@vamrs.com>
Date: Thu, 7 Jan 2021 01:52:42 +0800
Subject: [PATCH 45/79] Update DMA driver for VIC7100.

---
 .../dma/dw-axi-dmac/dw-axi-dmac-platform.c    | 103 +++++++++++++++---
 drivers/dma/dw-axi-dmac/dw-axi-dmac.h         |  36 +++++-
 2 files changed, 119 insertions(+), 20 deletions(-)

diff --git a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
index 14c1ac26f866..bdd775b38f0b 100644
--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
+++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
@@ -27,6 +27,8 @@
 #include "../dmaengine.h"
 #include "../virt-dma.h"
 
+#include <soc/starfive/vic7100.h>
+
 /*
  * The set of bus widths supported by the DMA controller. DW AXI DMAC supports
  * master data bus width up to 512 bits (for both AXI master interfaces), but
@@ -143,24 +145,43 @@ static inline u32 axi_chan_irq_read(struct axi_dma_chan *chan)
 	return axi_chan_ioread32(chan, CH_INTSTATUS);
 }
 
+static inline bool axi_chan_get_nr8(struct axi_dma_chan *chan)
+{
+	return chan->chip->flag->nr_chan_8;
+}
+
 static inline void axi_chan_disable(struct axi_dma_chan *chan)
 {
 	u32 val;
 
-	val = axi_dma_ioread32(chan->chip, DMAC_CHEN);
-	val &= ~(BIT(chan->id) << DMAC_CHAN_EN_SHIFT);
-	val |=   BIT(chan->id) << DMAC_CHAN_EN_WE_SHIFT;
-	axi_dma_iowrite32(chan->chip, DMAC_CHEN, val);
+	if(axi_chan_get_nr8(chan)) {
+		val = axi_dma_ioread32(chan->chip, DMAC_CHEN_8);
+		val &= ~(BIT(chan->id) << DMAC_CHAN_EN_SHIFT_8);
+		val |=   BIT(chan->id) << DMAC_CHAN_EN_WE_SHIFT_8;
+		axi_dma_iowrite32(chan->chip, DMAC_CHEN_8, val);
+	} else {
+		val = axi_dma_ioread32(chan->chip, DMAC_CHEN);
+		val &= ~(BIT(chan->id) << DMAC_CHAN_EN_SHIFT);
+		val |=   BIT(chan->id) << DMAC_CHAN_EN_WE_SHIFT;
+		axi_dma_iowrite32(chan->chip, DMAC_CHEN, val);
+	}
 }
 
 static inline void axi_chan_enable(struct axi_dma_chan *chan)
 {
 	u32 val;
 
-	val = axi_dma_ioread32(chan->chip, DMAC_CHEN);
-	val |= BIT(chan->id) << DMAC_CHAN_EN_SHIFT |
-	       BIT(chan->id) << DMAC_CHAN_EN_WE_SHIFT;
-	axi_dma_iowrite32(chan->chip, DMAC_CHEN, val);
+	if(axi_chan_get_nr8(chan)) {
+		val = axi_dma_ioread32(chan->chip, DMAC_CHEN_8);
+		val |= BIT(chan->id) << DMAC_CHAN_EN_SHIFT_8 |
+			BIT(chan->id) << DMAC_CHAN_EN_WE_SHIFT_8;
+		axi_dma_iowrite32(chan->chip, DMAC_CHEN_8, val);
+	} else {
+		val = axi_dma_ioread32(chan->chip, DMAC_CHEN);
+		val |= BIT(chan->id) << DMAC_CHAN_EN_SHIFT |
+			BIT(chan->id) << DMAC_CHAN_EN_WE_SHIFT;
+		axi_dma_iowrite32(chan->chip, DMAC_CHEN, val);
+	}
 }
 
 static inline bool axi_chan_is_hw_enable(struct axi_dma_chan *chan)
@@ -272,6 +293,7 @@ static void write_chan_llp(struct axi_dma_chan *chan, dma_addr_t adr)
 static void axi_chan_block_xfer_start(struct axi_dma_chan *chan,
 				      struct axi_dma_desc *first)
 {
+	struct axi_dma_desc *desc;
 	u32 priority = chan->chip->dw->hdata->priority[chan->id];
 	u32 reg, irq_mask;
 	u8 lms = 0; /* Select AXI0 master for LLI fetching */
@@ -304,6 +326,23 @@ static void axi_chan_block_xfer_start(struct axi_dma_chan *chan,
 	irq_mask |= DWAXIDMAC_IRQ_SUSPENDED;
 	axi_chan_irq_set(chan, irq_mask);
 
+    /*flush all the desc */
+#ifdef CONFIG_SOC_STARFIVE_VIC7100
+	if(chan->chip->flag->need_flush) {
+		/*flush fisrt desc*/
+		starfive_flush_dcache(first->vd.tx.phys, sizeof(*first));
+
+		list_for_each_entry(desc, &first->xfer_list, xfer_list) {
+			starfive_flush_dcache(desc->vd.tx.phys, sizeof(*desc));
+
+			dev_dbg(chan->chip->dev,
+				"sar:%#llx dar:%#llx llp:%#llx ctl:0x%x:%08x\n",
+				desc->lli.sar, desc->lli.dar, desc->lli.llp,
+				desc->lli.ctl_hi, desc->lli.ctl_lo);
+		}
+	}
+#endif
+
 	axi_chan_enable(chan);
 }
 
@@ -614,8 +653,10 @@ static irqreturn_t dw_axi_dma_interrupt(int irq, void *dev_id)
 
 		if (status & DWAXIDMAC_IRQ_ALL_ERR)
 			axi_chan_handle_err(chan, status);
-		else if (status & DWAXIDMAC_IRQ_DMA_TRF)
+		else if (status & DWAXIDMAC_IRQ_DMA_TRF) {
 			axi_chan_block_xfer_complete(chan);
+			dev_info(chip->dev, "axi_chan_block_xfer_complete.\n");
+	}
 	}
 
 	/* Re-enable interrupts */
@@ -654,10 +695,17 @@ static int dma_chan_pause(struct dma_chan *dchan)
 
 	spin_lock_irqsave(&chan->vc.lock, flags);
 
-	val = axi_dma_ioread32(chan->chip, DMAC_CHEN);
-	val |= BIT(chan->id) << DMAC_CHAN_SUSP_SHIFT |
-	       BIT(chan->id) << DMAC_CHAN_SUSP_WE_SHIFT;
-	axi_dma_iowrite32(chan->chip, DMAC_CHEN, val);
+	if(axi_chan_get_nr8(chan)){
+		val = axi_dma_ioread32(chan->chip, DMAC_CHSUSP_8);
+		val |= BIT(chan->id) << DMAC_CHAN_SUSP_SHIFT_8 |
+			BIT(chan->id) << DMAC_CHAN_SUSP_WE_SHIFT_8;
+		axi_dma_iowrite32(chan->chip, DMAC_CHSUSP_8, val);
+	} else {
+		val = axi_dma_ioread32(chan->chip, DMAC_CHSUSP);
+		val |= BIT(chan->id) << DMAC_CHAN_SUSP_SHIFT |
+			BIT(chan->id) << DMAC_CHAN_SUSP_WE_SHIFT;
+		axi_dma_iowrite32(chan->chip, DMAC_CHSUSP, val);
+	}
 
 	do  {
 		if (axi_chan_irq_read(chan) & DWAXIDMAC_IRQ_SUSPENDED)
@@ -680,11 +728,17 @@ static inline void axi_chan_resume(struct axi_dma_chan *chan)
 {
 	u32 val;
 
-	val = axi_dma_ioread32(chan->chip, DMAC_CHEN);
-	val &= ~(BIT(chan->id) << DMAC_CHAN_SUSP_SHIFT);
-	val |=  (BIT(chan->id) << DMAC_CHAN_SUSP_WE_SHIFT);
-	axi_dma_iowrite32(chan->chip, DMAC_CHEN, val);
-
+	if(axi_chan_get_nr8(chan)){
+		val = axi_dma_ioread32(chan->chip, DMAC_CHSUSP_8);
+		val &= ~(BIT(chan->id) << DMAC_CHAN_SUSP_SHIFT_8);
+		val |=  (BIT(chan->id) << DMAC_CHAN_SUSP_WE_SHIFT_8);
+		axi_dma_iowrite32(chan->chip, DMAC_CHSUSP_8, val);
+	} else {
+		val = axi_dma_ioread32(chan->chip, DMAC_CHSUSP);
+		val &= ~(BIT(chan->id) << DMAC_CHAN_SUSP_SHIFT);
+		val |=  (BIT(chan->id) << DMAC_CHAN_SUSP_WE_SHIFT);
+		axi_dma_iowrite32(chan->chip, DMAC_CHSUSP, val);
+	}
 	chan->is_paused = false;
 }
 
@@ -760,6 +814,13 @@ static int parse_device_properties(struct axi_dma_chip *chip)
 
 	chip->dw->hdata->nr_channels = tmp;
 
+	if(chip->dw->hdata->nr_channels > 8){
+		chip->flag->nr_chan_8 = true;
+#ifdef CONFIG_SOC_STARFIVE_VIC7100
+		chip->flag->need_flush = true;
+#endif
+	}
+
 	ret = device_property_read_u32(dev, "snps,dma-masters", &tmp);
 	if (ret)
 		return ret;
@@ -820,6 +881,7 @@ static int dw_probe(struct platform_device *pdev)
 	struct resource *mem;
 	struct dw_axi_dma *dw;
 	struct dw_axi_dma_hcfg *hdata;
+	struct dw_dma_flag *flag;
 	u32 i;
 	int ret;
 
@@ -835,9 +897,14 @@ static int dw_probe(struct platform_device *pdev)
 	if (!hdata)
 		return -ENOMEM;
 
+	flag = devm_kzalloc(&pdev->dev, sizeof(*flag), GFP_KERNEL);
+	if (!flag)
+		return -ENOMEM;
+
 	chip->dw = dw;
 	chip->dev = &pdev->dev;
 	chip->dw->hdata = hdata;
+	chip->flag = flag;
 
 	chip->irq = platform_get_irq(pdev, 0);
 	if (chip->irq < 0)
diff --git a/drivers/dma/dw-axi-dmac/dw-axi-dmac.h b/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
index 18b6014cf9b4..0a50e1a3cddc 100644
--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
+++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
@@ -5,6 +5,8 @@
  * Synopsys DesignWare AXI DMA Controller driver.
  *
  * Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
+ *         Samin.guo <samin.guo@starfivetech.com>
+ *                 add support for (channels > 8). 2020.
  */
 
 #ifndef _AXI_DMA_PLATFORM_H
@@ -18,10 +20,17 @@
 
 #include "../virt-dma.h"
 
-#define DMAC_MAX_CHANNELS	8
+#define DMAC_MAX_CHANNELS	16
 #define DMAC_MAX_MASTERS	2
 #define DMAC_MAX_BLK_SIZE	0x200000
 
+struct dw_dma_flag {
+	bool nr_chan_8;
+#ifdef CONFIG_SOC_STARFIVE_VIC7100
+	bool need_flush;
+#endif
+};
+
 struct dw_axi_dma_hcfg {
 	u32	nr_channels;
 	u32	nr_masters;
@@ -61,6 +70,7 @@ struct axi_dma_chip {
 	struct clk		*core_clk;
 	struct clk		*cfgr_clk;
 	struct dw_axi_dma	*dw;
+	struct dw_dma_flag	*flag;
 };
 
 /* LLI == Linked List Item */
@@ -124,6 +134,15 @@ static inline struct axi_dma_chan *dchan_to_axi_dma_chan(struct dma_chan *dchan)
 #define DMAC_CHEN		0x018 /* R/W DMAC Channel Enable */
 #define DMAC_CHEN_L		0x018 /* R/W DMAC Channel Enable 00-31 */
 #define DMAC_CHEN_H		0x01C /* R/W DMAC Channel Enable 32-63 */
+#define DMAC_CHSUSP		0x018 /* R/W DMAC Channel suspend */
+#define DMAC_CHABORT		0x018 /* R/W DMAC Channel Abort */
+
+#define DMAC_CHEN_8		0x018 /* R/W DMAC Channel Enable */
+#define DMAC_CHEN_L_8		0x018 /* R/W DMAC Channel Enable */
+#define DMAC_CHEN_H_8		0x01C /* R/W DMAC Channel Enable */
+#define DMAC_CHSUSP_8		0x020 /* R/W DMAC Channel Suspend */
+#define DMAC_CHABORT_8		0x028 /* R/W DMAC Channel Abort */
+
 #define DMAC_INTSTATUS		0x030 /* R DMAC Interrupt Status */
 #define DMAC_COMMON_INTCLEAR	0x038 /* W DMAC Interrupt Clear */
 #define DMAC_COMMON_INTSTATUS_ENA 0x040 /* R DMAC Interrupt Status Enable */
@@ -171,6 +190,19 @@ static inline struct axi_dma_chan *dchan_to_axi_dma_chan(struct dma_chan *dchan)
 #define DMAC_CHAN_SUSP_SHIFT		16
 #define DMAC_CHAN_SUSP_WE_SHIFT		24
 
+#define DMAC_CHAN_ABORT_SHIFT		32
+#define DMAC_CHAN_ABORT_WE_SHIFT	40
+
+
+#define DMAC_CHAN_EN_SHIFT_8		0
+#define DMAC_CHAN_EN_WE_SHIFT_8		16
+
+#define DMAC_CHAN_SUSP_SHIFT_8		0
+#define DMAC_CHAN_SUSP_WE_SHIFT_8	16
+
+#define DMAC_CHAN_ABORT_SHIFT_8		0
+#define DMAC_CHAN_ABORT_WE_SHIFT_8	16
+
 /* CH_CTL_H */
 #define CH_CTL_H_ARLEN_EN		BIT(6)
 #define CH_CTL_H_ARLEN_POS		7
@@ -227,7 +259,7 @@ enum {
 #define CH_CTL_L_SRC_MAST		BIT(0)
 
 /* CH_CFG_H */
-#define CH_CFG_H_PRIORITY_POS		17
+#define CH_CFG_H_PRIORITY_POS		15
 #define CH_CFG_H_HS_SEL_DST_POS		4
 #define CH_CFG_H_HS_SEL_SRC_POS		3
 enum {
-- 
2.30.0

