From c600fe3e7be8709d6c43c7df47b3b7937c67d393 Mon Sep 17 00:00:00 2001
From: "yiming.li" <yiming.li@starfivetech.com>
Date: Fri, 2 Apr 2021 07:48:22 +0000
Subject: [PATCH 79/79] 1. add clk for PWM & fixup cat /sys period data error
 2. Clear PWM CNTR after modified period & duty_cycle

---
 drivers/Makefile             |  2 +-
 drivers/pwm/pwm-sifive-ptc.c | 96 +++++++++++++++++++++++-------------
 2 files changed, 63 insertions(+), 35 deletions(-)

diff --git a/drivers/Makefile b/drivers/Makefile
index 576228037718..d4dd277de2ba 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -14,7 +14,6 @@ obj-$(CONFIG_GENERIC_PHY)	+= phy/
 # GPIO must come after pinctrl as gpios may need to mux pins etc
 obj-$(CONFIG_PINCTRL)		+= pinctrl/
 obj-$(CONFIG_GPIOLIB)		+= gpio/
-obj-y				+= pwm/
 
 obj-y				+= pci/
 
@@ -38,6 +37,7 @@ obj-y				+= clk/
 # really early.
 obj-$(CONFIG_DMADEVICES)	+= dma/
 
+obj-y				+= pwm/
 # SOC specific infrastructure drivers.
 obj-y				+= soc/
 
diff --git a/drivers/pwm/pwm-sifive-ptc.c b/drivers/pwm/pwm-sifive-ptc.c
index a8be2a788d63..d3c8ea34970e 100644
--- a/drivers/pwm/pwm-sifive-ptc.c
+++ b/drivers/pwm/pwm-sifive-ptc.c
@@ -14,40 +14,40 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 
-#define PTC_DEBUG			0
-
 /* max channel of pwm */
-#define MAX_PWM				8
+#define MAX_PWM								8
 
 /* PTC Register offsets */
-#define REG_RPTC_CNTR			0x0
-#define REG_RPTC_HRC			0x4
-#define REG_RPTC_LRC			0x8
-#define REG_RPTC_CTRL			0xC
+#define REG_RPTC_CNTR 						0x0
+#define REG_RPTC_HRC						0x4
+#define REG_RPTC_LRC						0x8
+#define REG_RPTC_CTRL						0xC
 
 /* Bit for PWM clock */
-#define BIT_PWM_CLOCK_EN		31
+#define BIT_PWM_CLOCK_EN					31
 
 /* Bit for clock gen soft reset */
-#define BIT_CLK_GEN_SOFT_RESET		13
+#define BIT_CLK_GEN_SOFT_RESET				13
+
+#define NS_1                                1000000000
 
-#define NS_1				1000000000
+#define PTC_DEBUG  0
 
 /* Access PTC register (cntr hrc lrc and ctrl) ,need to replace PWM_BASE_ADDR */
-#define REG_PTC_BASE_ADDR_SUB(base, N)	((base) + ((N>3)?((N-4)*0x10+(1<<15)):(N*0x10)))
-#define REG_PTC_RPTC_CNTR(base,N)	(REG_PTC_BASE_ADDR_SUB(base,N))
-#define REG_PTC_RPTC_HRC(base,N)	(REG_PTC_BASE_ADDR_SUB(base,N) + 0x4)
-#define REG_PTC_RPTC_LRC(base,N)	(REG_PTC_BASE_ADDR_SUB(base,N) + 0x8)
-#define REG_PTC_RPTC_CTRL(base,N)	(REG_PTC_BASE_ADDR_SUB(base,N) + 0xC)
+#define REG_PTC_BASE_ADDR_SUB(base, N)    ((base) + ((N>3)?((N-4)*0x10+(1<<15)):(N*0x10)))
+#define REG_PTC_RPTC_CNTR(base,N)		(REG_PTC_BASE_ADDR_SUB(base,N))
+#define REG_PTC_RPTC_HRC(base,N)			(REG_PTC_BASE_ADDR_SUB(base,N) + 0x4)
+#define REG_PTC_RPTC_LRC(base,N)			(REG_PTC_BASE_ADDR_SUB(base,N) + 0x8)
+#define REG_PTC_RPTC_CTRL(base,N)		(REG_PTC_BASE_ADDR_SUB(base,N) + 0xC)
 
 /* pwm ptc device */
 struct sifive_pwm_ptc_device {
-	struct pwm_chip	chip;
-	struct clk	*clk;
-	void __iomem	*regs;
-	int		irq;
+	struct pwm_chip		chip;
+	struct clk		*clk;
+	void __iomem		*regs;
+	int 			irq;
 	/* apb clock frequency , from dts */
-	unsigned int	approx_period;
+	unsigned int		approx_period;
 };
 
 static inline struct sifive_pwm_ptc_device *chip_to_sifive_ptc(struct pwm_chip *c)
@@ -65,15 +65,15 @@ static void sifive_pwm_ptc_get_state(struct pwm_chip *chip, struct pwm_device *d
 	uint32_t pwm_clk_ns = 0;
 
 	/* get lrc and hrc data from registe*/
-	data_lrc = ioread32(REG_PTC_RPTC_LRC(pwm->regs, dev->hwpwm));
-	data_hrc = ioread32(REG_PTC_RPTC_HRC(pwm->regs, dev->hwpwm));
-	period = data_lrc + data_hrc;
+	data_lrc = ioread32(REG_PTC_RPTC_LRC(pwm->regs,dev->hwpwm));
+	data_hrc = ioread32(REG_PTC_RPTC_HRC(pwm->regs,dev->hwpwm));
+	//period = data_lrc + data_hrc;
 
 	/* how many ns does apb clock elapse */
 	pwm_clk_ns = NS_1 / pwm->approx_period;
 
 	/* pwm period(ns) */
-	state->period     = period*pwm_clk_ns;
+	state->period     = data_lrc*pwm_clk_ns;
 
 	/* duty cycle(ns) ,means high level eclapse ns if it is normal polarity */
 	state->duty_cycle = data_hrc*pwm_clk_ns;
@@ -83,6 +83,15 @@ static void sifive_pwm_ptc_get_state(struct pwm_chip *chip, struct pwm_device *d
 
 	/* enabled or not */
 	state->enabled    = 1;
+#if PTC_DEBUG
+	printk("sifive_pwm_ptc_get_state in,no:%d....\r\n",dev->hwpwm);
+	printk("data_hrc:0x%x 0x%x \n", data_hrc, data_lrc);
+        printk("period:%d\r\n",state->period);
+        printk("duty_cycle:%d\r\n",state->duty_cycle);
+        printk("polarity:%d\r\n",state->polarity);
+	printk("enabled:%d\r\n",state->enabled);
+#endif
+
 }
 
 
@@ -106,7 +115,9 @@ static int sifive_pwm_ptc_apply(struct pwm_chip *chip, struct pwm_device *dev, s
 #endif
 	/* duty_cycle should be less or equal than period */
 	if(state->duty_cycle > state->period)
+	{
 		state->duty_cycle = state->period;
+	}
 
 	/* calculate pwm real period (ns) */
 	pwm_clk_ns = NS_1 / pwm->approx_period;
@@ -119,29 +130,36 @@ static int sifive_pwm_ptc_apply(struct pwm_chip *chip, struct pwm_device *dev, s
 	period_data = state->period / pwm_clk_ns;
 
 	if (!state->enabled)
+	{
 		/* if is unenable,just set duty_dat to 0 , means low level always */
 		duty_data = 0;
+	}
 	else
+	{
 		/* calculate duty count*/
 		duty_data = state->duty_cycle / pwm_clk_ns;
+	}
 
 #if PTC_DEBUG
 	printk("period_data:%d,duty_data:%d\r\n",period_data,duty_data);
 #endif
 
 	if(state->polarity == PWM_POLARITY_NORMAL)
+	{
 		/* calculate data_hrc */
 		data_hrc = period_data - duty_data;
+	}
 	else
+	{
 		/* calculate data_hrc */
 		data_hrc = duty_data;
-
+	}
 	data_lrc = period_data;
 
 	/* set hrc */
-	reg_addr = REG_PTC_RPTC_HRC(pwm->regs, dev->hwpwm);
+	reg_addr = REG_PTC_RPTC_HRC(pwm->regs,dev->hwpwm);
 #if PTC_DEBUG
-	printk("[sifive_pwm_ptc_config]reg_addr:0x%lx,data:0x%d....\n",reg_addr,data_hrc);
+	printk("[sifive_pwm_ptc_config]reg_addr:0x%lx,data:%d....\n",reg_addr,data_hrc);
 #endif
 	iowrite32(data_hrc, reg_addr);
 
@@ -150,9 +168,9 @@ static int sifive_pwm_ptc_apply(struct pwm_chip *chip, struct pwm_device *dev, s
 #endif
 
 	/* set lrc */
-	reg_addr = REG_PTC_RPTC_LRC(pwm->regs, dev->hwpwm);
+	reg_addr = REG_PTC_RPTC_LRC(pwm->regs,dev->hwpwm);
 #if PTC_DEBUG
-	printk("[sifive_pwm_ptc_config]reg_addr:0x%lx,data:0x%d....\n",reg_addr,data_lrc);
+	printk("[sifive_pwm_ptc_config]reg_addr:0x%lx,data:%d....\n",reg_addr,data_lrc);
 #endif
 
 	iowrite32(data_lrc, reg_addr);
@@ -160,6 +178,9 @@ static int sifive_pwm_ptc_apply(struct pwm_chip *chip, struct pwm_device *dev, s
 #if PTC_DEBUG
 	printk("[sifive_pwm_ptc_config]lrc ok....\n");
 #endif
+        /* set REG_RPTC_CNTR*/
+        reg_addr = REG_PTC_RPTC_CNTR(pwm->regs, dev->hwpwm);
+        iowrite32(0, reg_addr);
 
 	return 0;
 }
@@ -168,7 +189,7 @@ static int sifive_pwm_ptc_apply(struct pwm_chip *chip, struct pwm_device *dev, s
 
 static const struct pwm_ops sifive_pwm_ptc_ops = {
 	.get_state	= sifive_pwm_ptc_get_state,
-	.apply		= (void *)sifive_pwm_ptc_apply,
+	.apply		= (void*)sifive_pwm_ptc_apply,
 	.owner		= THIS_MODULE,
 };
 
@@ -202,10 +223,11 @@ static int sifive_pwm_ptc_probe(struct platform_device *pdev)
 	chip->base = -1;
 
 	/* get pwm channels count, max value is 8 */
-	ret = of_property_read_u32(node, "sifive,npwm", &chip->npwm);
+	ret = of_property_read_u32(node, "starfive,npwm", &chip->npwm);
 	if (ret < 0 || chip->npwm > MAX_PWM)
+	{
 		chip->npwm = MAX_PWM;
-
+	}
 #if PTC_DEBUG
 	printk("[sifive_pwm_ptc_probe] npwm:0x%lx....\r\n",chip->npwm);
 #endif
@@ -232,6 +254,12 @@ static int sifive_pwm_ptc_probe(struct platform_device *pdev)
 	printk("[sifive_pwm_ptc_probe] regs:0x%lx....\r\n",pwm->regs);
 #endif
 
+	pwm->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(pwm->clk)) {
+		dev_err(dev, "Unable to find controller clock\n");
+		return PTR_ERR(pwm->clk);
+	}
+
 	/* after add,it will display as /sys/class/pwm/pwmchip0,0 is chip->base
 	 * after execute echo 0 > export in  , pwm0 can be seen */
 	ret = pwmchip_add(chip);
@@ -258,8 +286,8 @@ static int sifive_pwm_ptc_remove(struct platform_device *dev)
 }
 
 static const struct of_device_id sifive_pwm_ptc_of_match[] = {
-	{ .compatible = "sifive,pwm0" },
-	{ },
+	{ .compatible = "starfive,pwm0" },
+	{},
 };
 MODULE_DEVICE_TABLE(of, sifive_pwm_ptc_of_match);
 
-- 
2.30.0

