From 9d3cf3894be765b9903a1b40ef3f5f019a8e346e Mon Sep 17 00:00:00 2001
From: Tom <support@vamrs.com>
Date: Fri, 8 Jan 2021 04:01:19 +0800
Subject: [PATCH 49/86] improve stmicro stmmac driver by configuring gtxclk
 based on speed

---
 .../net/ethernet/stmicro/stmmac/stmmac_main.c | 44 +++++++++++++++----
 1 file changed, 36 insertions(+), 8 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index cff104c76c32..427b4718ffe4 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -932,6 +932,10 @@ static void stmmac_mac_link_up(struct phylink_config *config,
 {
 	struct stmmac_priv *priv = netdev_priv(to_net_dev(config->dev));
 	u32 ctrl;
+#ifdef CONFIG_SOC_STARFIVE_VIC7100
+	u32	value;
+	void	*addr;
+#endif
 
 	stmmac_xpcs_link_up(priv, &priv->hw->xpcs_args, speed, interface);
 
@@ -979,18 +983,32 @@ static void stmmac_mac_link_up(struct phylink_config *config,
 			return;
 		}
 	} else {
+#ifdef CONFIG_SOC_STARFIVE_VIC7100
+		addr = ioremap(0x118001ec, 0x4);
+		value = readl(addr);
+		value &= ~(0xFF);
+#endif
 		switch (speed) {
 		case SPEED_2500:
 			ctrl |= priv->hw->link.speed2500;
 			break;
 		case SPEED_1000:
 			ctrl |= priv->hw->link.speed1000;
+#ifdef CONFIG_SOC_STARFIVE_VIC7100
+			value |= 0x4;
+#endif
 			break;
 		case SPEED_100:
 			ctrl |= priv->hw->link.speed100;
+#ifdef CONFIG_SOC_STARFIVE_VIC7100
+			value |= 0x14;
+#endif
 			break;
 		case SPEED_10:
 			ctrl |= priv->hw->link.speed10;
+#ifdef CONFIG_SOC_STARFIVE_VIC7100
+			value |= 0xc8;
+#endif
 			break;
 		default:
 			return;
@@ -999,8 +1017,18 @@ static void stmmac_mac_link_up(struct phylink_config *config,
 
 	priv->speed = speed;
 
-	if (priv->plat->fix_mac_speed)
+	if (priv->plat->fix_mac_speed) {
+#ifdef CONFIG_SOC_STARFIVE_VIC7100
+		/*0x118001ec地址为mac的时钟分频寄存器，低8位为分频值
+		 *mac的root时钟为500M,gtxclk需求的时钟如下：
+		 *1000M: gtxclk为125M，分频值为500/125=0x4
+		 *100M: gtxclk为25M，分频值为500/25=0x14
+		 *10M:gtxclk为2.5M，分频值为500/2.5=0xc8*/
+		writel(value, addr); /*set gmac gtxclk*/
+		iounmap(addr);
+#endif
 		priv->plat->fix_mac_speed(priv->plat->bsp_priv, speed);
+	}
 
 	if (!duplex)
 		ctrl &= ~priv->hw->link.duplex;
@@ -1258,9 +1286,9 @@ static void stmmac_clear_tx_descriptors(struct stmmac_priv *priv, u32 queue)
 #ifdef FLUSH_TX_DESC_ENABLE
 	unsigned long len;
 	if (priv->extend_desc)
-		len = DMA_TX_SIZE * sizeof(struct dma_extended_desc);
+		len = DMA_DEFAULT_TX_SIZE * sizeof(struct dma_extended_desc);
 	else
-		len = DMA_TX_SIZE * sizeof(struct dma_desc);
+		len = DMA_DEFAULT_TX_SIZE * sizeof(struct dma_desc);
 
 	stmmac_flush_dcache(tx_q->dma_tx_phy, len);
 #endif
@@ -1509,9 +1537,9 @@ static int init_dma_tx_desc_rings(struct net_device *dev)
 #ifdef FLUSH_TX_DESC_ENABLE
 		unsigned long len;
 		if (priv->extend_desc)
-			len = DMA_TX_SIZE * sizeof(struct dma_extended_desc);
+			len = DMA_DEFAULT_TX_SIZE * sizeof(struct dma_extended_desc);
 		else
-			len = DMA_TX_SIZE * sizeof(struct dma_desc);
+			len = DMA_DEFAULT_TX_SIZE * sizeof(struct dma_desc);
 
 		stmmac_flush_dcache(tx_q->dma_tx_phy, len);
 #endif
@@ -2164,9 +2192,9 @@ static void stmmac_tx_err(struct stmmac_priv *priv, u32 chan)
 #ifdef FLUSH_TX_DESC_ENABLE
 	unsigned long len;
 	if (priv->extend_desc)
-		len = DMA_TX_SIZE * sizeof(struct dma_extended_desc);
+		len = DMA_DEFAULT_TX_SIZE * sizeof(struct dma_extended_desc);
 	else
-		len = DMA_TX_SIZE * sizeof(struct dma_desc);
+		len = DMA_DEFAULT_TX_SIZE * sizeof(struct dma_desc);
 
 	stmmac_flush_dcache(tx_q->dma_tx_phy, len);
 #endif
@@ -3708,7 +3736,7 @@ static netdev_tx_t stmmac_xmit(struct sk_buff *skb, struct net_device *dev)
 	else
 		desc_size = sizeof(struct dma_desc);
 
-	entry = STMMAC_GET_ENTRY(entry, DMA_TX_SIZE);
+	entry = STMMAC_GET_ENTRY(entry, DMA_DEFAULT_TX_SIZE);
 	tx_q->cur_tx = entry;
 
 	tx_q->tx_tail_addr = tx_q->dma_tx_phy + (tx_q->cur_tx * desc_size);
-- 
2.30.0

